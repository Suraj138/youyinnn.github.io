<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script src="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@latest/myjs/loadscripts.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@latest/myjs/jump-1.4.js"></script> -->
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@latest/img/favicon.ico" />
    <link rel="icon" href="/img/favicon.ico" type="image/ico"/>
    <link rel="stylesheet" href="/mycss/style.css">

    <script src="/myjs/scriptlist.js"></script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg">🚀</button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <div id="homepage-center">
            <div id="slogan">
                <i id="wolf-logo" style="font-style: normal;" class="mr-4">🌑</i><span id="slogan-text"></span>
            </div>
            <div id="homepage-btn">
                <div id="showmore"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; About Me & This Blog</div>
                <div id="showhacknical"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; My Github Analysis</div>
                <div id="toarticles"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; My Tech Articles</div>
            </div>
        </div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistics</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Online:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Chars:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Categories:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tags:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Last update:</td>
                    <td style="text-align:left" id="stat_last_update"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search with keywords (algolia)">
            <div id="searchprocessbar">
                <div id="spb-out" class="spb-outter-animate"></div>
                <div id="spb-in" class="spb-inner-animate"></div>
            </div>
            <div class="input-group-append">
                <button id="cleanbut" class="btn btn-light" type="button" title="clear search">cls</button>
                <button id="categories" class="btn btn-light" type="button">cates</button>
                <button id="tags" class="btn btn-light" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn btn-light" type="button" title="search">sch</button>
            </div>
        </div>
        <div id="searchrscount" class="unselectable"></div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        <p>本篇主要是再来聊聊MySQL中InnoDB的索引的细节，主要聊到引擎是如何利用B+树去检索数据的</p>
<p>以及整理一些关于索引的问题与回答，所以本篇的形式还是以问题点为驱动，回答一个个的问题</p>
<p>在开始之前，再强调一些B+树的细节：</p>
<ul>
<li><strong>“高扇出性”</strong>，为了减少IO次数，而尽可能一次IO读取更多的数据；</li>
<li><strong>“范围查找”</strong>，由于索引存储的特点，相比于<strong><em>哈希索引的等值查找</em></strong>，它还能胜任范围查找；</li>
<li><strong>“顺序排序”</strong>，因为索引是顺序存储，所以查询结果天然排序；</li>
<li><strong>“索引即数据，数据即索引”</strong>，聚集索引的存储值就是数据本身；</li>
</ul>

          <h3 id="b798ff2b">使用B+树的索引过程</h3><p>
        <div class="_showpic_7dd11eb8 showpicbtn">Loading images >></div>
        <img href=http://47.103.216.138/wp-content/uploads/2019/11/15727784554518.jpg class="_pic_7dd11eb8 hidepic" picId="7dd11eb8"></img>
        <script>
            {
                let imgself7dd11eb8s = document.getElementsByClassName('_pic_7dd11eb8')
                let showpicbtn7dd11eb8s = document.getElementsByClassName('_showpic_7dd11eb8')
                let isInViewPortOfTwo7dd11eb8 = function () {
                    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
                    const top = imgself7dd11eb8s[0].getBoundingClientRect() && imgself7dd11eb8s[0].getBoundingClientRect().top
                    if (top  <= viewPortHeight + 300) {
                        for (el of imgself7dd11eb8s) {
                            el.src = el.getAttribute('href')
                            el.classList.add('showpic')
                            window.removeEventListener('scroll', isInViewPortOfTwo7dd11eb8)
                            isInViewPortOfTwo7dd11eb8 = null
                        }
                        for (el of showpicbtn7dd11eb8s) {
                            el.style.display = 'none'
                        }
                    }
                }
                window.addEventListener('scroll', isInViewPortOfTwo7dd11eb8)
            }
        </script>
    </p>
<p>现在假设我们要查找<code>id&gt;=18</code>并且<code>id&lt;40</code>的用户数据</p>
<p>对应的sql语句如下，其中id为主键：</p>
<pre><code class="language-sql">select * from user where id&gt;=18 and id &lt;40</code></pre>
<p>具体的查找过程如下：</p>
<ol>
<li><p>一般根节点都是常驻内存的，也就是说<code>页1</code>已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。从内存中读取到<code>页1</code>，要查找这个<code>id&gt;=18 and id &lt;40</code>或者范围值，我们首先需要找到<code>id=18</code>的键值。从<code>页1</code>中我们可以找到键值<code>18</code>，此时我们需要根据指针<code>p2</code>，定位到<code>页3</code>。 </p>
</li>
<li><p>要从<code>页3</code>中查找数据，我们就需要拿着<code>p2</code>指针去磁盘中进行读取<code>页3</code>。从磁盘中读取<code>页3</code>放入内存中，然后进行查找，我们可以找到键值<code>18</code>，然后再拿到<code>页3</code>中的指针<code>p1</code>，定位到<code>页8</code>。 </p>
</li>
<li><p>同样的<code>页8</code>不在内存中，我们需要再去磁盘中将<code>页8</code>读取到内存中。将<code>页8</code>读取到内存中后，因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值<code>18</code>。</p>
<p><strong>此时因为已经到数据页了</strong>，此时我们已经找到一条满足条件的数据了，就是键值<code>18</code>对应的数据。因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页8中的键值依次进行遍历查找并匹配满足条件的数据。我们可以一直找到键值为<code>22</code>的数据，然后<code>页8</code>中就没有数据了，此时我们需要拿着<code>页8</code>中的<code>p指针</code>去读取<code>页9</code>中的数据。 </p>
</li>
<li><p>因为<code>页9</code>不在内存中，就又会加载<code>页9</code>到内存中，并通过和<code>页8</code>中一样的方式进行数据的查找，直到将<code>页12</code>加载到内存中，发现<code>41</code>大于<code>40</code>，此时不满足条件。</p>
<p><strong>那么查找到此终止</strong>。</p>
</li>
</ol>
<p>最终我们找到满足条件的所有数据为：<code>(18,kl),(19,kl),(22,hj),(24,io),(25,vg),(29,jk),(31,jk),(33,rt),(34,ty),(35,yu),(37,rt),(39,rt)</code>，总共12条记录。</p>
<p>具体流程如：</p>
<p>
        <div class="_showpic_9f702110 showpicbtn">Loading images >></div>
        <img href=http://47.103.216.138/wp-content/uploads/2019/11/15727785424308.jpg class="_pic_9f702110 hidepic" picId="9f702110"></img>
        <script>
            {
                let imgself9f702110s = document.getElementsByClassName('_pic_9f702110')
                let showpicbtn9f702110s = document.getElementsByClassName('_showpic_9f702110')
                let isInViewPortOfTwo9f702110 = function () {
                    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
                    const top = imgself9f702110s[0].getBoundingClientRect() && imgself9f702110s[0].getBoundingClientRect().top
                    if (top  <= viewPortHeight + 300) {
                        for (el of imgself9f702110s) {
                            el.src = el.getAttribute('href')
                            el.classList.add('showpic')
                            window.removeEventListener('scroll', isInViewPortOfTwo9f702110)
                            isInViewPortOfTwo9f702110 = null
                        }
                        for (el of showpicbtn9f702110s) {
                            el.style.display = 'none'
                        }
                    }
                }
                window.addEventListener('scroll', isInViewPortOfTwo9f702110)
            }
        </script>
    </p>
<p>而非聚集索引的查找流程也一样，只不过它最终返回的是记录的主键，然后再通过主键去聚集索引中查找数据，我们称这个行为叫做<strong>“回表”</strong></p>

          <h3 id="b00be92a">索引匹配过程</h3>
          <h4 id="956aeab4">Explain命令</h4><p>在了解索引匹配之前，我们先了解了解MySQL中一个对SQL执行过程进行解释的命令<code>explain</code>，</p>
<p>我们需要了解各列的含义，接下来的内容转载整理自：<a href="https://www.cnblogs.com/mzhaox/p/11203042.html">https://www.cnblogs.com/mzhaox/p/11203042.html</a></p>

          <h5 id="ef65433d">id</h5><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。MySQL将 select 查询分为简单查询和复杂查询。复杂查询分为三类：<strong>简单子查询、派生表（from语句中的子查询）、union 查询</strong>。</p>
<ol>
<li><p>简单子查询</p>
<pre><code class="language-sql">mysql&gt; explain select (select 1 from actor limit 1) from film;
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
|  1 | PRIMARY     | film  | index | NULL          | idx_name | 32      | NULL |    1 | Using index |
|  2 | SUBQUERY    | actor | index | NULL          | PRIMARY  | 4       | NULL |    2 | Using index |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</code></pre>
</li>
<li><p>from子句中的子查询</p>
<pre><code class="language-sql">mysql&gt; explain select id from (select id from film) as der;
+----+-------------+------------+-------+---------------+----------+---------+------+------+-------------+
| id | select_type | table      | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
+----+-------------+------------+-------+---------------+----------+---------+------+------+-------------+
|  1 | PRIMARY     | &lt;derived2&gt; | ALL   | NULL          | NULL     | NULL    | NULL |    2 | NULL        |
|  2 | DERIVED     | film       | index | NULL          | idx_name | 32      | NULL |    1 | Using index |
+----+-------------+------------+-------+---------------+----------+---------+------+------+-------------+</code></pre>
<p>这个查询执行时有个临时表别名为der，外部 select 查询引用了这个临时表</p>
</li>
<li><p>union查询</p>
<pre><code class="language-sql">mysql&gt; explain select 1 union all select 1;
+----+--------------+------------+------+---------------+------+---------+------+------+-----------------+
| id | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra           |
+----+--------------+------------+------+---------------+------+---------+------+------+-----------------+
|  1 | PRIMARY      | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used  |
|  2 | UNION        | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used  |
| NULL | UNION RESULT | &lt;union1,2&gt; | ALL  | NULL          | NULL | NULL    | NULL | NULL | Using temporary |
+----+--------------+------------+------+---------------+------+---------+------+------+-----------------+</code></pre>
<p>union结果总是放在一个匿名临时表中，临时表不在SQL总出现，因此它的id是NULL。</p>
</li>
</ol>

          <h5 id="6f9bfcce">select_type</h5><p>select_type 表示对应行是是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。</p>
<ol>
<li><p><strong>simple</strong>：简单查询。查询不包含子查询和union；</p>
</li>
<li><p><strong>primary</strong>：复杂查询中最外层的 select；</p>
</li>
<li><p><strong>subquery</strong>：包含在 select 中的子查询（不在 from 子句中）；</p>
</li>
<li><p><strong>derived</strong>：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表；</p>
<pre><code class="language-sql">mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;
+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+
| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows | Extra       |
+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+
|  1 | PRIMARY     | &lt;derived3&gt; | system | NULL          | NULL    | NULL    | NULL  |    1 | NULL        |
|  3 | DERIVED     | film       | const  | PRIMARY       | PRIMARY | 4       | const |    1 | NULL        |
|  2 | SUBQUERY    | actor      | const  | PRIMARY       | PRIMARY | 4       | const |    1 | Using index |
+----+-------------+------------+--------+---------------+---------+---------+-------+------+-------------+</code></pre>
</li>
<li><p><strong>union</strong>：在 union 中的第二个和随后的 select；</p>
</li>
<li><p><strong>union result</strong>：从 union 临时表检索结果的 select；</p>
<pre><code class="language-sql">mysql&gt; explain select 1 union all select 1;
+----+--------------+------------+------+---------------+------+---------+------+------+-----------------+
| id | select_type  | table      | type | possible_keys | key  | key_len | ref  | rows | Extra           |
+----+--------------+------------+------+---------------+------+---------+------+------+-----------------+
|  1 | PRIMARY      | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used  |
|  2 | UNION        | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL | No tables used  |
| NULL | UNION RESULT | &lt;union1,2&gt; | ALL  | NULL          | NULL | NULL    | NULL | NULL | Using temporary |
+----+--------------+------------+------+---------------+------+---------+------+------+-----------------+</code></pre>
</li>
</ol>

          <h5 id="1bf8e684">table</h5><p>这一列表示 explain 的一行正在访问哪个表。</p>
<p>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。</p>
<p>当有 union 时，UNION RESULT 的 table 列的值为 &lt;union1,2&gt;，1和2表示参与 union 的 select 行id。</p>

          <h5 id="90bc59cf">type（重点）</h5><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行。</p>
<p>依次从最优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong></p>
<ul>
<li><p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。</p>
<p>例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表</p>
<pre><code class="language-sql">mysql&gt; explain select min(id) from film;
+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra                        |
+----+-------------+-------+------+---------------+------+---------+------+------+------------------------------+
|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | Select tables optimized away |
+----+-------------+-------+------+---------------+------+---------+------+------+------</code></pre>
</li>
<li><p><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p>
<pre><code class="language-sql">mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;
+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+
| id | select_type | table      | type   | possible_keys | key               | key_len | ref                     | rows | Extra       |
+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+
|  1 | SIMPLE      | film_actor | index  | NULL          | idx_film_actor_id | 8       | NULL                    |    3 | Using index |
|  1 | SIMPLE      | film       | eq_ref | PRIMARY       | PRIMARY           | 4       | test.film_actor.film_id |    1 | NULL        |
+----+-------------+------------+--------+---------------+-------------------+---------+-------------------------+------+-------------+</code></pre>
</li>
<li><p><strong>ref</strong>：相比 <code>eq_ref</code>，不使用唯一索引，而是使用普通索引或者唯一性索引的<strong>部分前缀</strong>，索引要和某个值相比较，可能会找到多个符合条件的行。</p>
<pre><code class="language-sql">1. 简单 select 查询，name是普通索引（非唯一索引）
mysql&gt; explain select * from film where name = &quot;film1&quot;;
+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+
| id | select_type | table | type | possible_keys | key      | key_len | ref   | rows | Extra                    |
+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+
|  1 | SIMPLE      | film  | ref  | idx_name      | idx_name | 33      | const |    1 | Using where; Using index |
+----+-------------+-------+------+---------------+----------+---------+-------+------+--------------------------+

2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。
mysql&gt; explain select * from film left join film_actor on film.id = film_actor.film_id;
+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+
| id | select_type | table      | type  | possible_keys     | key               | key_len | ref          | rows | Extra       |
+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+-------------+
|  1 | SIMPLE      | film       | index | NULL              | idx_name          | 33      | NULL         |    3 | Using index |
|  1 | SIMPLE      | film_actor | ref   | idx_film_actor_id | idx_film_actor_id | 4       | test.film.id |    1 | Using index |
+----+-------------+------------+-------+-------------------+-------------------+---------+--------------+--</code></pre>
</li>
<li><p><strong>ref_or_null</strong>：类似<code>ref</code>，但是可以搜索值为NULL的行。</p>
<pre><code class="language-sql">mysql&gt; explain select * from film where name = &quot;film1&quot; or name is null;
+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+
| id | select_type | table | type        | possible_keys | key      | key_len | ref   | rows | Extra                    |
+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+
|  1 | SIMPLE      | film  | ref_or_null | idx_name      | idx_name | 33      | const |    2 | Using where; Using index |
+----+-------------+-------+-------------+---------------+----------+---------+-------+------+--------------------------+</code></pre>
</li>
<li><p><strong>index_merge</strong>：表示使用了索引合并的优化方法。</p>
<p>例如下表：id是主键，tenant_id是普通索引。or 的时候没有用 primary key，而是使用了 primary key(id) 和 tenant_id 索引</p>
<pre><code class="language-sql">mysql&gt; explain select * from role where id = 11011 or tenant_id = 8888;
+----+-------------+-------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+
| id | select_type | table | type        | possible_keys         | key                   | key_len | ref  | rows | Extra                                           |
+----+-------------+-------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+
|  1 | SIMPLE      | role  | index_merge | PRIMARY,idx_tenant_id | PRIMARY,idx_tenant_id | 4,4     | NULL |  134 | Using union(PRIMARY,idx_tenant_id); Using where |
+----+-------------+-------+-------------+-----------------------+-----------------------+---------+------+------+-------------------------------------------------+</code></pre>
</li>
<li><p><strong>range</strong>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p>
<pre><code class="language-sql">mysql&gt; explain select * from actor where id &gt; 1;
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | actor | range | PRIMARY       | PRIMARY | 4       | NULL |    2 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</code></pre>
</li>
<li><p><strong>index</strong>：和ALL一样，不同就是mysql只需扫描索引树，这通常比ALL快一些。</p>
<pre><code class="language-sql">mysql&gt; explain select count(*) from film;
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
|  1 | SIMPLE      | film  | index | NULL          | idx_name | 33      | NULL |    3 | Using index |
+----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</code></pre>
</li>
<li><p><strong>ALL</strong>：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了</p>
<pre><code class="language-sql">mysql&gt; explain select * from actor;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+</code></pre>
</li>
</ul>

          <h5 id="31adb4b7">possible_keys</h5><p>这一列显示查询可能使用哪些索引来查找。</p>
<p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。</p>
<p>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>

          <h5 id="2b31a049">key</h5><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。<br>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>

          <h5 id="3562c7af">key_len</h5><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</p>

          <h5 id="cb7ab6c2">ref</h5><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名（例：film.id）</p>

          <h5 id="256a3324">rows</h5><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>

          <h5 id="53abcd37">filtered</h5><p>某个表经过搜索条件过滤后剩余记录条数的百分比</p>

          <h5 id="b9248174">extra</h5><p>这一列展示的是额外信息。常见的重要值如下：</p>
<ul>
<li><p><strong>distinct</strong>: 一旦mysql找到了与行相联合匹配的行，就不再搜索了</p>
<pre><code class="language-sql">  mysql&gt; explain select distinct name from film left join film_actor on film.id = film_actor.film_id;
  +----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+------------------------------+
  | id | select_type | table      | type  | possible_keys     | key               | key_len | ref          | rows | Extra                        |
  +----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+------------------------------+
  |  1 | SIMPLE      | film       | index | idx_name          | idx_name          | 33      | NULL         |    3 | Using index; Using temporary |
  |  1 | SIMPLE      | film_actor | ref   | idx_film_actor_id | idx_film_actor_id | 4       | test.film.id |    1 | Using index; Distinct        |
  +----+-------------+------------+-------+-------------------+-------------------+---------+--------------+------+------------------------------+</code></pre>
</li>
<li><p><strong>Using index</strong>：这发生在对表的请求列都是同一索引的部分的时候，返回的列数据只使用了索引中的信息，而没有再去访问表中的行记录。是性能高的表现。</p>
<pre><code class="language-sql">  mysql&gt; explain select id from film order by id;
  +----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
  | id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
  +----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
  |  1 | SIMPLE      | film  | index | NULL          | PRIMARY | 4       | NULL |    3 | Using index |
  +----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</code></pre>
</li>
<li><p><strong>Using where</strong>：mysql服务器将在存储引擎检索行后再进行过滤。就是先读取整行数据，再按 where 条件进行检查，符合就留下，不符合就丢弃。</p>
<pre><code class="language-sql">  mysql&gt; explain select * from film where id &gt; 1;
  +----+-------------+-------+-------+---------------+----------+---------+------+------+--------------------------+
  | id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra                    |
  +----+-------------+-------+-------+---------------+----------+---------+------+------+--------------------------+
  |  1 | SIMPLE      | film  | index | PRIMARY       | idx_name | 33      | NULL |    3 | Using where; Using index |
  +----+-------------+-------+-------+---------------+----------+---------+------+------+--------------------------+</code></pre>
</li>
<li><p><strong>Using temporary</strong>：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>
<pre><code class="language-sql">  1. actor.name没有索引，此时创建了张临时表来distinct
  mysql&gt; explain select distinct name from actor;
  +----+-------------+-------+------+---------------+------+---------+------+------+-----------------+
  | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra           |
  +----+-------------+-------+------+---------------+------+---------+------+------+-----------------+
  |  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using temporary |
  +----+-------------+-------+------+---------------+------+---------+------+------+-----------------+

  2. film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表
  mysql&gt; explain select distinct name from film;
  +----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
  | id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
  +----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
  |  1 | SIMPLE      | film  | index | idx_name      | idx_name | 33      | NULL |    3 | Using index |
  +----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</code></pre>
</li>
<li><p><strong>Using filesort</strong>：mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。这种情况下一般也是要考虑使用索引来优化的。</p>
<pre><code class="language-sql">  1. actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录
  mysql&gt; explain select * from actor order by name;
  +----+-------------+-------+------+---------------+------+---------+------+------+----------------+
  | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra          |
  +----+-------------+-------+------+---------------+------+---------+------+------+----------------+
  |  1 | SIMPLE      | actor | ALL  | NULL          | NULL | NULL    | NULL |    2 | Using filesort |
  +----+-------------+-------+------+---------------+------+---------+------+------+----------------+

  2. film.name建立了idx_name索引,此时查询时extra是using index
  mysql&gt; explain select * from film order by name;
  +----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
  | id | select_type | table | type  | possible_keys | key      | key_len | ref  | rows | Extra       |
  +----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+
  |  1 | SIMPLE      | film  | index | NULL          | idx_name | 33      | NULL |    3 | Using index |
  +----+-------------+-------+-------+---------------+----------+---------+------+------+-------------+</code></pre>
</li>
</ul>

          <h4 id="6fd77e31">匹配过程</h4><p>假如我们有表：</p>
<pre><code class="language-sql">mysql root@youyinnn.top:test&gt; show create table mytable3\G
***************************[ 1. row ]***************************
Table        | mytable3
Create Table | CREATE TABLE `mytable3` (
  `a` int(11) NOT NULL AUTO_INCREMENT,
  `b` varchar(30) NOT NULL,
  `c` varchar(20) NOT NULL,
  `d` int(11) DEFAULT NULL,
  `e` int(11) DEFAULT NULL,
  PRIMARY KEY (`a`,`b`,`c`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8</code></pre>
<p>并且有3个列组成的聚集索引：</p>
<pre><code class="language-sql">mysql root@youyinnn.top:test&gt; show index from mytable3;
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| mytable3 | 0          | PRIMARY  | 1            | a           | A         | 6           | &lt;null&gt;   | &lt;null&gt; |      | BTREE      |         |               |
| mytable3 | 0          | PRIMARY  | 2            | b           | A         | 6           | &lt;null&gt;   | &lt;null&gt; |      | BTREE      |         |               |
| mytable3 | 0          | PRIMARY  | 3            | c           | A         | 6           | &lt;null&gt;   | &lt;null&gt; |      | BTREE      |         |               |
+----------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</code></pre>

          <h5 id="19f1de30">全列查询</h5><p>如果我们提供了所有主键的等值条件，那么就会使用const类型的查询</p>
<pre><code class="language-sql">mysql root@youyinnn.top:test&gt; explain select * from mytable3 where a = &#39;1&#39; and b = &#39;name&#39; and c = &#39;age&#39;;
+----+-------------+----------+------------+-------+---------------+---------+---------+-------------------+------+----------+--------+
| id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref               | rows | filtered | Extra  |
+----+-------------+----------+------------+-------+---------------+---------+---------+-------------------+------+----------+--------+
| 1  | SIMPLE      | mytable3 | &lt;null&gt;     | const | PRIMARY       | PRIMARY | 158     | const,const,const | 1    | 100.0    | &lt;null&gt; |
+----+-------------+----------+------------+-------+---------------+---------+---------+-------------------+------+----------+--------+</code></pre>

          <h5 id="c5f73885">最左前缀查询</h5><pre><code class="language-sql">mysql root@youyinnn.top:test&gt; explain select * from mytable3 where a = &#39;1&#39;;
+----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+--------+
| id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra  |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+--------+
| 1  | SIMPLE      | mytable3 | &lt;null&gt;     | ref  | PRIMARY       | PRIMARY | 4       | const | 1    | 100.0    | &lt;null&gt; |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+------+----------+--------+</code></pre>
<p>我们的索引有3列，但我们只用到了最左边的一列，所以type为ref</p>

          <h5 id="57c85373">非最左前缀查询</h5><p>但是当我们不从索引列的最左边开始提供条件的时候：</p>
<pre><code class="language-sql">mysql root@youyinnn.top:test&gt; explain select * from mytable3 where b = &#39;name&#39; and c = &#39;1&#39;;
+----+-------------+----------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys | key    | key_len | ref    | rows | filtered | Extra       |
+----+-------------+----------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| 1  | SIMPLE      | mytable3 | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 6    | 16.67    | Using where |
+----+-------------+----------+------------+------+---------------+--------+---------+--------+------+----------+-------------+</code></pre>
<p>可以看到，这里直接使用了全表扫描，是效率最低的一种查询方式；为了优化，我们可以填上最左缺省的前缀主键，为了不破坏准确性，我们可以将全表扫描提升为<strong>范围扫描（range）</strong>类型的查询：</p>
<pre><code class="language-sql">mysql root@youyinnn.top:test&gt; explain select * from mytable3 where b = &#39;name&#39; and c = &#39;1&#39; and a in(1, 1000000);
+----+-------------+----------+------------+-------+---------------+---------+---------+--------+------+----------+-------------+
| id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref    | rows | filtered | Extra       |
+----+-------------+----------+------------+-------+---------------+---------+---------+--------+------+----------+-------------+
| 1  | SIMPLE      | mytable3 | &lt;null&gt;     | range | PRIMARY       | PRIMARY | 158     | &lt;null&gt; | 2    | 100.0    | Using where |
+----+-------------+----------+------------+-------+---------------+---------+---------+--------+------+----------+-------------+</code></pre>

          <h5 id="5631f7a6">表达式查询</h5><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）：</p>
<pre><code class="language-sql">mysql root@youyinnn.top:test&gt; explain select * from mytable3 where a - 1 = 1;
+----+-------------+----------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys | key    | key_len | ref    | rows | filtered | Extra       |
+----+-------------+----------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| 1  | SIMPLE      | mytable3 | &lt;null&gt;     | ALL  | &lt;null&gt;        | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 6    | 100.0    | Using where |
+----+-------------+----------+------------+------+---------------+--------+---------+--------+------+----------+-------------+</code></pre>

          <h5 id="b44c82a9">or查询</h5><p>对于<strong>同列</strong>的or查询，它实际上就转成一个针对该列的范围查询（如果是最左的话）；</p>
<p>对于<strong>不同列</strong>的or查询，我们就把or的子条件当成一个独立的子句，如果子句不符合最左前缀，那子句查询还是会走全表扫描：</p>
<pre><code class="language-sql">mysql root@youyinnn.top:test&gt; explain select * from mytable3 where a = &#39;1&#39; or b = &#39;name&#39;;
+----+-------------+----------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys | key    | key_len | ref    | rows | filtered | Extra       |
+----+-------------+----------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| 1  | SIMPLE      | mytable3 | &lt;null&gt;     | ALL  | PRIMARY       | &lt;null&gt; | &lt;null&gt;  | &lt;null&gt; | 6    | 30.56    | Using where |
+----+-------------+----------+------------+------+---------------+--------+---------+--------+------+----------+-------------+</code></pre>
<p>就算把它们拆成union也是一样的</p>

          <h3 id="e224da0">索引的选择</h3>
          <h4 id="f899e0ea">索引的建立</h4><p>并不是所有的查询我们都需要为其建立索引，索引虽然加快了查询速度，但索引也是有代价的：</p>
<ul>
<li>索引文件本身要消耗存储空间；</li>
<li>同时索引会加重插入、删除和修改记录时的负担；</li>
<li>MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引；</li>
</ul>
<p><strong>以下两种情况可以不建立索引：</strong></p>
<ol>
<li><p>表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了；</p>
</li>
<li><p>索引的选择性较低；</p>
<blockquote>
<p><strong>“选择性”</strong>这个概念我们在索引概述的时候讲过，通俗的说就是像性别这种列，就算用定值去选都能选半张表的列就是<strong>选择性低</strong>的列；</p>
<p>而对于选择性低的列，如果<strong>已经成为索引</strong>了，而且会在一定程度上影响最左前缀匹配，可以使用填坑的方式去满足最左前缀，而触发索引；</p>
</blockquote>
</li>
</ol>

          <h4 id="f82ef9d8">主键选择</h4><p><strong>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</strong></p>
<p>我们从B+树索引的特性中可以明白，索引本质上还是依赖主键的值去排序、排列、分页的，如果选用非自增的值作为主键，可能会导致索引树频繁进行移动、分页而产生大量的碎片，这样索引的性能会很低</p>

          <h3 id="c044e099">优化器行为</h3>
          <h4 id="cabcca87">覆盖索引</h4><p>这个在上节中说过，这回来explain一下：</p>
<pre><code class="language-sql">mysql root@youyinnn.top:test&gt; explain select a from mytable3 where e &gt;= 0 and e &lt;= 3000;
+----+-------------+----------+------------+-------+---------------+-------+---------+--------+------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys | key   | key_len | ref    | rows | filtered | Extra                    |
+----+-------------+----------+------------+-------+---------------+-------+---------+--------+------+----------+--------------------------+
| 1  | SIMPLE      | mytable3 | &lt;null&gt;     | range | idx_e         | idx_e | 5       | &lt;null&gt; | 4    | 100.0    | Using where; Using index |
+----+-------------+----------+------------+-------+---------------+-------+---------+--------+------+----------+--------------------------+</code></pre>
<p>假如有e的辅助索引，在查询a值的时候，直接返回结果，不回表全表扫</p>

          <h4 id="1a37e2fe">不使用索引</h4><p>有的时候我们有<strong>某非主键字段进行范围查找整行数据（select *）</strong>的情况，对某个非主键字段进行范围查找，这时候虽然该字段可能有辅助索引，但是辅助索引并不能包含整行信息，于是查到辅助索引还要再查一次聚集索引，因为是书签，所以在磁盘上进行的是离散的而不是顺序的读操作，这时候优化器会选择直接利用聚集索引来依次查找</p>

          <h3 id="a40c7374">索引相关面试题</h3><ol>
<li><p>为什么采用B+树而不采用哈希索引？</p>
<blockquote>
<ul>
<li>高扇出，减少IO</li>
<li>适合范围查找</li>
<li>天然排序</li>
</ul>
</blockquote>
</li>
<li><p>B+树叶子节点里都存什么？</p>
<blockquote>
<p>聚集索引存整行数据，非聚集索引存主键</p>
</blockquote>
</li>
<li><p>什么情况下非聚集索引不需要回表？</p>
<blockquote>
<p>在<strong>覆盖索引</strong>发生的情况下，可以不用回表</p>
</blockquote>
</li>
<li><p>覆盖索引什么时候回发生？</p>
<blockquote>
<p>在辅助索引完全能够返回查询结果的情况下，不需要回表，比如直接查询主键的值、一些统计语句</p>
</blockquote>
</li>
<li><p>什么时候优化器不会使用索引？</p>
<blockquote>
<p>有时候使用一些没有索引或者辅助索引覆盖不了全部表的时候，优化器会直接进行全表扫</p>
</blockquote>
</li>
<li><p>创建索引要考虑哪些因素？</p>
<blockquote>
<ul>
<li>根据业务查询比重建立索引；</li>
<li>满足查询的最左前缀；</li>
</ul>
</blockquote>
</li>
<li><p>什么时候要使用联合索引？</p>
<blockquote>
<p>可以通过联合索引来做天然排序而不用调用<code>filesort</code>；</p>
</blockquote>
</li>
<li><p>怎么看索引的选择情况？</p>
<blockquote>
<p>使用explain；</p>
</blockquote>
</li>
</ol>

          <h3 id="b5b4cbf8">参考</h3><ul>
<li><p><a href="https://www.hollischuang.com/archives/4110">Hollis</a>；</p>
</li>
<li><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">张洋</a>；</p>
</li>
<li><p><a href="https://www.cnblogs.com/mzhaox/p/11203042.html%EF%BC%9B">https://www.cnblogs.com/mzhaox/p/11203042.html；</a></p>
</li>
</ul>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

</body>

</html>