<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script src="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@latest/myjs/loadscripts.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@latest/myjs/jump-1.4.js"></script>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@latest/img/favicon.ico" />
    <link rel="icon" href="/img/favicon.ico" type="image/ico"/>
    <link rel="stylesheet" href="/mycss/style.css">

    <script src="/resources/resources.js"></script>
    <script src="/myjs/scriptlist.js"></script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg">🚀</button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <div id="homepage-center">
            <div id="slogan">
                <i id="wolf-logo" style="font-style: normal;" class="mr-4">🌑</i><span id="slogan-text"></span>
            </div>
            <div id="homepage-btn">
                <div id="showmore"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; About Me & This Blog</div>
                <div id="showhacknical"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; My Github Analysis</div>
                <div id="toarticles"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; My Tech Articles</div>
            </div>
        </div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistics</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Online:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Chars:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Categories:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tags:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Last update:</td>
                    <td style="text-align:left" id="stat_last_update"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search with keywords (algolia)">
            <div id="searchprocessbar">
                <div id="spb-out" class="spb-outter-animate"></div>
                <div id="spb-in" class="spb-inner-animate"></div>
            </div>
            <div class="input-group-append">
                <button id="cleanbut" class="btn btn-light" type="button" title="clear search">cls</button>
                <button id="categories" class="btn btn-light" type="button">cates</button>
                <button id="tags" class="btn btn-light" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn btn-light" type="button" title="search">sch</button>
            </div>
        </div>
        <div id="searchrscount" class="unselectable"></div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3 id="6fe6d02f">介绍</h3><p>本篇主要介绍了MySQL系统的核心引擎之一：<strong><em>InnoDB</em></strong>，本系列所有的内容是基于姜承尧老师所著<em>《MySQL技术内幕：InnoDB存储引擎》</em>再加上整理的网络笔记、MySQL5.7的<a href="https://dev.mysql.com/doc/refman/5.7/en/">官方文档</a>和自己的一些理解</p>

          <h3 id="d6029cf">InnoDB引擎</h3><p>MySQL5.5.8以后的默认引擎，支持事物、行锁设计、外键、全文索引、非锁定读（默认读操作不会产生锁）；</p>
<p>使用多版本并发控制（MVCC）来支持高并发性，并实现了4中标准的隔离级别，能避免幻读；还提供了许多其他的特性来支持高性能高并发；</p>

          <h3 id="d896924e">体系架构</h3><p>
        <div class="_showpic_f596600e showpicbtn">Loading images >></div>
        <img href=https://image.youyinnn.top/20200611211157.png class="_pic_f596600e hidepic" picId="f596600e"></img>
        <script>
            {
                let imgselff596600es = document.getElementsByClassName('_pic_f596600e')
                let showpicbtnf596600es = document.getElementsByClassName('_showpic_f596600e')
                let isInViewPortOfTwof596600e = function () {
                    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
                    const top = imgselff596600es[0].getBoundingClientRect() && imgselff596600es[0].getBoundingClientRect().top
                    if (top  <= viewPortHeight + 300) {
                        for (el of imgselff596600es) {
                            el.src = el.getAttribute('href')
                            el.classList.add('showpic')
                            window.removeEventListener('scroll', isInViewPortOfTwof596600e)
                            isInViewPortOfTwof596600e = null
                        }
                        for (el of showpicbtnf596600es) {
                            el.style.display = 'none'
                        }
                    }
                }
                window.addEventListener('scroll', isInViewPortOfTwof596600e)
            }
        </script>
    </p>
<p>引擎的内存中主要包含以下工作区域：</p>
<ol>
<li>线程维护区域/线程所需内部数据结构区域</li>
<li>数据缓存，数据修改之后并不是马上进入磁盘文件，而是先缓存在这里；</li>
<li>重做日志缓冲；</li>
</ol>

          <h3 id="fcc80935">后台线程的分类</h3><ol>
<li><strong>Master Thread</strong>：核心线程，主要负责将缓冲池中的数据异步地刷新到磁盘，保证数据一致性，具体表现为：<strong>刷脏页（InnoDB 1.2.x之后被独立为Page Cleaner Thread）、合并插入缓冲、回收Undo页（InnoDB 1.1之后被独立为Purge Thread）</strong>；</li>
<li><strong>IO Thread</strong>：引擎使用了大量的AIO技术来处理写IO请求，以提高数据库的性能，该线程的工作是<strong>处理这些IO的回调</strong>；而在Windows系统中，IO线程的数量可以调整；</li>
<li><strong>Purge Thread</strong>：（InnoDB 1.1引入）事务被提交后，其所使用的undolog可能不再被需要，该线程是负责<strong>回收</strong>这些被分配的undo页；该线程的线程数也支持配置；减轻Master Thread的负担，提高性能；</li>
<li><strong>Page Cleaner Thread</strong>：（InnoDB 1.2.x引入），主要完成<strong>脏页的刷新</strong>操作，减轻Master Thread的负担，提高性能；</li>
</ol>

          <h3 id="7504268c">内存/内存对象</h3>
          <h3 id="ecc28cd8">缓冲池</h3><p>InnoDB是基于磁盘文件存储的引擎，并将数据按页分配和管理。而由于CPU和磁盘的IO差距，想要提高性能，肯定是要利用系统内存区弥补IO差距的，所以我们可以简单地将缓冲池理解为磁盘数据文件的内存映射</p>

          <h4 id="fbf96d55">基本逻辑和内容</h4><p><strong>读操作</strong>：系统启动的时候，会缓存（FIX）部分页到缓冲池里，在读页的时候，首先去缓冲池里找，如果找到了就直接读取，否则就从磁盘上读</p>
<p><strong>写操作</strong>：首先修改缓冲池中的页，然后再以一定频率刷新到次磁盘上，而且不是一有页更新就刷，而是根据一种叫<strong>Checkpoint</strong>的机制来刷</p>
<p>缓冲池的内存大小也直接影响了数据库的性能，我们也可以再配置中调节它的大小，也能够调节缓冲池的实例个数，多缓冲池实例的好处是每个页会更散列地分配到不同实例当中，好处是减少内部资源竞争</p>
<p>缓冲池的内存数据对象如下：</p>
<p>
        <div class="_showpic_5c8a4cfe showpicbtn">Loading images >></div>
        <img href=https://image.youyinnn.top/20200611215932.png class="_pic_5c8a4cfe hidepic" picId="5c8a4cfe"></img>
        <script>
            {
                let imgself5c8a4cfes = document.getElementsByClassName('_pic_5c8a4cfe')
                let showpicbtn5c8a4cfes = document.getElementsByClassName('_showpic_5c8a4cfe')
                let isInViewPortOfTwo5c8a4cfe = function () {
                    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
                    const top = imgself5c8a4cfes[0].getBoundingClientRect() && imgself5c8a4cfes[0].getBoundingClientRect().top
                    if (top  <= viewPortHeight + 300) {
                        for (el of imgself5c8a4cfes) {
                            el.src = el.getAttribute('href')
                            el.classList.add('showpic')
                            window.removeEventListener('scroll', isInViewPortOfTwo5c8a4cfe)
                            isInViewPortOfTwo5c8a4cfe = null
                        }
                        for (el of showpicbtn5c8a4cfes) {
                            el.style.display = 'none'
                        }
                    }
                }
                window.addEventListener('scroll', isInViewPortOfTwo5c8a4cfe)
            }
        </script>
    </p>

          <h4 id="226195c9">缓冲算法</h4><p>对于缓冲池的管理，引擎使用了基本的三种算法来完成：<strong>LRU List、Free List、Flush List</strong></p>
<p>假设我们知道基本的LRU缓存算法，但再InnoDB中的LRU算法又不太一样，它提供了一个<strong><em>midpoint</em></strong>来处理使用频率更新时，节点的放置策略：在新读取到页的时候，虽然是最新访问的，但是并不是放到队列的头部，而是放在大概中间的位置，默认是列表长度的5/8处，这个值也是可以进行配置的</p>
<p>而我们把这个点之前的页称为new列表，表示是使用频繁的热点数据，后面的称为old列表</p>
<p>InnoDB之所以对算法进行改进的原因是：某些SQL操作可以能会把相当一部分的页甚至是所有页都刷出去，如果热点数据放在头部，那么它有可能最早被刷出，而下一次需要的时候，又从磁盘读取，非常影响性能</p>
<p><strong>Free列表是干嘛的呢？</strong></p>
<p>在数据库刚启动的时候，LRU列表是空的，没有任何的页，因为这时候页都在Free列表中。当需要从缓冲池中分页的时候，首先从Free列表中查找是否有可用的空闲页，有就直接将该页从Free列表移动到LRU列表</p>
<p><strong>Flush列表和脏页</strong></p>
<p>在LRU列表中的页被修改之后，该页被称为脏页，这时候该页的数据和磁盘上对应的映射数据不一致，于是引擎通过Checkpoint机制将脏页刷回磁盘，我们把脏页都放在Flush列表中</p>
<p><em>注意：脏页即存在LRU列表中，页存在Flush列表中，两者逻辑上分工不同</em></p>

          <h4 id="f67bdc9e">重做日志缓冲</h4><p>在一个事物的过程中，引擎会先把重做日志放到缓冲区，然后再按照频率刷新到重做日志文件。在这样的场景下，重做日志缓存一般不会占用太多内存，保证每秒的事物量在这个范围内就好，默认的8M，也是能够配置的</p>
<blockquote>
<p>重做日志刷新的时机：</p>
<ol>
<li>Master Thread每一秒都刷一次；</li>
<li>每个事物提交的时候也会刷；</li>
<li>重做日志空间剩余空间小于1/2的时候，也会刷；</li>
</ol>
</blockquote>

          <h4 id="84c99e32">额外的内存</h4><p>剩下还有一些额外内存，用于分配数据库所需的对象、数据结构等，用于记录锁信息和LRU以及等待的信息</p>

          <h3 id="c01a2634">Checkpoint机制</h3><p> 当出现脏页的时候，需要把数据刷回磁盘，但不能每出现一次脏页就刷回，这样会增加IO的压力，从而性能会很差；同时，如果在刷页的时候系统挂了，那么数据就难以恢复；大部分数据库系统采用了Write Ahead Log的策略，即先写重做日志，再修改页，在出意外的时候，可用日志恢复；</p>
<p>而Checkpoint技术的出现主要是为了解决：</p>
<ol>
<li><p>缩短数据恢复的时间；</p>
<blockquote>
<p>当系统挂掉的时候，数据库不需要套重做所有的日志，checkpoint之前的页已经刷回磁盘；只需要恢复checkpoint后面的页就行；</p>
</blockquote>
</li>
<li><p>缓冲池不够用的时候，将脏页刷到磁盘；</p>
<blockquote>
<p>缓冲池不够用的时候，LRU算法会溢出最近少使用的页，如果这个页是脏页，那么需要强制执行checkpoint，将脏页刷回磁盘</p>
</blockquote>
</li>
<li><p>重做日志<strong>不可用</strong>的时候，刷新脏页；</p>
<blockquote>
<p>在重做日志不够用的时候，强制产生checkpoint，将缓冲池的页至少刷新到当前重做日志的位置；</p>
</blockquote>
</li>
</ol>
<p>Checkpont分为2种：</p>
<ol>
<li>Sharp Checkpoint：数据库即将关闭的时候将所有的脏页刷回磁盘；</li>
<li>Fuzzy Checkpoint：运行时的Checkpoint，每次只刷新部分脏页，保证数据库可用性；</li>
</ol>

          <h3 id="c021825a">Master Thread(before 1.1)</h3><p>Master Thread具有最高的线程优先级，其内部由多个循环组成：主循环（loop）、后台循环（backgroud loop）、暂停循环（suspend loop）。主线程会根据数据库的状态在不同下循环之间进行切换</p>
<p>而我们先分析InnoDB1.1之前，Master Thread的工作细节，再回头看，Master线程中的哪些工作被独立为线程</p>

          <h4 id="7564a45e">Loop</h4><p>主循环的工作有2部分：</p>
<ol>
<li>每秒一次：<ul>
<li>（总是）日志缓存刷到磁盘，即使事物还没提交；</li>
<li>（可能）合并插入缓冲，是否发生看IO的次数，次数小就可用执行合并；</li>
<li>（可能）最多刷100个脏页到磁盘，是否发生看脏页比例，超过某个阈值就刷；</li>
<li>（可能）如果当前用户没有活动，切换到后台循环；</li>
</ul>
</li>
<li>每10秒一次：<ul>
<li>（可能）刷100个脏页；</li>
<li>（总是）合并若干个插入缓冲；</li>
<li>（总是）刷日志到磁盘；</li>
<li>（总是）删除无用的Undo页；</li>
<li>（总是）刷100个脏页或者10个脏页到磁盘；</li>
</ul>
</li>
</ol>
<p>在InnoDB版本迭代之后，每秒次可以刷不只100页脏页，可以自己在配置中调节，其中阈值也能够进行调节</p>
<p>除此之外，我们把删除Undo页的操作称为<strong>“full purge”</strong>，在引擎版本升级的时候，删除多少页Undo页也能够配置</p>

          <h4 id="c908f210">Background Loop</h4><p>如果当前用户没有活动，或者数据库要关闭了，那么就会切换到这个循环，它的工作有：</p>
<ol>
<li>（总是）删除无用的Undo页；</li>
<li>（总是）合并20个插入缓冲；</li>
<li>（总是）跳回主循环；</li>
<li>（可能）刷100页直到符合条件（在flush loop还在主线程的版本的时候，这会跳转到flush loop）</li>
</ol>
<p>如果flush loop也没有什么可以做的了，主线程就会切换到suspend loop，将线程挂起，等待事件发生</p>

          <h4 id="812f6b7">Version</h4><ul>
<li>InnoDB 1.1开始，回收Undo页的工作独立为Purge Thread；</li>
<li>InnoDB 1.2开始，刷脏页的工作独立为Page Cleaner Thread;</li>
</ul>

          <h3 id="12b57f8b">InnoDB关键特性</h3>
          <h4 id="9e6df0eb">插入缓冲（Insert Buffer）</h4><p>听名字可能会让人以为它是缓冲池的一部分，但其实它和数据页一样，是物理页的一个组成部分，它的作用是为了提高插入操作的性能</p>
<p>了解插入缓冲之前，我们先来了解一下引擎是如何根据索引插入行记录的：</p>
<ul>
<li><strong>在一般情况下</strong>，主键是行的唯一标识符，所以插入顺序一般是按照主键递增的顺序执行，不需要磁盘随机读取，若主键支持自动增长，那么这类情况的插入效率非常快；对于这样的<strong>按照表的主键构造的索引</strong>，我们称为<strong>聚集索引</strong>；</li>
<li><strong>但是每张表中不一定只有聚集索引</strong>，可能还有多个<strong>非聚集的辅助索引</strong>，比如需要按照某个字段进行查找，而且某个字段不是唯一的，这样就会产生非聚集索引；而在插入的时候，数据页虽然还是按照主键顺序存放，但是非聚集索引的叶子节点就不是顺序的了，这时候就需要<strong>离散地</strong>访问非聚集索引页，导致插入性能会有所下降（<strong>由B+树的特性决定的非聚集索引插入的离散性</strong>）；</li>
<li><strong>某些情况下</strong>，非聚集索引也可能是顺序的或者说较为顺序，在插入索引值的时候手动保证绝对顺序（比如字段存的是绝对时间）；</li>
</ul>
<p>于是对于非聚集索引的插入或者更新操作，InnoDB设计的<strong>Insert Buffer</strong>就会起到作用：</p>
<ul>
<li>对于非聚集索引的插入或者更新，不是直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中：<ul>
<li>若在，则直接插入；</li>
<li>否则，先放到一个<strong>Insert Buffer</strong>对象中；</li>
</ul>
</li>
<li>然后再以一定频率和特定情况将<strong>Insert Buffer</strong>和辅助索引子节点进行<strong>merge</strong>操作；这时通常能够将多个插入操作合并到一个操作中（如果是针对同一张索引页的话），这就大大提高非聚集索引的插入性能；</li>
</ul>
<p>然而插入缓冲是需要条件的，只有符合以下条件的插入操作才能触发插入缓冲：</p>
<ol>
<li>索引是辅助索引（not primary key）；</li>
<li>索引不是唯一的（not unique）；</li>
</ol>

          <h5 id="b005ebe3">结构</h5><p>Insert Buffer的数据结构是一棵B+树，而且是全局共享的，负责对所有表的辅助索引进行Insert Buffer</p>

          <h4 id="b116ebfc">改动缓冲（Change Buffer）</h4><p>Change Buffer可以理解为Insert Buffer的升级，它对更新操作都进行缓冲——INSERT、DELETE、UPDATE，分别对应Insert Buffer、Delete Buffer、Purge Buffer；它面向的依然是非唯一的辅助索引</p>

          <h4 id="be9c297b">合并插入缓冲</h4><p>接下来我们了解Insert Buffer的合并时机：</p>
<ul>
<li><p>辅助索引页被读取到缓冲池时；</p>
<blockquote>
<p>比如在执行Select操作的时候，先检查Insert Buffer Bitmap，然后确认该辅助页在不在树上，在树上就把该页记录插入到辅助索引页中</p>
</blockquote>
</li>
<li><p>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间的时候；</p>
</li>
<li><p>钟点工Master Thread在认真地工作；</p>
</li>
</ul>

          <h4 id="99d092d7">两次写（Doublewrite）</h4><p>主要是保证数据页的可靠性，当数据库在写操作的中间时候发生宕机，这种情况叫做分写失败</p>
<p>我们之前了解过，重做日志中记录的是对该页的物理操作，但是如果这个页本身已经发生了损坏，再重做的意义就不大了，于是可用在<strong>应用重做日志之前</strong>，先准备一个页的副本，当写入失效的时候，先通过副本还原页，再进行重做，这就是<strong>两次写</strong>技术</p>
<p>我们先来看看doublewrite的架构</p>
<p>
        <div class="_showpic_c3d98b8b showpicbtn">Loading images >></div>
        <img href=https://image.youyinnn.top/20200612112402.png class="_pic_c3d98b8b hidepic" picId="c3d98b8b"></img>
        <script>
            {
                let imgselfc3d98b8bs = document.getElementsByClassName('_pic_c3d98b8b')
                let showpicbtnc3d98b8bs = document.getElementsByClassName('_showpic_c3d98b8b')
                let isInViewPortOfTwoc3d98b8b = function () {
                    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
                    const top = imgselfc3d98b8bs[0].getBoundingClientRect() && imgselfc3d98b8bs[0].getBoundingClientRect().top
                    if (top  <= viewPortHeight + 300) {
                        for (el of imgselfc3d98b8bs) {
                            el.src = el.getAttribute('href')
                            el.classList.add('showpic')
                            window.removeEventListener('scroll', isInViewPortOfTwoc3d98b8b)
                            isInViewPortOfTwoc3d98b8b = null
                        }
                        for (el of showpicbtnc3d98b8bs) {
                            el.style.display = 'none'
                        }
                    }
                }
                window.addEventListener('scroll', isInViewPortOfTwoc3d98b8b)
            }
        </script>
    </p>
<p>doublewrite由两部分组成：内存中的doublewrite buffer，另一部分是物理磁盘上共享表空间中连续的128页，大小都是2MB</p>
<p>在对脏页刷新的时候，不直接写到磁盘，而是先将脏页复制到内存中的doublewrite buffer，然后通过该buffer分写两次，每次1MB顺序地写入共享表空间磁盘，然后马上调用fsync函数，同步磁盘</p>
<p>在这个过程中，因为doublewrite页是连续的，所以写入过程是顺序的，执行非常快；写完doublewrite页之后，再将doublewrite buffer中的页写如各个表空间文件中；</p>
<p>如果要恢复数据，InnoDB可用从共享表空间中的doublewrite页中找到该页的副本，将其复制到表空间文件，再应用重做日志</p>

          <h4 id="ae0e746d">自适应哈希索引（Adaptive Hash Index）</h4><p>一般情况下，索引页都是B+树结构，虽然已经非常快了，但是随机访问还是没有哈希快，InnoDB引擎会对表上索引页的查询进行监控，如果觉得建立哈希索引可以提示速度，则简历哈希索引，这个哈希索引是从B+树页构造而来，所以建立的速度非常快</p>
<p>但是AHI的建立条件非常多但是这些条件不太需要用户去关心，引擎默认开启AHI的建立；</p>

          <h4 id="608caee0">异步IO（Async IO）</h4><p>AIO对应的是SIO（Sync IO），AIO的优势是充分利用线程的优势，异步读取多个对象；其另一个优势就是可以合并多个IO操作，也能够提高性能；</p>
<p>需要注意的是，AIO需要操作系统提供Native支持，Windows和Linus都行，Max OS不行；</p>

          <h4 id="d97fe32c">刷新邻接页（Flush Neighbor Page）</h4><p>再刷脏页的时候，引擎会检测该页所在区域（extent）的所有页，如果是脏页，那么一起刷新，这样做的好处的可以合并IO，但是对于读写速度比较快的磁盘，应用这个特性可能会带来一些问题，于是推荐在机械磁盘开启这个设置，在SSD等高速磁盘关闭该设置</p>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

</body>

</html>