<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="baidu-site-verification" content="l09YSIpJQW" />
    <meta name="referrer" content="origin">
    <title>blog | youyinnn</title>
    <script src="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@latest/myjs/loadscripts.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@latest/myjs/jump-1.4.js"></script>
    <link rel="bookmark" href="https://cdn.jsdelivr.net/gh/youyinnn/youyinnn.github.io@latest/img/favicon.ico" />
    <link rel="icon" href="/img/favicon.ico" type="image/ico"/>
    <link rel="stylesheet" href="/mycss/style.css">

    <script src="/resources/resources.js"></script>
    <script src="/myjs/scriptlist.js"></script>
</head>

<body>

    <ol id="topbar" class="breadcrumb unselectable new_font">
        <p style="color:rgb(214, 214, 214); padding-right: 1rem;">
            <button id="egg" class="egg">🚀</button>&nbsp;&nbsp;&nbsp;&nbsp;&gt;</p>
        <li class="breadcrumb-item">
            <spen id="homebut" href="javaScript:void(0)" class="ah">-home</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="articlesbut" href="javaScript:void(0)" class="ah">-articles</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="scriptbut" href="javaScript:void(0)" class="ah">-scripts</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="todobut" href="javaScript:void(0)" class="ah">-todos</spen>
        </li>
        <li class="breadcrumb-item">
            <spen id="resumebut" href="javaScript:void(0)" class="ah">-resume</spen>
        </li>
        <li class="breadcrumb-item dropdown">
            <spen href="javaScript:void(0)" class="ah" role="button" id="friendlinkedbut" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">-friends</spen>
            <div id="fldd" class="dropdown-menu" aria-labelledby="friendlinkedbut" style="border-radius: initial;"></div>
        </li>

        <div id="hb" data-toggle="tooltip" data-placement="bottom" title="show/hide TopBar">

        </div>
    </ol>

    <div id="homepage" class="unselectable new_font myhide">
        <div id="homepage-center">
            <div id="slogan">
                <i id="wolf-logo" style="font-style: normal;" class="mr-4">🌑</i><span id="slogan-text"></span>
            </div>
            <div id="homepage-btn">
                <div id="showmore"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; About Me & This Blog</div>
                <div id="showhacknical"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; My Github Analysis</div>
                <div id="toarticles"> &nbsp;&nbsp;&nbsp;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp; My Tech Articles</div>
            </div>
        </div>
        <div id="ifwrapper" class="hacknical_hide">
            <iframe id="hacknical_github_analysis" frameborder="0"></iframe>
        </div>
    </div>

    <div id="articles_side_panel" class="unselectable myhide new_font">
        <div id="cates_tree_head">Article Categories</div>
        <div id="cates_tree_body"></div>
        <div id="blog_statistic_head">Blog Statistics</div>
        <table id="blog_statistic_body" class="myhide">
            <tbody>
                <tr>
                    <td style="text-align:right">Online:</td>
                    <td style="text-align:left" id="stat_running"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Article:</td>
                    <td style="text-align:left" id="stat_article_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Chars:</td>
                    <td style="text-align:left" id="stat_typein"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Categories:</td>
                    <td style="text-align:left" id="stat_cate_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Tags:</td>
                    <td style="text-align:left" id="stat_tag_count"></td>
                </tr>
                <tr>
                    <td style="text-align:right">Last update:</td>
                    <td style="text-align:left" id="stat_last_update"></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="docpanel" class="myhide new_font">
        <div id="articlesearch" class="input-group">
            <input id="articlesearchtext" type="text" class="form-control" autocomplete="off" placeholder="search with keywords (algolia)">
            <div id="searchprocessbar">
                <div id="spb-out" class="spb-outter-animate"></div>
                <div id="spb-in" class="spb-inner-animate"></div>
            </div>
            <div class="input-group-append">
                <button id="cleanbut" class="btn btn-light" type="button" title="clear search">cls</button>
                <button id="categories" class="btn btn-light" type="button">cates</button>
                <button id="tags" class="btn btn-light" type="button" title="all tags">tags</button>
                <button id="articlesearchbut" class="btn btn-light" type="button" title="search">sch</button>
            </div>
        </div>
        <div id="searchrscount" class="unselectable"></div>
        <div class="tgs myhide" id="all_cates">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All categories:</span>
            <br>
        </div>
        <div class="tgs myhide" id="all_tags">
            <span style="font-size: 1rem; font-weight: bold ; padding: 6px;">All tags:</span>
            <br>
        </div>
    </div>

    <div id="sidetoccontainer" class="tochide unselectable new_font">
        <div id="block">
            <div id="percent" data-toggle="tooltip" data-placement="bottom" title="return to the top">0%</div>
        </div>
        <div id="sidetoc" class="unselectable markdown-body editormd-preview-container markdown-toc"></div>
    </div>
    <div id="md" class="myhide markdown-body editormd-html-preview">
        
          <h3 id="e25a21eb">Introduction</h3><p>我们先分析Leetcode的55题，是从45题Jump Game II 跳过来的，因为这题比II要简单一点，只需要判断序列是否能jump到终点就行，而45题是要找最小的jump次数；</p>
<p>为什么这题要拿出篇幅来分析？因为这题包含了很多东西： </p>
<ul>
<li><strong>纯回溯</strong></li>
<li><strong>纯回溯<code>---&gt;</code>回溯Top-down DP</strong></li>
<li><strong>回溯Top-Down DP<code>---&gt;</code>迭代Bottom-up DP</strong></li>
<li><strong>迭代Bottom-up DP<code>---&gt;</code>线性贪婪</strong></li>
</ul>
<p>分析完之后你会发现，原来算法可以这么美妙😃</p>

          <h3 id="fe10ab4a">Jump Game</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p><strong>Determine if you are able to reach the last index.</strong></p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.:</code></pre>
          <h4 id="9418e596">1. Backtracking</h4><p>无论是I还是II，我最开始只能想到的就是回溯法，而回溯法用于解这两题是会炸的，因为时间复杂度和递归栈太多了，单作为DP的第一步，我们还是先把回溯写出来</p>
<pre><code class="language-java">public boolean canJump(int[] nums) {
    return backtracking(nums, 0);
}

private boolean backtracking(int[] nums, int now) {
    if (now == nums.length - 1) {
        return true;
    } else {
        // 从允许的最大跳数开始跳
        int maxStep = nums[now];
        if (now + maxStep &gt;= nums.length) {
            maxStep = nums.length - now - 1;
        }
        for (int i = maxStep; i &gt;= 1; i--) {
            if (backtracking(nums, now + i)) {
                return true;
            }
        }
    }
    return false;
}</code></pre>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : <strong>O(2^n)</strong>. There are <strong>2^n</strong> (upper bound) ways of jumping from the first position to the last, where <em>n</em> is the length of array <code>nums</code>. For a complete proof, please refer to Appendix A.</li>
<li>Space complexity : <strong>O(n)</strong>. Recursion requires additional memory for the stack frames. </li>
</ul>

          <h4 id="4e7c82ed">2. Memorization: DP Top-down</h4><p>也许你已经意识到了，我们仅仅是想知道每一个位置是否能跳到最后一格而已，但是某个位置可能会有从不同地方跳过来的，如果第一次跳过来的时候，这时候肯定不知道这个位置能不能到达，然后从这个位置继续往下跳的时候就能回溯出一个结果来，如果我们将这个结果记录下来的话，那么第二次有从其他地方跳过来的时候，我们就知道这个位置往下走到底是个什么结果，这样就不必再继续往下跳然后等回溯了；</p>
<p>于是我们将每个位置的回溯结果记忆化：能到终点代表<strong><em>GOOD</em></strong>、不能到终点代表<strong><em>BAD</em></strong>、没尝试过代表<strong><em>UNKNOWN</em></strong></p>
<p>比如Leetcode上的例子：</p>
<p>An example of a memorization table for input array <code>nums = [2, 4, 2, 1, 0, 2, 0]</code> can be seen in the diagram below. We write <strong>G</strong> for a <em>GOOD</em> position and <strong>B</strong> for a <em>BAD</em> one. We can see that we cannot start from indices 2, 3 or 4 and eventually reach last index (6), but we can do that from indices 0, 1, 5 and (trivially) 6.</p>
<table>
<thead>
<tr>
<th>Index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>nums</td>
<td>2</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>memo</td>
<td>G</td>
<td>G</td>
<td>B</td>
<td>B</td>
<td>B</td>
<td>G</td>
<td>G</td>
</tr>
</tbody></table>
<p><strong>Steps</strong></p>
<ol>
<li>Initially, all elements of the <code>memo</code> table are <strong><em>UNKNOWN</em></strong>, except for the last one, which is (trivially) <strong><em>GOOD</em></strong> (it can reach itself)</li>
<li>Modify the backtracking algorithm such that the recursive step first checks if the index is known (<strong><em>GOOD</em></strong>/ <strong><em>BAD</em></strong>)<ol>
<li>If it is known then return <em>True</em> / <em>False</em></li>
<li>Otherwise perform the backtracking steps as before</li>
</ol>
</li>
<li>Once we determine the value of the current index, we store it in the <code>memo</code> table</li>
</ol>
<pre><code class="language-java">public class Solution {
    enum Index {
        GOOD, BAD, UNKNOWN
    }
    Index[] memo;
    public boolean canJumpFromPosition(int position, int[] nums) {
        if (memo[position] == Index.BAD) {
            return false;
        } else if (memo[position] == Index.GOOD) {
            return true;
        } else {
            int maxStep = Math.min(nums[position], nums.length - position - 1);
            for (int i = maxStep; i &gt; 0; i--) {
                if (canJumpFromPosition(position + i, nums)) {
                    memo[position + maxStep] = Index.GOOD;
                    return true;
                }
            }
            memo[position] = Index.BAD;
            return false;
        }
    }

    public boolean canJump(int[] nums) {
        memo = new Index[nums.length];
        for (int i = 0; i &lt; nums.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[nums.length - 1] = Index.GOOD;
        return canJumpFromPosition(0, nums);
    }
}</code></pre>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : <strong>O(n^2)</strong> For every element in the array, say <code>i</code>, we are looking at the next <code>nums[i]</code> elements to its right aiming to find a <em>GOOD</em> index. <code>nums[i]</code> can be at most <em>n</em>, where <em>n</em> is the length of array <code>nums</code>.</li>
<li>Space complexity : <strong>O(2n) =O(n)</strong>. First n originates from recursion. Second n comes from the usage of the memo table. </li>
</ul>
<p>送算减少了很多的回溯了，时间复杂度也从2的n次方降到n的2次方了，这回提交到Leetcode，打了11.11%</p>

          <h4 id="3945c3b3">3. Memorization: DP Bottom-up</h4><p>上篇练习过挺多DP的，但是都没仔细研究过<strong>自顶向下</strong>和<strong>自底向上</strong>，正好借这题来分析分析</p>
<p>我们的问题，若是要从一头到另一头，比如这一题，需要从起点跳到终点，然后从终点回溯回来（也许是跳到了之前回溯好了的结果），这样才能知道结果，形式化的想象一下，我们主动地发送请求到服务端，然后服务端返回结果，这是一个过去/回来的过程；</p>
<p>如果我们能直接从服务端返回结果，那么就少花一半以上的effort，也就是说，我们可以从终点直接往回走！</p>
<p>因为我们起点部分的点的结果，都是从终点附近的后半段点的结果递归回来的，我们这样做是提前从后半段算回结果</p>
<p>于是我们可以通过两个for循环，消除回溯调用栈</p>
<pre><code class="language-java">enum Index {
    GOOD, BAD, UNKNOWN
}

public class Solution {
    public boolean canJump(int[] nums) {
        Index[] memo = new Index[nums.length];
        for (int i = 0; i &lt; nums.length; i++) {
            memo[i] = Index.UNKNOWN;
        }
        memo[nums.length - 1] = Index.GOOD;

        for (int i = nums.length - 2; i &gt;= 0; i--) {
            int maxStep = Math.min(nums[i], nums.length - i - 1);
            // 从当前position的第一步开始
            for (int j = i + 1; j &lt;= i + maxStep; j++) {
                if (memo[j] == Index.GOOD) {
                    memo[i] = Index.GOOD;
                    break;
                }
            }
        }

        return memo[0] == Index.GOOD;
    }
}</code></pre>
<p><strong>Complexity Analysis</strong></p>
<ul>
<li>Time complexity : <strong>O(n^2)</strong>. For every element in the array, say <code>i</code>, we are looking at the next <code>nums[i]</code> elements to its right aiming to find a <em>GOOD</em> index. <code>nums[i]</code> can be at most <em>n</em>, where <em>n</em> is the length of array <code>nums</code>.</li>
<li>Space complexity : <strong>O(n)</strong>. This comes from the usage of the memo table. </li>
</ul>
<p>我们又优化了一下DP，这次打了30.77%，似乎还不错，再看看能不能再有什么优化的地方</p>

          <h4 id="bcfc086">4. Refine The DP</h4><p>如果我们减负去很多题目以外的概念的话，我们将会得到一个很简单的Memo模型：和自底向上一样，只不过我们不需要考虑什么<strong><em>UNKNOWN</em></strong></p>
<pre><code class="language-java">public boolean canJump(int[] nums) {
    boolean[] can = new boolean[nums.length];
    can[nums.length - 1] = true;
    for (int i = nums.length - 2; i &gt;= 0; i--) {
        int steps = nums[i];
        for (int j = i + 1; j &lt; nums.length &amp;&amp; j &lt;= i + steps; j++) {
            if  (can[j]) {
                can[i] = true;
                break;
            }
        }
    }
    return can[0];
}</code></pre>
<p>这次打了34.76%，别看和上面的没提升多少，相比之下这已经减少了1倍以上的耗时了，我们似乎已经达到了这道题DP的极限了，再靠DP的思维已经无法再进行优化了，这时候我告诉你，差一步你就能将这个DP转为线性解法，你可能会崩溃</p>

          <h4 id="d4ee57aa">5. Greedy</h4><p>从上面的DP我们可以发现，每当我们的到达一个新的位置（i）的时候，它就会往后找，找到一个GOOD就break掉，于是我们就认为这个新位置也是GOOD，而这个被找到的GOOD，就是当前新位置能reach到的第一个GOOD，因为一旦reach到这个GOOD，那么其他case就不比再考虑了，所以我们才break；</p>
<table>
<thead>
<tr>
<th>Index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>nums</td>
<td>9</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>memo</td>
<td>U</td>
<td>G</td>
<td>B</td>
<td>B</td>
<td>B</td>
<td>G</td>
<td>G</td>
</tr>
</tbody></table>
<p>那么如果说，我们每次都记录最后的GOOD的位置，于是我们仅仅需要计算，<strong>当前位置能不能reach到这个GOOD</strong>就行了，而这一步甚至不需要迭代，只要当前位置能跳的距离大于等于这个GOOD的位置就好了，于是我们可以从后往前线性地得到题解：</p>
<pre><code class="language-java">public boolean canJump(int[] nums) {
    int lastPos = nums.length - 1;
    for (int i = nums.length - 1; i &gt;= 0; i--) {
        if (i + nums[i] &gt;= lastPos) {
            lastPos = i;
        }
    }
    return lastPos == 0;
}</code></pre>

          <h3 id="71847fd8">Jump Game II</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.</code></pre>
          <h4 id="6cc9381b">1. Backtracking - O(2^n)</h4><p>不多BB</p>
<pre><code class="language-java">public int jump(int[] nums) {
    return dfs(nums, 0, 0, Integer.MAX_VALUE);
}

private int dfs(int[] nums, int now, int jump, int minJump) {
    if (jump &gt;= minJump) {
        return minJump;
    }
    if (now == nums.length - 1) {
        return Math.min(jump, minJump);
    } else {
        int subJump = Integer.MAX_VALUE;
        for (int i = 1; i &lt;= nums[now] &amp;&amp; now + i &lt; nums.length; i++) {
            subJump = Math.min(dfs(nums, now + i, jump + 1, minJump), subJump);
        }
        return Math.min(subJump, minJump);
    }
}</code></pre>
<p>不用多想，时间复杂度爆掉了</p>

          <h4 id="b0df4e79">2. DP Bottom-up - O (n^2)</h4><pre><code class="language-java">public int jump(int[] nums) {
    int[] dp = new int[nums.length];
    for (int i = nums.length - 2; i &gt;= 0; i--) {
        // one jump to the end
        if (i + nums[i] &gt;= nums.length) {
            dp[i] = 1;
        } else {
            // jump max step if it can reach the end
            int tmp = Integer.MAX_VALUE;
            for (int j = i + 1; j &lt;= i + nums[i]; j++) {
                if (dp[j] != Integer.MAX_VALUE) {
                    tmp = Math.min(tmp, dp[j] + 1);
                }
            }
            dp[i] = tmp;
        }
    }
    return dp[0];
}</code></pre>

          <h4 id="5dc338ca">3. BFS - O (n)</h4><p>参考自：<a href="https://leetcode.com/problems/jump-game-ii/discuss/18019/10-lines-C%252B%252B-(16ms)-Python-BFS-Solutions-with-Explanations">10-lines C++ (16ms) / Python BFS Solutions with Explanations</a></p>
<p>如果我们仅观察步数的增长的话，我们其实能够把数组视为一棵以跳数来分层的数结构，这也是这道题能够用广度优先搜索来思考的关键点</p>
<p>比如<code>nums = [2, 3, 1, 1, 4]</code>，第一层是我们的起点<code>2</code>，它能够到达的下一层数字有<code>3,1</code>，而<code>3,1</code>的下一跳能够到达的是<code>1,4</code>如此一来我们仅需要跳2层就能够到达终点了；</p>
<p>再比如<code>nums = [2, 6, 5, 2, 3, 7, 4, 9, 8, 2, 1, 1]</code>，第一层<code>2</code>，第二层<code>6, 5</code>，第三层<code>2,3,7,4,9</code>，因为最多能从<code>i = 1, nums[1] = 6</code>跳到<code>nums[1 + 6] = nums[7] = 9</code>，然后第三层的第一个数必定是第二层结尾的下一个数，以此类推第四层<code>2, 1, 1</code></p>
<pre><code class="language-java">public int jump(int[] nums) {
    int jump = 0;
    int start = 0, end = 0;
    // when end reach the final index
    // that means we finish the jump
    while (end &lt; nums.length - 1) {
        // jump first
        jump++;
        // at least one position on next floor
        int tmpEnd = end + 1;
        for (int i = start; i &lt;= end; i++) {
            // hit the final straight
            if (i + nums[i] &gt; nums.length) {
                return jump;
            }
            tmpEnd = Math.max(tmpEnd, i + nums[i]);
        }
        // visit next floor
        start = end + 1;
        end = tmpEnd;
    }
    return jump;
}</code></pre>

          <h3 id="fd3f1d11">Edit Distance</h3><p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em>.</p>
<p>You have the following 3 operations permitted on a word:</p>
<ol>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>
<p><strong>Example 1:</strong></p>
<pre><code>Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
Output: 3
Explanation: 
horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)
rorse -&gt; rose (remove &#39;r&#39;)
rose -&gt; ros (remove &#39;e&#39;)</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
Output: 5
Explanation: 
intention -&gt; inention (remove &#39;t&#39;)
inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)
enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)
exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)
exection -&gt; execution (insert &#39;u&#39;)</code></pre>
          <h4 id="4800a877">DP Top-down For Edit Distance</h4><p>这题，乍一看一脸懵逼，咋还有3种情况！咋还随便什么位置都能有这三种情况！怎么玩！用什么思路！</p>
<p>思考几分钟后无果，果断去讨论区找思路，然后看到高评DP解，醍醐灌顶- -</p>
<p>简单来说，虽然对比到有不同有<strong>3</strong>种情况，但是我们还是可以按照顺序来给两个word做一个矩阵，于是熟悉的操作就来了，</p>
<pre><code class="language-java">a = ac, b = ae

     j = 0 1
         a e
i = 0 a  0 1
    1 c  1 1

我们看到，当我们走到i = 1，j = 1的时候，我们有3种选择：
1. 直接替换，于是操作数在a -&gt; a的基础上+1；
2. 删除c，我们在ac -&gt; a完成之后的基础上，继续进行a -&gt; ae；
3. 插入e，我们在ac -&gt; aec完成之后的基础上，继续进行aec -&gt; ae；

（上面这一套是巨难理解的地方）

于是在这3个选择中选最小值</code></pre>
<p>矩阵都来了，dp就完事了，于是我们可以想象一下状态转移公式：</p>
<pre><code class="language-java">String a,b

F(i, j) = {
    if a.charAt(i) == b.charAt(j)
        dp[i][j] = dp[i - 1][j - 1];
    else
        dp[i][j] = min of {
            dp[i - 1][j - 1],    // replace
            dp[i][j - 1],        // insert
            dp[i - 1][j]        // delete
        } + 1
}

base case：
    dp[i][0] = i;
    dp[0][j] = j;</code></pre>
<p>于是代码为：</p>
<pre><code class="language-java">public int minDistance(String word1, String word2) {
    int[][] dp = new int[word1.length() + 1][word2.length() + 1];
    for (int i = 0; i &lt;= word1.length(); i++) {
        dp[i][0] = i;
    }
    for (int j = 0; j &lt;= word2.length(); j++) {
        dp[0][j] = j;
    }
    for (int i = 1; i &lt;= word1.length(); i++) {
        for (int j = 1; j &lt;= word2.length(); j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                // same as before
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1
                        + Math.min(
                                // replace
                                dp[i - 1][j - 1],
                        Math.min(
                                // delete
                                dp[i - 1][j],
                                // insert
                                dp[i][j - 1]));
            }
        }
    }
    return dp[word1.length()][word2.length()];
}</code></pre>

          <h4 id="d483efbb">DP Bottom-up + Backtracking</h4><p>我们还可以用回溯的形式去计算dp，也就是说以自底向上的思路去求解</p>
<pre><code class="language-java">public int minDistance(String a, String b) {
    int[][] dp = new int[a.length() + 1][b.length() + 1];
    return dfs(a, b, a.length() - 1, b.length() - 1, dp);
}

private int dfs(String a, String b, int i, int j, int[][] dp) {
    if (i == -1) {
        return j + 1;
    }
    if (j == -1) {
        return i + 1;
    }
    if (dp[i][j] == 0) {
        if (a.charAt(i) == b.charAt(j)) {
            dp[i][j] = dfs(a, b, i - 1, j - 1, dp);
        } else {
            dp[i][j] = 1
                    + Math.min(
                            dfs(a, b, i - 1, j - 1, dp),
                    Math.min(
                            dfs(a, b, i - 1, j, dp),
                            dfs(a, b, i, j - 1, dp)));
        }
    }
    return dp[i][j];
}</code></pre>

          <h3 id="552cc9d1">New 21 Game</h3><p>Alice plays the following game, loosely based on the card game &quot;21&quot;.</p>
<p>Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities.</p>
<p>Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points?</p>
<p>Example 1:</p>
<blockquote>
<p>Input: N = 10, K = 1, W = 10<br>Output: 1.00000<br>Explanation:  Alice gets a single card, then stops.</p>
</blockquote>
<p>Example 2:</p>
<blockquote>
<p>Input: N = 6, K = 1, W = 10<br>Output: 0.60000<br>Explanation:  Alice gets a single card, then stops.<br>In 6 out of W = 10 possibilities, she is at or below N = 6 points.</p>
</blockquote>
<p>Example 3:</p>
<blockquote>
<p>Input: N = 21, K = 17, W = 10<br>Output: 0.73278<br>Note:</p>
<p>0 &lt;= K &lt;= N &lt;= 10000<br>1 &lt;= W &lt;= 10000<br>Answers will be accepted as correct if they are within 10^-5 of the correct answer.<br>The judging time limit has been reduced for this question.</p>
</blockquote>

          <h4 id="244c0fb7">DP Top-down For 21 Game</h4><p>这题刚上手确实过于难，看了官方题解后才能有比较清晰的了解。</p>
<p>首先我们需要理解题中的3个值：</p>
<ul>
<li>N值：获胜目标分，想要获胜的话，我们的积分就必须低于等于N；</li>
<li>K值：停抽分，一旦我们最后一手牌抽到再累积积分超过K值，就停止抽牌，否则必须再抽一张；</li>
<li>W值：牌面最大分值，我们抽牌能够获取【0~W】值的积分；</li>
<li>起始积分：0分；</li>
</ul>
<p>然后我们再来分析例子：</p>
<ol>
<li>K为1，意味着我们最多只能抽一次牌，最多的积分只能为1~10分，总积分低于等于N值（10）的概率为100%；</li>
<li>K为1，意味着我们最多只能抽一次牌，最多的积分只能为1~10分，总积分低于等于N值（6）的概率为60%；</li>
</ol>
<p>再来分析例3，K为17时，我们看最后只能抽一手牌的情况，也就是积分为16的时候，这时候我们最好一手抽出的积分情况为：</p>
<pre><code class="language-graph">┌-----┐┌-----┐┌-----┐┌-----┐┌-----┐┌-----┐┌-----┐┌-----┐┌-----┐┌-----┐┌-----┐┌-----┐
| ... ||  16 ||  17 ||  18 ||  19 ||  20 ||  21 ||  22 ||  23 ||  24 ||  25 ||  26 | &lt;--- 总积分
└-----┘└-----┘└-----┘└-----┘└-----┘└-----┘└-----┘└-----┘└-----┘└-----┘└-----┘└-----┘
                 1      1      1      1      1      0      0      0      0      0    &lt;--- 是否获胜</code></pre>
<p>于是我们可以知道在积分等于16的时候，获胜的概率：</p>
<p>我们设<em>f(x)</em>，为积分为x的时候，获胜的概率，于是有</p>
<p>$$<br>\begin{aligned}<br>f(16) &amp;= \frac {1} {10} \cdotp (1 + 1+ 1+ 1+ 1 + 0 + 0 + 0 + 0 + 0) \\<br>&amp;= \frac {5} {10} = 0.5<br>\end{aligned}<br>$$</p>
<p>并且：</p>
<p>$$<br>f(17) = f(18) = f(19)  = f(20)  = f(21)  = 1 \\  f(22) = f(23) = f(24)  = f(25)  = f(26)  = 0<br>$$</p>
<p> 于是我们可以得到初步的状态转移方程：</p>
<p>$$<br>\begin{aligned} f(x) &amp;= \frac {1} {W} \cdotp (f(x + 1) + f(x + 2) + \dotsb + f(x + W)) \\  f(x - 1) &amp;= \frac {1} {W} \cdotp (f(x) + f(x + 1) + \dotsb + f(x + W - 1)) \\ \vdots \\ f(0) &amp;= \frac {1} {W} \cdotp (f(1) + f(2) + \dotsb + f(W)) \end{aligned}<br>$$</p>
<p>到这里为止，其实我们已经能够写出题解了，但是我们要是以高中生的眼光来看上面的公式，我们不难发现，后一项和前一项的公式中其实有部分个结果是有重复的部分，<em>f(x)</em>和<em>f(x - 1)</em>中有重叠的<em>f(x + 1) + ... + f(x + W - 1))</em>，于是我们可以两式相减来简化一下：</p>
<p>$$<br>\begin{aligned} f(x) - f(x - 1) &amp;= \frac {1} {W} \cdotp (\bcancel{f(x + 1)} + \bcancel{f(x + 2)} + \bcancel{\dotsb} + f(x + W)) \\ &amp;\quad- \frac {1} {W} \cdotp (f(x) + \bcancel{f(x + 1)} + \bcancel{\dotsb} + \bcancel{f(x + W - 1)}) \\ &amp;= \frac {1} {W} \cdotp (f(x + W) - f(x)) \end{aligned}<br>$$</p>
<p>于是有：</p>
<p>$$<br>f(x)  - f(x - 1)  = \frac {1} {W} \cdotp (f(x + W) - f(x))<br>$$</p>
<p>到这里有两个化简选择：</p>
<ol>
<li><p>如果<em>f(x - 1)</em>右移：</p>
<p>$$<br>f(x) = \frac {1} {W} \cdotp (f(x + W) - f(x))  - f(x - 1)<br>$$</p>
<p>这样无法求解，因为我们是从后往前推到的转移公式，最终是要推导道<em>f(0)</em>，我们希望的是要有：</p>
<p>$$<br>f(x) = C \cdot f(x + 1) + k<br>$$</p>
<p>这样的公式，这样我们才能倒序循环，从后一项推出前一项的值，观察上面的化简式可以发现，式中有3个高一项的值，一个矮一项的值，我们把高的都放右边，矮的单独放左边，于是有第二种化简</p>
</li>
<li><p><em>f(x - 1)</em>右移后，原式右边左移，最后左右翻转一下：<br>$$<br>\begin{aligned} f(x - 1) &amp;= f(x) -  \frac {1} {W} \cdotp (f(x + W) - f(x)) \\ f(x) &amp;= f(x + 1) -  \frac {1} {W} \cdotp (f(x + 1 + W) - f(x + 1)) \end{aligned}<br>$$</p>
</li>
</ol>
<p>上式就是我们最终得出的简化的通项公式，然后我们兴高采烈地写出题解：</p>
<pre><code class="language-java">public double new21Game(int n, int k, int w) {
    if (k == 0) return 1.0;
    double[] dp = new double[k + w + 1];
    for (int i = k; i &lt;= k + w - 1 &amp;&amp; i &lt;= n; i++) {
        dp[i] = 1.0;
    }
    for (int i = k - 1; i &gt;= 0; i--) {
        dp[i] = dp[i + 1] - (dp[i + w + 1] - dp[i + 1]) / w;
    }
    return dp[0];
}</code></pre>
<p>结果爆炸，这到底是为什么呢？演算一下，我们发现<em>dp[16]</em>居然算出1.1000000，显然和事实的0.5不符，我们假设化简后通项公式不适用于<em>dp[K-1]</em>，那么我们需要先计算好这个值，再从<em>dp[K-2]</em>，开始去尝试，那么<em>dp[K-1]</em>等于多少呢？</p>
<p>我们在得到16分的时候，距离21分还有10张牌里有5种赢的可能，那就是21-16+1，也就是<em>N-K+1</em>，而如果说这时候W等于3，那么就最多只有3张牌里有3种赢的机会，所以我们可以得出公式：<br>$$<br>f(K - 1) = \frac {1} {W} \cdot min(N-K+1, W)<br>$$<br>于是我们最终的代码为：</p>
<pre><code class="language-java">public double new21Game(int n, int k, int w) {
    if (k == 0) return 1.0;
    double[] dp = new double[k + w + 1];
    for (int i = k; i &lt;= k + w - 1 &amp;&amp; i &lt;= n; i++) {
        dp[i] = 1.0;
    }
    dp[k - 1] = 1.0 * Math.min(n - k + 1, w) / w;
    for (int i = k - 2; i &gt;= 0; i--) {
        dp[i] = dp[i + 1] - (dp[i + w + 1] - dp[i + 1]) / w;
    }
    return dp[0];
}</code></pre>

    </div>
    <div id="scriptsearcher" class="myhide input-group new_font">
        <input id="searchtext" type="text" class="form-control" placeholder="keywords" autocomplete="off">
        <div class="input-group-append">
            <button id="searchbut" class="btn btn-dark" type="button">Search</button>
        </div>
    </div>

    <div id="bbt" class="myhide new_font">
        <a id="toc" style="display: none;" class="myhide" href="javascript:void(0);" data-toggle="tooltip" data-placement="left" title="show/hide Toc">Toc</a>
        <a id="gohub" href="#" target="_blank" data-toggle="tooltip" data-placement="bottom" title="view this at github">unuse</a>
    </div>

    <div id="share_png_panel" class="myhide">
        <div id="share_curtain"></div>
        <div id="png_box"></div>
        <button id="share_png_paned_close" class="btn btn-dark">Close</button>
    </div>

</body>

</html>