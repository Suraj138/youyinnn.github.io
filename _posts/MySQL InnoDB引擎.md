---
title: MySQL InnoDB引擎
categories:
  - db
  - mysql
  - engines
tags:
  - mysql-engins
series: 《MySQL技术内幕：InnoDB存储引擎》笔记
date: 2020-6-11 19:12:14
---



### 介绍

本篇主要介绍了MySQL系统的核心引擎，本系列所有的内容是基于姜承尧老师所著*《MySQL技术内幕：InnoDB存储引擎》*再加上整理的网络笔记、MySQL5.7的[官方文档](https://dev.mysql.com/doc/refman/5.7/en/)和自己的一些理解

### InnoDB

MySQL5.5.8以后的默认引擎，支持事物、行锁设计、外键、全文索引、非锁定读（默认读操作不会产生锁）；

使用多版本并发控制（MVCC）来支持高并发性，并实现了4中标准的隔离级别，能避免幻读；还提供了许多其他的特性来支持高性能高并发；

#### 体系架构

![](https://image.youyinnn.top/20200611211157.png)

引擎的内存中主要包含以下工作区域：

1. 线程维护区域/线程所需内部数据结构区域
2. 数据缓存，数据修改之后并不是马上进入磁盘文件，而是先缓存在这里；
3. 重做日志缓冲；

#### 后台线程的分类

1. **Master Thread**：核心线程，主要负责将缓冲池中的数据异步地刷新到磁盘，保证数据一致性；
2. **IO Thread**：引擎使用了大量的AIO技术来处理写IO请求，以提高数据库的性能，该线程的工作是处理这些IO的回调；而在Windows系统中，IO线程的数量可以调整；
3. **Purge Thread**：事物被提交后，其所使用的undolog可能不再被需要，该线程是负责回收这些被分配的undo页；该线程的线程数也支持配置，提高性能；
4. **Page Cleaner Thread**：主要完成脏页的刷新操作，提高性能；

#### 内存/内存对象

#### 缓冲池

InnoDB是基于磁盘文件存储的引擎，并将数据按页分配和管理。而由于CPU和磁盘的IO差距，想要提高性能，肯定是要利用系统内存区弥补IO差距的，所以我们可以简单地将缓冲池理解为磁盘数据文件的内存映射

##### 基本逻辑和内容

**读操作**：系统启动的时候，会缓存（FIX）部分页到缓冲池里，在读页的时候，首先去缓冲池里找，如果找到了就直接读取，否则就从磁盘上读

**写操作**：首先修改缓冲池中的页，然后再以一定频率刷新到次磁盘上，而且不是一有页更新就刷，而是根据一种叫**Checkpoint**的机制来刷

缓冲池的内存大小也直接影响了数据库的性能，我们也可以再配置中调节它的大小，也能够调节缓冲池的实例个数，多缓冲池实例的好处是每个页会更散列地分配到不同实例当中，好处是减少内部资源竞争

缓冲池的内存数据对象如下：

![](https://image.youyinnn.top/20200611215932.png)

##### 缓冲算法

对于缓冲池的管理，引擎使用了基本的三种算法来完成：**LRU List、Free List、Flush List**

假设我们知道基本的LRU缓存算法，但再InnoDB中的LRU算法又不太一样，它提供了一个***midpoint***来处理使用频率更新时，节点的放置策略：在新读取到页的时候，虽然是最新访问的，但是并不是放到队列的头部，而是放在大概中间的位置，默认是列表长度的5/8处，这个值也是可以进行配置的

而我们把这个点之前的页称为new列表，表示是使用频繁的热点数据，后面的称为old列表

InnoDB之所以对算法进行改进的原因是：某些SQL操作可以能会把相当一部分的页甚至是所有页都刷出去，如果热点数据放在头部，那么它有可能最早被刷出，而下一次需要的时候，又从磁盘读取，非常影响性能

**Free列表是干嘛的呢？**

在数据库刚启动的时候，LRU列表是空的，没有任何的页，因为这时候页都在Free列表中。当需要从缓冲池中分页的时候，首先从Free列表中查找是否有可用的空闲页，有就直接将该页从Free列表移动到LRU列表

**Flush列表和脏页**

在LRU列表中的页被修改之后，该页被称为脏页，这时候该页的数据和磁盘上对应的映射数据不一致，于是引擎通过Checkpoint机制将脏页刷回磁盘，我们把脏页都放在Flush列表中

*注意：脏页即存在LRU列表中，页存在Flush列表中，两者逻辑上分工不同*

##### 重做日志缓冲

在一个事物的过程中，引擎会先把重做日志放到缓冲区，然后再按照频率刷新到重做日志文件。在这样的场景下，重做日志缓存一般不会占用太多内存，保证每秒的事物量在这个范围内就好，默认的8M，也是能够配置的

> 重做日志刷新的时机：
>
> 1. Master Thread每一秒都刷一次；
> 2. 每个事物提交的时候也会刷；
> 3. 重做日志空间剩余空间小于1/2的时候，也会刷；

##### 额外的内存

剩下还有一些额外内存，用于分配数据库所需的对象、数据结构等，用于记录锁信息和LRU以及等待的信息

#### Checkpoint机制

 当出现脏页的时候，需要把数据刷回磁盘，但不能每出现一次脏页就刷回，这样会增加IO的压力，从而性能会很差；同时，如果在刷页的时候系统挂了，那么数据就难以恢复；大部分数据库系统采用了Write Ahead Log的策略，即先写重做日志，再修改页，在出意外的时候，可用日志恢复；

而Checkpoint技术的出现主要是为了解决：

1. 缩短数据恢复的时间；

   > 当系统挂掉的时候，数据库不需要套重做所有的日志，checkpoint之前的页已经刷回磁盘；只需要恢复checkpoint后面的页就行；

2. 缓冲池不够用的时候，将脏页刷到磁盘；

   > 缓冲池不够用的时候，LRU算法会溢出最近少使用的页，如果这个页是脏页，那么需要强制执行checkpoint，将脏页刷回磁盘

3. 重做日志**不可用**的时候，刷新脏页；

   > 在重做日志不够用的时候，强制产生checkpoint，将缓冲池的页至少刷新到当前重做日志的位置；

Checkpont分为2种：

1. Sharp Checkpoint：数据库即将关闭的时候将所有的脏页刷回磁盘；
2. Fuzzy Checkpoint：运行时的Checkpoint，每次只刷新部分脏页，保证数据库可用性；

#### Main Thread

Main Thread具有最高的线程优先级，其内部由多个循环组成：主循环（loop）、后台循环（backgroud loop）、暂停循环（suspend loop）。主线程会根据数据库的状态在不同下循环之间进行切换

##### Loop

主循环的工作有2部分：

1. 每秒一次：
   - （总是）日志缓存刷到磁盘，即使事物还没提交；
   - （可能）合并插入缓冲，是否发生看IO的次数，次数小就可用执行合并；
   - （可能）最多刷100个脏页到磁盘，是否发生看脏页比例，超过某个阈值就刷；
   - （可能）如果当前用户没有活动，切换到后台循环；
2. 每10秒一次：
   - （可能）刷100个脏页；
   - （总是）合并若干个插入缓冲；
   - （总是）刷日志到磁盘；
   - （总是）删除无用的Undo页；
   - （总是）刷100个脏页或者10个脏页到磁盘；

在InnoDB版本迭代之后，每次可以刷不只100页脏页，可以自己调节

##### Background Loop

如果当前用户没有活动，或者数据库要关闭了，那么就会切换到这个循环，它的工作有：

1. （总是）删除无用的Undo页；
2. （总是）合并20个插入缓冲；
3. （总是）跳回主循环；
4. （可能）刷100页直到符合条件（在flush loop还在主线程的时候）

