---
title: MySQL InnoDB事务概述
categories:
  - db
  - mysql
  - transaction
tags:
  - db-transaction
  - mvcc
series: 《MySQL技术内幕：InnoDB存储引擎》笔记
date: 2020-6-17 14:45:26
---





本篇介绍内容：

- 数据库系统中事务的相关概念；
- SQL隔离级别要解决的问题；
- InnoDB中的隔离级别；
- InnoDB支持什么样的事务以及如何支持事务；



### 事务相关概述

#### ACID

在数据库中，事务可以是一条简单的SQL语句，也可以是一组复杂的SQL语句；一个事务是访问并更新数据库的一个**执行单元**；

数据库要保证的是，事务中的操作要么全部成功，要么全部无效；

事务的保证需要遵循**ACID特性**，但是数据库可以不必严格满足**ACID**，对于InnoDB来说，它是完全满足了ACID的

**原子性（Atomicity）**

是指整个事务是一个不可切分的工作单位，整个事务中所有的数据库操作要都成功，该事务才算成功；事务中任何一个语句失败则整个事务都失败；

**一致性（Consistency）**

指事务从一个状态转变到下一个状态的过程中，事务的开始和结束后，数据库的完整性约束没有被破坏；例如某个字段是唯一的，在事务进行当中如果破坏了该字段的唯一性，系统会撤销该事务，然会到初始状态；

**隔离性（Isolation）**

隔离性在MySQL的InnoDB中还代表着：并发控制、可串行化、锁等；

事务的隔离性要求每个对鞋事务的对象对其他事务的操作对象能够互相分离，即该事务提交前对其他事务都不可见，一般是用锁来实现；

**持久性（Durability）**

事务一旦提交，其结果是永久性的，即使发生宕机事故，数据库也能恢复该数据；

#### 事务的分类

理论上来说，事务可以被分为以下几种类型：

- 扁平事务；
- 带保存点的事务；
- 链事务；
- 嵌套事务；
- 分布式事务；

**扁平事务**

它是使用得最多的事务类型，它的所有操作都在同一个层次，其间的操作都是原子的，要么都执行，要么都回滚，因此扁平事务是程序称为原子操作的基本组成

**带保存点的事务**

允许在事务执行的过程中回滚到**同一事务中较早的某个状态**，虽然扁平事务的使用率高，但是有些事务在执行过程中万一出错就要回滚整个事务好像有点不划算，于是利用**保存点（save point）**机制来让系统支持事务的部分回滚

对于扁平事务，其保存点是事务的最开始

**链事务**

在一个事务进行时如果系统崩溃，那么其所有的保存点都会消失，当进行恢复的时候，事务又要重新开始执行，而不会从最近一个保存点开始执行

链事务的思想是：在提交一个事务的时候，开始下一个事务，这个过程是原子的，意味着下一个事务能看到上一个事务的结果，就好像它们处于同一个事务一样；

不同的是：

- 事务的回滚仅能回到当前事务节点的保存点，而不能回到之前事务节点的保存点；

- 任意节点commit之后，会释放相应事务节点所设计的锁，而带有保存点的事务的任何回滚操作都不会放锁；

**嵌套事务**

一个事务中可以开启其他事务，所属关系为父子关系，在结构上是一棵树；其特点是：

1. 子事务可以是任何类型的事务；
2. 子事务的提交并不立即生效，而是都在顶层事务提交后再提交；
3. 树中任意事务回滚都会引起其他子事务的一同回滚

**分布式事务（XA事务）**

分布式事务是处理不同主机、不同数据库甚至是同一数据库实例的不同引擎之间的**扁平事务**，我们把不同的执行上下文称为一个节点；

对于分布式事务，其对ACID的要求是最严格的，任何节点的事务失败，则整个事务都会失败；

实现分布式事务的各个节点的隔离级别都需要是**SERIALIABLE（串行化）**级别

分布式事务的基本模型为：一个或多个资源管理器、一个事务管理器、一个应用程序；

- 资源管理器：通常由数据库代表；
- 事务管理器：协调参与全局事务中的各个事务，需要和所有节点通信；
- 应用程序：事务发起方；

![](https://image.youyinnn.top/20200616171712.png)

### 事务的实现

事务的隔离性由锁来实现，而原子性、一致性、持久性由事务来保持

- redo log，用来保证原子性、持久性，基本上是顺序读写；
- undo log，用来保证事务的一致性和MVCC，需要进行随机读写；

#### Redo的概念

为了实现事务的持久性，设计了**重做日志**，其由两部分组成：

1. 内存中的重做日志缓冲（redo log buffer）；
2. 文件中的重做日志文件（redo log file）；

InnoDB为了能保证事务的理论特性，通过***Force Log at Commit***机制实现事务的持久性，在事务提交的时候，必须先把该事务的所有**“日志”**写入到**重做日志文件**中，然后再真正执行COMIMIT

这里的**“日志”**由两部分组成，一是redo log，二是undo log；

为了确保重做日志的及时性和有效性，当要把日志从缓冲写到文件系统后，引擎都要调用一次主机系统的fsync操作，由于这个操作依赖磁盘性能，所以事务也依赖磁盘性能，所以数据库整体就依赖磁盘性能；

#### Undo

##### 作用

重做日志记录了事务的行为，可以很好地重做页；但是事务还需要回滚操作，这时候就会需要undo，在数据要修改的时候，引擎不仅会产生redo，还会产生一定量的undo，这样如果某条语句失败了，或者用户可以主动地调用回滚，将数据滚回之前的样子

于是，**“回滚”**是undo第一个要做的事

redo存放在重做日志文件中，而undo是存在数据库内部的一个特殊段（segment）中，这个undo段位于共享表空间里

需要注意的是：undo并非用于将数据库**物理地**恢复到事务之前的样子，实际上undo是逻辑日志，它将数据**逻辑地**恢复到原来的样子；我们可以理解为：

> 你怎么改的哪些东西，就怎么改哪些东西回去，而不是将整个页都改回原来的样子

因为只有这样，你才能不会影响到其他线程的事务

**undo还有一个作用是MVCC**，MVCC的实现是通过undo来完成的，当读取一条被锁定的记录的时候，不会阻塞在此而是通过undo来读取之前的行版本信息，实现**非锁定读**

最后，undo的执行也会产生redo log，因为它页需要持久性保护

那么undo究竟在干嘛？当事务提交的时候，**引擎会为undo机制做以下两件事**：

1. 将undo log放入列表，以供purge操作；
2. 判断undo log所在页释放可以重用，以供下个事务使用；

事务提交后不会马上删除undo log和相关undo log页，因为可能还有其他事务需要这个undo的版本，所以undo的删除页交由purge线程来判断

##### purge线程

那么怎么决定什么样的undo log要删除呢？我们先来了解以下undo log的分类：

- insert undo log

  是指insert操作产生的undo log，因为该操作只对当前线程可见，所以一旦事务提交，则该undo log可以直接删除，不需要转给purge；

- update undo log

  是指delete和update语句产生的undo log，这些操作因为可能会被其他事务的MVCC所需要，所以会保留一段时间，直到没有事务线程引用其MVCC版本就会删除；

我们把重点放在第 第二种log上，由于一些update操作需要保留一些undo log来支持MVCC，所以实际上这些操作设计到的数据记录页并没有**马上就更新或者是删除，而是会有延时，这些操作最终会由purge线程来完成！等到没有事务引用其版本记录，那么就会删除这个版本，并且执行update操作**



### 事务的隔离级别

和ACID类似地，SQL标准定义的四个隔离级别为：

**读未提交（READ UNCOMMITTED）**

能够读取到其他事务的正在修改中的**未提交的结果**，称之为脏读；而且性能上说这个隔离级别也没有比后面的级别好多少，反而问题多多

**读已提交（READ COMMITTED）**

大多数数据库的默认隔离级别（MySQL不是），简单来说就是只能够读取到已经提交过的结果，但是在同一次事务中读取某个数据两次可能会得到两个不同的结果（假如其他事务同时对该数据提交了两次修改）；所以该级别也叫不可重复读（nonrepeatable read）

**可重复读（REPEATABLE READ)**

可重复读解决了脏读、多次读取不一致的问题，但在理论上，标准的可重复读没有能够解决幻读的问题，即某个事务在读取**范围内数据**的时候，另一个事务在这个范围又插了一条数据，原来的事务再次读取这个范围就会读取到**幻行**，导致上下文不一致；而MySQL的InnoDB通过多版本**并发控制（MVCC）**解决了这个问题

**串行化（SERIALIZABLE）**

最高级别，强制事务串行执行，避免前面的各种问题，简单说就是在读取的每行上都加了共享锁，所以这个隔离级别的性能会比较低；

------

下面我们来说一些**细节**

#### 效率问题

隔离级别越低，事务请求的锁就越少或者保持锁的时间就越短，但是随着技术的不断改进，可以有很多机制来辅助隔离级别的行为，于是各个隔离级别之间的性能差异越来越小，甚至没有区别

#### 实现问题

对于**InnoDB**，由于其提供了MVCC而解决了**不可重复读、幻读等问题，同时还提高了并发性能**；所以在其REPEATABLE READ（可重复读）级别下也能完整地支持事务ACID，于是其默认的级别也就是这个；

对于其他引擎，甚至是其他数据库，都不一定会支持所有隔离级别，也不会严格按照标准实现



