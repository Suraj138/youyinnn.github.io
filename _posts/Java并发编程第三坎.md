---
title: Java并发编程第三坎
categories:
  - java
  - concurrency
  - 《艺术》与《技术》
comments: true
tags:
  - java
  - thread
  - CAS
date: 2018-7-18 14:15:22
series: 并发
---



### 前言

前两篇基本说了线程的基本概念和基本使用，这回说说Java并发编程第三坎，关于锁的好多基本概念的提前了解

在讲锁之前，我们还需要介绍一个很重要的原理——CAS（Compare And Swap）操作，这个操作是保证并发过程中每个操作具有**“原子性”**的利器

- **关键概念说明：**临界区、排他锁、共享式锁、Java对象头
- **什么是CAS操作：**原子性、CAS

暂时只有这些概念，如果有什么提前概念我会继续补充

-------

### 关键概念说明

#### 临界区

在操作系统的解释上，临界区代表的是**“不允许多个进程访问的资源叫临界资源，而访问临界资源的代码段叫临界区”**

而在这里，我们可以笼统地说：**锁包括的范围就是临界区，临界区的资源需要保证内存可见性，需要对所有线程任何时刻都保持一致性**

#### 排他锁

也就是独占式锁，一旦一个线程获取到了这个锁而单独进入临界区，其他线程在拿锁线程没放锁之前只能在锁外阻塞。

#### 共享式锁

所谓共享式锁就是，可以有多个线程同时获取到锁而共同进入临界区，一般这部分线程都有着共同的特性，而没有这些特性的其他线程则在锁外阻塞，需要保证的是持有锁的这些线程对临界区的操作要同步，也就是说要么这些线程只能读，这些一般这个时候临界区就失去了临界区的意义，要么这些线程在临界区内进行的写操作之间也要保持同步，但是这没有太大的意义

举个例子，读者/写者模式中，同一篇文章允许多个读者同时读，新写者阻塞直到没有读者读（看似好像和实际遇到的读写者模式不大一样），对于读者之间来说，这就是**共享式锁**，但是同一时刻只能有一个写者写，新的写者和新的读者只能阻塞，对于写者之间来说，这就是**独占式锁**

在上面的例子中，读者线程之间共性就是只能读取临界资源，同一时刻只存在读取操作的话，不会造成内存可见性问题，所以读者线程可以共享（关于什么是**内存可见性问题**，在内存模型的部分会讲解到，这里就简单理解为**脏读问题**）

对于例子中读者可以阻塞写者的说法，有的人可能想不通，我们投入到场景中去看：

> - Github上有一篇issue，你可以看到，这算是**“读a”**
> - 你可以编辑，这算是**“写a”**
> - 但实际上的临界资源是存放在Github服务器上的，这里才真正运用到了**读写者模式**，我们刷一个issue页的时候，首先请求到服务端，服务端对临界资源进行**“读b”**操作
> - 在无阻塞的情况下，**“读b”**操作把读出的临界资源issue内容，复制了一份，响应给请求方浏览器，所以我们在浏览器上读取到的资源，并不是临界资源，而是临界资源在**“读b”**操作中复制出来的副本而已
> - 所以**“读a”**操作其实读的是副本内容并不存在临界资源的抢夺
> - 同理， 我们**“写a”**也是对副本进行写操作，然后把写好的内容发送给服务端，由服务端对临界资源进行**“写b”**操作，这时如果有其他的**“读b”**操作，**“写b”**会阻塞

#### Java对象头

用于存储Java对象的一些控制信息，在并发的过程中，锁的记录会经常性地和对象头中的一些标志位打交道，特别是在使用synchronized关键字的时候，具体的位置是放在对象头的**Mark Word**内容当中

所以对于Java来说，synchronized用的锁是存在**Java对象头**里的，这部分就不细说了

### CAS操作

##### 什么是CAS

CAS即**Compare And Swap**，比较并交换，它的思想是输入两个值，一个旧值（期望的操作前的值）和一个替换旧值的新值，在操作期间先比较旧值和新值，看是否发生了变化，如果**没有变化**才将旧值换成新值，如果发生了变化则不替换

##### 什么是原子性

原子（atomic）的本意是“不能被分割的最小粒子”，而原子操作就是“不可被中断的一个或者一系列操作”，但是在多处理器中实现原子操作是有点困难的

##### 处理器如何实现原子操作

- **处理器会自动保证：**对内存的操作是原子的，则当一个处理器处理一个字节的时候，其他处理器不能访问这个字节的内存地址
- **锁总线：**当一个处理器要操作一个共享变量的时候，会发出一个LOCK #信号，其他处理器对该变量的操作会阻塞
- **锁缓存：**参考缓存一致性

##### Java中的CAS

Java SE1.5开始，JDK并发包就提供了一些原子操作的更新器，比如`AtomicBoolean`、`AtomicInteger`、`AtomicLong`等，这些原子包装类还提供了原子的自增自减等方法

##### CAS的三大问题

1. **ABA问题：**如果一个值原来是A，变成了B，然后又变回了A，实际上有变化，但是CAS是检测不到变化的，要解决这个问题，可以在变量前面追加版本号，每次变化则版本号加1，在我看来这可以说是双重CAS，一个只负责给版本号加一，一个复杂监控整个变量值的变化，这样就变成了：1A-2B-3A
2. **自旋消耗：**使用CAS一般是搭配上**自旋（即死循环）**来使用，如果长时间自旋CAS成功，则会大量消耗CPU，这个问题并不好解决
3. **只能保证一个变量的原子值：**如果要对多个变量同时保证原子操作，有两种方式，一种是将多个变量聚合成一个变量，第二个是通过锁操作

##### CAS和Java中锁的关系

JVM中实现了许多锁机制，但是除了偏向锁，其他锁的实现方式几乎都用了循环CAS，**即当一个线程要进入同步块的时候，使用循环CAS的方式来获取锁，当它要退出锁的时候，使用循环CAS来释放锁**

-------

坐骑已经找到了，皮皮猪，我们走！