
    sessionStorage.setItem('pseries', "- se: 《计算机网络》\n  ps:\n    - 计算机网络-谢希仁-2.html\n    - 计算机网络-谢希仁-1.html\n- se: JVM\n  ps:\n    - 关于JVM的运行时数据区上的GC.html\n    - 关于JVM的运行时数据区.html\n    - 关于JVM的对象创建与访问.html\n    - 关于JVM的GC行为和内存分配.html\n- se: 从头到尾读\n  ps:\n    - 把HashMap安排得明明白白.html\n    - 从头到尾读Iterable与Iterator.html\n    - 从头到尾读Collection.html\n    - 从头到尾读ArrayList.html\n- se: 《Mastering Regular Expression(Third Edition)》\n  ps:\n    - RegExp_2_metacharacters.html\n    - RegExp_1_overview.html\n- se: Log4j2\n  ps:\n    - Log4j2_Lookups.html\n    - Log4j2_Layouts.html\n    - Log4j2_HelloWorld.html\n    - Log4j2_Filters.html\n    - Log4j2_Appenders.html\n- se: leetcode\n  ps:\n    - Leetcode-71~75.html\n    - Leetcode-6~10.html\n    - Leetcode-66~70.html\n    - Leetcode-61~65.html\n    - Leetcode-56~60.html\n    - Leetcode-51~55.html\n    - Leetcode-46~50.html\n    - Leetcode-41~45.html\n    - Leetcode-36~40.html\n    - Leetcode-31~35.html\n    - Leetcode-26~30.html\n    - Leetcode-21~25.html\n    - Leetcode-1~5.html\n    - Leetcode-16~20.html\n    - Leetcode-11~15.html\n- se: JettyDocument_ZH_CN_Translation\n  ps:\n    - JettyDocument_ZH_CN_Translation_README.html\n    - JettyDocument_ZH_CN_Translation_Part4-23.html\n    - JettyDocument_ZH_CN_Translation_Part4-21.html\n    - JettyDocument_ZH_CN_Translation_Part3-13.html\n    - JettyDocument_ZH_CN_Translation_Part1.html\n- se: jenkins\n  ps:\n    - Jenkins Introductions&Setup.html\n- se: 并发\n  ps:\n    - Java并发编程第四坎.html\n    - Java并发编程第六坎.html\n    - Java并发编程第八坎.html\n    - Java并发编程第五坎.html\n    - Java并发编程第二坎.html\n    - Java并发编程第三坎.html\n    - Java并发编程第七坎.html\n    - Java并发编程第七坎-2.html\n    - Java并发编程第一坎.html\n- se: express\n  ps:\n    - Express Routing.html\n    - Express Middleware.html\n- se: electron\n  ps:\n    - Electron_配置相关与对象.html\n    - Electron_打包你的HelloWorld为exe.html\n    - Electron_上手铺垫.html\n    - Electron_一个HelloWorld.html\n    - Electron_UI.html\n- se: docker\n  ps:\n    - Docker Volumes.html\n    - Docker Swarm&ClusterSetup.html\n    - Docker Stack.html\n    - Docker Service&Composefile.html\n    - Docker Persist Data Overview.html\n    - Docker Orientation&Setup.html\n    - Docker Containers&Dockerfile.html\n    - Docker ConceptReview.html\n- se: Cron4jDocument_ZH_CN_Translation\n  ps:\n    - Cron4jDocument_ZH_CN_Translation_README.html\n    - Cron4jDocument_ZH_CN_Translation.html\n");

    sessionStorage.setItem('pcbl', "- abbrlink: 1h187i6\n  title: 5 Useful Tips For A Better Commit Message\n  categories:\n    - reprinted\n  comments: true\n  tags:\n    - tips\n    - github\n    - git\n  date: 2017-11-15T16:59:00.000Z\n  char_count: 3731\n  short_contant: \"\\r\\n\\r\\nYou’re already writing decent commit messages. Let’s see if we can level you up to awesome. Other developers, especially you-in-two-weeks and you-from-next-year, will thank you for your forethought and verbosity when they run git blame to see why that conditional is there.\\r\\n\\r\\n<!-- more -->\\r\\n\\r\\n1. The first line should always be <u>50 characters</u> or less and that it should be followed by a blank line. Vim ships with syntax, indent, and filetype plugins for Git commits which can help here.\\r\\n\\r\\n1. Add this line to your `~/.vimrc` to add spell checking and automatic wrapping at the recommended 72 columns to you commit messages.\\r\\n\\r\\n      ``` vim\\r\\n      autocmd Filetype gitcommit setlocal spell textwidth=72\\r\\n      ```\\r\\n1. Never use the `-m <msg>` / `--message=<msg>` flag to `git commit`.\\r\\n\\r\\n    It gives you a poor mindset right off the bat as you will feel that you have to fit your commit message into the terminal command, and makes the commit feel more like a one-off argument than a page in history:\\r\\n\\r\\n      ``` bash\\r\\n      git commit -m \\\"Fix login bug\\\"\\r\\n      ```\\r\\n    A more useful commit message might be:\\r\\n\\r\\n    ``` vim\\r\\n    Redirect user to the requested page after login\\r\\n\\r\\n\"\n- abbrlink: wji6g0\n  title: AVL树和红黑树\n  categories:\n    - note\n    - datastruct\n  comments: true\n  date: 2018-08-27T15:05:00.000Z\n  tags:\n    - BST\n    - AVL\n    - RBT\n    - algorithm\n    - tree\n  char_count: 8943\n  short_contant: \"\\r\\n\\r\\n### 小声BB\\r\\n\\r\\n本篇尽量不po代码，仅仅过一遍AVL树和红黑树\\r\\n\\r\\n其中红黑树更是在HashMap中大展身手，肯定要研究一下为什么他们要用到RBT\\r\\n\\r\\n--------------\\r\\n\\r\\n### AVL\\r\\n\\r\\n了解AVL之前，我们先BB一句二叉搜索树（Binary Search Tree，BST），BST有什么性质？\\r\\n\\r\\n曰：**二叉结构，元素可比，左小右大，仅此而已**\\r\\n\\r\\n然后再BB一句为什么有了BST之后，又要研究AVL树：在极端的情况下，一组大小有序的数据插入BST，那么就会生成一条线而不是一棵树，这样对于树的操作就完全退化成链表操作，举例说查找操作从二分法的效率变成了顺序查找\\r\\n\\r\\n大部分时候我们使用一棵树，更重要的是要用到他的查找操作，而不是插入或者删除操作\\r\\n\\r\\n于是为了防止一棵树会变成一条线，于是就有了平衡二叉树，也就是AVL树\\r\\n\\r\\n下面引自[GeekforKGeek的《AVL Tree | Set 1 (Insertion)》一文](https://www.geeksforgeeks.org/avl-tree-set-1-insertion/)\\r\\n\\r\\n> **Why AVL Trees?** Most of the BST operations (e.g., search, max, min, insert, delete.. etc) take O(h) time where h is the height of the BST. The cost of these operations may become O(n) for a skewed Binary tree. If we make sure that height of the tree remains O(Logn) after every insertion and deletion, then we can guarantee an upper bound of O(Logn) for all these operations. The height of an AVL tree is always O(Logn) where n is the number of nodes in the tree (See [this ](http://www.youtube.com/watch?v=TbvhGcf6UJU)video lecture for proof).\\r\\n\"\n- abbrlink: 1ox3j6i\n  title: CentOS7下安装Pillow并使用osm-bundler生成图点模型\n  categories:\n    - note\n    - project\n    - 17y-CollagesStudent-Creative-Project\n  comments: true\n  tags:\n    - centos7\n    - python\n    - Pillow\n    - osm-bundler\n    - pip\n  date: 2018-01-21T11:50:30.000Z\n  char_count: 5699\n  short_contant: \"\\r\\n\\r\\n{% cq %}\\r\\n前言：之前留下的17大创项目总得做点什么，马上就要结题了，我们做的AR留影需要将用户照下来的照片生成点云然后合成模型。由此Escnqh[link:gayhub]找到了使用PIL+osm-bundler的解决方案。\\r\\n{% endcq %}\\r\\n\\r\\n<!-- more -->\\r\\n\\r\\n### Python Photogrammetry ToolKit（PPT）\\r\\n\\r\\n这玩意是意大利的一个团队开发的一个Python图像处理工具包，正是这个工具包提供的osm-bundler加上PIL构成了一套解决方案。\\r\\n\\r\\n官网：http://184.106.205.13/arcteam/ppt.php\\r\\n\\r\\n#### PIL\\r\\n> The Python Imaging Library (PIL) adds image processing capabilities to your Python interpreter. This library supports many file formats, and provides powerful image processing and graphics capabilities.\\r\\n\\r\\n简单来说就是Python的图像处理库，osm-bundler基于这个库对图像进行分析。\\r\\n\\r\\n官网：http://www.pythonware.com/products/pil/\\r\\n\\r\\n但是很坑的一点是，这个项目09年就停止维护了，所以安装这个东西异常困难。\\r\\n\\r\\n#### Pillow\\r\\n\\r\\n\"\n- abbrlink: vywf17\n  title: CLH Lock Queue\n  categories:\n    - note\n    - datastruct\n  tags:\n    - algorithm\n    - CLH-Lock-Queue\n  date: 2018-12-30T16:35:00.000Z\n  char_count: 4850\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n在学习Java并发中的同步器源码的时候，注释中有提到过AQS的Node结构是参考CLH的一种变体：\\r\\n\\r\\n> The wait queue is a variant of a \\\"CLH\\\" (Craig, Landin, and Hagersten) lock queue. \\r\\n>\\r\\n> CLH locks are normally used for spinlocks.  We instead use them for blocking synchronizers, but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node.  A \\\"status\\\" field in each node keeps track of whether a thread should block.  \\r\\n>\\r\\n> A node is signalled when its predecessor releases.  Each node of the queue otherwise serves as a specific-notification-style monitor holding a single waiting thread. The status field does NOT control whether threads are granted locks etc though.  \\r\\n>\\r\\n> A thread may try to acquire if it is first in the queue. But being first does not guarantee success; it only gives the right to contend.  So the currently released contender thread may need to rewait.\\r\\n>\\r\\n> **To enqueue into a CLH lock, you atomically splice it in as new tail.** \\r\\n>\\r\\n> **To dequeue, you just set the head field.**\\r\\n>\\r\\n>  <pre class=\\\"nhi\\\">\\r\\n>       +------+  prev +-----+       +-----+\\r\\n>  head |      | &lt;---- |     | &lt;---- |     |  tail\\r\\n>       +------+       +-----+       +-----+\\r\\n>  </pre>\\r\\n\"\n- abbrlink: 1ngl1pm\n  title: Cron4jDocument_ZH_CN_Translation\n  categories:\n    - translation\n  tags:\n    - cron4j\n    - scheduler\n  series: Cron4jDocument_ZH_CN_Translation\n  date: 2018-05-07T17:25:01.000Z\n  char_count: 20010\n  short_contant: \"\\r\\n\\r\\n# Cron4j\\r\\n \\r\\n一些必要的单词解释：\\r\\n1. schedule 安排、调度（安排在有主语的时候使用 调用在没主语的时候使用）\\r\\n2. scheduler 调度器\\r\\n3. scheduling pattern 调度模式\\r\\n4. reschedule 重新调度、安排\\r\\n5. action/task 动作/任务\\r\\n6. deschedule 脱离调度、安排\\r\\n7. Daemon threads 守护线程 （其实daemon本意就有守护进程的意思 加个threads应该是强调线程而非进程）\\r\\n8. Predictor 先知（故意翻译为这个中二的名字哈哈）、预报器（这才是常规翻译）\\r\\n9. Crontab/Cron 定时任务工具\\r\\n10. status tracking 状态跟踪\\r\\n11. executor 执行器\\r\\n12. collector 收集器\\r\\n- - -\\r\\n\\r\\n<span id=\\\"1快速开始\\\"></span>\\r\\n### 1、快速开始：\\r\\ncron4j的主要实体是‘scheduler’，实例化`it.sauronsoftware.cron4j.Scheduler`之后，你可以在一年当中任意的时间段执行任意的任务（Task）。\\r\\n\\r\\n要使用cron4j scheduler 你需要做下面四步：\\r\\n1. new一个Scheduler实例\\r\\n\"\n- abbrlink: 19jo7o1\n  title: Cron4jDocument_ZH_CN_Translation_README\n  categories:\n    - translation\n  tags:\n    - cron4j\n    - scheduler\n    - readme\n  series: Cron4jDocument_ZH_CN_Translation\n  date: 2018-05-07T17:12:01.000Z\n  char_count: 2426\n  short_contant: \"\\r\\n\\r\\n# Cron4j : A pure Java cron-like scheduler\\r\\n创立时间：2017年8月20日13:35:01\\r\\n\\r\\n官方文档地址：http://www.sauronsoftware.it/projects/cron4j/\\r\\n- - -\\r\\nMaven依赖：\\r\\n```\\r\\n<dependency>\\r\\n    <groupId>it.sauronsoftware.cron4j</groupId>\\r\\n    <artifactId>cron4j</artifactId>\\r\\n    <version>2.2.5</version>\\r\\n</dependency>\\r\\n```\\r\\n- - -\\r\\n#### 前言：\\r\\n> 这是一篇针对cron4j官方英文文档的翻译。\\r\\n>\\r\\n> 虽然官方文档并不难看懂，但是本着高尚的自学精神，再加上暑假有点无聊，我尝试着翻译这篇Java工具包的技术文档。\\r\\n>\\r\\n> 该翻译并不是来自官方的，仅仅是自学用的翻译，如有翻译错误，请在issue中指出。\\r\\n>\\r\\n> 本人并仅仅英语四级压线水平，所以文档并没有严格按照语法规范翻译，首先遵从本人自己的理解（如有理解错误也请在issue中指出），再尽量翻译成通俗的语句，要求的是能根据本文快速掌握cron4j工具。一切以实践为标准，我在学习的时候也会先实践，再结合实践翻译到文档中。\\r\\n>\\r\\n\"\n- abbrlink: rx7jt4\n  title: Docker ConceptReview\n  categories:\n    - note\n    - docker\n  tags:\n    - docker\n  date: 2018-12-02T12:39:09.000Z\n  series: docker\n  char_count: 7764\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\nIn this section, we will go through all the main concepts of docker technologies such as : **Docker Engine**, **Docker Architecture**, **Docker underlying technology**.\\r\\n\\r\\nBasically reprinted from: https://docs.docker.com/engine/docker-overview, but I will make some adjustment for better understanding.\\r\\n\\r\\n### Docker Engine\\r\\n\\r\\n*Docker Engine* is a client-server application with these major components:\\r\\n\\r\\n- A server which is a type of long-running program called a daemon process (the `dockerd` command).\\r\\n- A REST API which specifies interfaces that programs can use to talk to the daemon and instruct it what to do.\\r\\n- A command line interface (CLI) client (the `docker` command).\\r\\n\\r\\n\\r\\n\\r\\nThe CLI uses the Docker REST API to control or interact with the Docker daemon through scripting or direct CLI commands. Many other Docker applications use the underlying API and CLI.\\r\\n\\r\\nThe daemon creates and manages Docker *objects*, such as images, containers, networks, and volumes.\\r\\n\\r\\n### Docker architecture\\r\\n\"\n- abbrlink: uh480l\n  title: Docker Containers&Dockerfile\n  categories:\n    - note\n    - docker\n  tags:\n    - docker\n  date: 2018-11-16T15:05:11.000Z\n  series: docker\n  char_count: 9321\n  short_contant: \"\\r\\n\\r\\n### Introduction\\r\\n\\r\\n本篇主要介绍Docker里面Containers的概念，以及它的定义\\r\\n\\r\\n还有就是如何分享你创建的Containers到hub上面\\r\\n\\r\\n需要注意的是，containers的定义其实就是image的定义\\r\\n\\r\\n以及说到了docker run了两个option`-p`和`-d`\\r\\n\\r\\n### Define a container with Dockerfile\\r\\n\\r\\n`Dockerfile` defines what goes on in the environment inside your container. Access to resources like networking interfaces and disk drives is virtualized inside this environment, which is isolated from the rest of your system, so you need to map ports to the outside world, and be specific about what files you want to “copy in” to that environment. However, after doing that, you can expect that the build of your app defined in this `Dockerfile` behaves exactly the same wherever it runs.\\r\\n\\r\\n#### Dockerfile\\r\\n\\r\\nCreate an empty directory. Change directories (`cd`) into the new directory, create a file called `Dockerfile`, copy-and-paste the following content into that file, and save it. Take note of the comments that explain each statement in your new Dockerfile.\\r\\n\\r\\n```dockerfile\\r\\n# Use an official Python runtime as a parent image\\r\\nFROM python:2.7-slim\\r\\n\\r\\n# Set the working directory to /app\\r\\n```\\n\"\n- abbrlink: 1ei198o\n  title: Docker Orientation&Setup\n  categories:\n    - note\n    - docker\n  tags:\n    - docker\n  date: 2018-11-14T13:50:11.000Z\n  series: docker\n  char_count: 7722\n  short_contant: \"\\r\\n\\r\\n### Docker concepts\\r\\n\\r\\nDocker is a platform for developers and sysadmins to **develop, deploy, and run** applications with containers. The use of Linux containers to deploy applications is called *containerization*. Containers are not new, but their use for easily deploying applications is.\\r\\n\\r\\nContainerization is increasingly popular because containers are:\\r\\n\\r\\n- Flexible: Even the most complex applications can be containerized.\\r\\n- Lightweight: Containers leverage and share the host kernel.\\r\\n- Interchangeable: You can deploy updates and upgrades on-the-fly.\\r\\n- Portable: You can build locally, deploy to the cloud, and run anywhere.\\r\\n- Scalable: You can increase and automatically distribute container replicas.\\r\\n- Stackable: You can stack services vertically and on-the-fly.\\r\\n\\r\\n> 优点巨多，这也是为什么开发中vm被container技术迅速淘汰的原因\\r\\n\\r\\n\\r\\n\\r\\n#### Images and containers\\r\\n\\r\\nA container is launched by running an image. An **image** is an executable package that includes everything needed to run an application--the code, a runtime, libraries, environment variables, and configuration files.\\r\\n\\r\\nA **container** is a runtime instance of an image--what the image becomes in memory when executed (that is, an image with state, or a user process). You can see a list of your running containers with the command, `docker ps`, just as you would in Linux.\\r\\n\\r\\n\"\n- abbrlink: lt42s8\n  title: Docker Persist Data Overview\n  categories:\n    - note\n    - docker\n  tags:\n    - docker\n    - volume\n  date: 2018-12-04T09:44:33.000Z\n  series: docker\n  char_count: 7375\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\nBy default all files created inside a container are stored on a writable container layer.\\r\\n\\r\\nThat means that the data doesn't persist when that container no longer exists, and it can be difficult to get the data out of the container if another process needs it.\\r\\n\\r\\nAnd here's you should know: a container's writable layer is tightly coupled to the host machine where the container is running. So **you can't easily move the data somewhere else**.\\r\\n\\r\\nDocker has two options for containers to store files in the host machine, so that the files are persisted even after the container stops: \\r\\n\\r\\n- *volumes*\\r\\n- *bind mounts*\\r\\n\\r\\nIf you’re running Docker on Linux you can also use a *tmpfs mount*.\\r\\n\\r\\n### Choose the right type of mount\\r\\n\\r\\nNo matter which type of mount you choose to use, the data looks the same from within the container. It is exposed as either a directory or an individual file in the container’s filesystem.\\r\\n\\r\\nAn easy way to visualize the difference among volumes, bind mounts, and `tmpfs` mounts is to think about where the data lives on the Docker host.\\r\\n\\r\\n\"\n- abbrlink: zkr55u\n  title: Docker Service&Composefile\n  categories:\n    - note\n    - docker\n  tags:\n    - docker\n    - compose-file\n  date: 2018-11-27T12:19:02.000Z\n  series: docker\n  char_count: 6011\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Service\\r\\n\\r\\nIn a distributed application, different pieces of the app are called “services.” For example, if you imagine a video sharing site, it probably includes **[1]a service for storing application data in a database**, **[2]a service for video transcoding in the background after a user uploads something**, **[3]a service for the front-end**, and so on.\\r\\n\\r\\nServices are really just “containers in production.” A service only runs one image, but it codifies the way that image runs:\\r\\n\\r\\n- what ports it should use\\r\\n- how many replicas of the container should run so the service has the capacity it needs\\r\\n- scaling a service changes the number of container instances running that piece of software\\r\\n- assigning more computing resources to the service in the process\\r\\n- ....\\r\\n\\r\\nLuckily it’s very easy to **define**, run, and scale services with the Docker platform -- just write a `docker-compose.yml` file\\r\\n\\r\\nA `docker-compose.yml` file is a YAML file that defines how Docker containers should behave in production.\\r\\n\\r\\n> image或者说container只是一个app的运行环境，通常来说在完整系统里面我们不止要用到1个app，这也是微服务的架构，而每个app有各自的环境资源和部署策略\\r\\n>\\r\\n> 我们这样去看待：\\r\\n>\\r\\n> - app是面向业务，而提供解决方案的\\r\\n\"\n- abbrlink: u7sd0w\n  title: Docker Stack\n  categories:\n    - note\n    - docker\n  tags:\n    - docker\n  date: 2018-11-29T16:46:00.000Z\n  series: docker\n  char_count: 6536\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\nAt the part of \\\"Container\\\", we've know we can define a `docker-compose.yaml` to deploy a service on our swarm so it can run on multiple machine.\\r\\n\\r\\nAs we practice before, our service just contains one container: a python app that provide web service with Flask.\\r\\n\\r\\nBut did you remember that sentence ? **Services are really just \\\"Containers in Production\\\"**\\r\\n\\r\\nSo we can define multiple containers in one service !!! Sounds nice isn't it ?\\r\\n\\r\\nThis is what they call **\\\"a Stack\\\"**, and that sounds very confused.\\r\\n\\r\\n### Stack\\r\\n\\r\\nA stack is a group of interrelated services that share dependencies, and can be orchestrated and scaled together. \\r\\n\\r\\nA single stack is capable of defining and coordinating the functionality of an entire application (though very complex applications may want to use multiple stacks).\\r\\n\\r\\nWe've been technically work with stack while we deploy a Composefile with `docker stack deploy`. But that was a single service stack running on a single host, which is not usually what takes place in production. Here, you can take what you’ve learned, make multiple services relate to each other, and run them on multiple machines.\\r\\n\\r\\n> Now we should build up a main concept for this:\\r\\n\"\n- abbrlink: 1toixsk\n  title: Docker Swarm&ClusterSetup\n  categories:\n    - note\n    - docker\n  tags:\n    - docker\n    - cluster\n    - swarm\n  date: 2018-11-28T21:06:03.000Z\n  series: docker\n  char_count: 11234\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\nIn the last post, we discussed the relationship between Application and Service. \\r\\n\\r\\nSo they say: **Services are really just \\\"Containers in Production\\\".**\\r\\n\\r\\nAnd when we deploy a service, we use `docker swarm init` to prepare for it.\\r\\n\\r\\nNow let's learn what is swarm and how to setup a cluster with **docker-machine**.\\r\\n\\r\\n### Swarm\\r\\n\\r\\n**A swarm is a group of machines that are running Docker and joined into a cluster.**\\r\\n\\r\\nAfter that has happened, you continue to run the Docker commands you’re used to, but now they are executed on a cluster by a **swarm manager**. The machines in a swarm can be **physical or virtual**. After joining a swarm, they are referred to as **nodes**.\\r\\n\\r\\nSwarm managers can use several **strategies** to run containers, such as :\\r\\n\\r\\n- “emptiest node” \\r\\n\\r\\n    which fills the least utilized machines with containers.\\r\\n\"\n- abbrlink: 1ae6lng\n  title: Docker Volumes\n  categories:\n    - note\n    - docker\n  tags:\n    - docker\n    - volume\n  date: 2018-12-05T10:23:09.000Z\n  series: docker\n  char_count: 8632\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n> **Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.** While [bind mounts](https://docs.docker.com/storage/bind-mounts/) are dependent on the directory structure of the host machine, **volumes are completely managed by Docker**. Volumes have several advantages over bind mounts:\\r\\n>\\r\\n> - Volumes are easier to back up or migrate than bind mounts.\\r\\n> - You can manage volumes using Docker CLI commands or the Docker API.\\r\\n> - Volumes work on both Linux and Windows containers.\\r\\n> - Volumes can be more safely shared among multiple containers.\\r\\n> - Volume drivers let you store volumes on remote hosts or cloud providers, to encrypt the contents of volumes, or to add other functionality.\\r\\n> - New volumes can have their content pre-populated by a container.\\r\\n>\\r\\n> In addition, volumes are often a better choice than persisting data in a container’s writable layer, because a volume does not increase the size of the containers using it, and the volume’s contents exist outside the lifecycle of a given container.\\r\\n>\\r\\n> \\r\\n>\\r\\n> If your container generates non-persistent state data, consider using a [tmpfs mount](https://docs.docker.com/storage/tmpfs/) to avoid storing the data anywhere permanently, and to increase the container’s performance by avoiding writing into the container’s writable layer.\\r\\n>\\r\\n> Volumes use `rprivate` bind propagation, and bind propagation is not configurable for volumes.\\r\\n\\r\\n### Use volumes with `-v` and `--mount` flag\\r\\n\\r\\n\"\n- abbrlink: 1flo1c0\n  title: DP Again\n  categories:\n    - note\n    - algorithm\n  tags:\n    - dp\n  date: 2019-03-22T06:14:00.000Z\n  char_count: 14213\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n我们先分析Leetcode的55题，是从45题Jump Game II 跳过来的，因为这题比II要简单一点，只需要判断序列是否能jump到终点就行，而45题是要找最小的jump次数；\\r\\n\\r\\n为什么这题要拿出篇幅来分析？因为这题包含了很多东西： \\r\\n\\r\\n- **纯回溯**\\r\\n- **纯回溯`--->`回溯Top-down DP**\\r\\n- **回溯Top-Down DP`--->`迭代Bottom-up DP**\\r\\n- **迭代Bottom-up DP`--->`线性贪婪**\\r\\n\\r\\n分析完之后你会发现，原来算法可以这么美妙\\U0001F603\\r\\n\\r\\n### Jump Game\\r\\n\\r\\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\\r\\n\\r\\nEach element in the array represents your maximum jump length at that position.\\r\\n\\r\\n**Determine if you are able to reach the last index.**\\r\\n\\r\\n\"\n- abbrlink: kimeni\n  title: Electron_UI\n  categories:\n    - note\n    - electron\n  comments: true\n  tags:\n    - electron\n  series: electron\n  date: 2019-10-10T11:44:21.000Z\n  char_count: 6890\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 对话框\\r\\n\\r\\n> 显示用于打开和保存文件、警报等的本机系统对话框。\\r\\n\\r\\n线程：[主线程](https://electronjs.org/docs/glossary#main-process)\\r\\n\\r\\n显示用于选择多个文件和目录的对话框的示例:\\r\\n\\r\\n```javascript\\r\\nconst { dialog } = require('electron')\\r\\nconsole.log(dialog.showOpenDialog({ properties: ['openFile', 'openDirectory', 'multiSelections'] }))Copy\\r\\n```\\r\\n\\r\\n这个对话框是从Electron的主线程上打开的。如果要使用渲染器进程中的对话框对象, 可以使用remote来获得:\\r\\n\\r\\n```javascript\\r\\nconst { dialog } = require('electron').remote\\r\\nconsole.log(dialog)\\r\\n```\\r\\n\\r\\n对话框的API大致分为：\\r\\n\"\n- abbrlink: a08lib\n  title: Electron_一个HelloWorld\n  categories:\n    - note\n    - electron\n  comments: true\n  tags:\n    - electron\n    - helloworld\n  series: electron\n  date: 2017-11-22T22:05:23.000Z\n  char_count: 4949\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n{% cq %}\\r\\n\\r\\n惊！仅用前端技术就可以打造跨平台桌面应用！\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n\\r\\n\\r\\n### 快速入门\\r\\n- - -\\r\\n\\r\\n简单介绍一下什么是Electron：\\r\\n\\r\\n> 如果你只会前端技术，如果你想打造一个桌面应用，如果你不想学C#、Swing之类的技术，那么Electron绝对是你的不二之选。\\r\\n>\\r\\n> 它的本质就是提供一个轻巧的chrome内核（其实也有131M），把你的项目包在里面运行，等于是你项目的专属浏览器！\\r\\n>\\r\\n> 为什么想要使用这门技术，首先非常有趣，其次我只是个半吊子的前端选手，写项目完全不存在浏览器兼容性考虑这回事（我觉得兼容考虑就是前端开发届的一大毒瘤之一），我写的项目全部基于Chrome的V8，IE什么的傻逼浏览器我是不会去管的。因此你如果想要使用我的项目，要么使用Chrome，要么使用我项目打包成的桌面应用咯- -\\r\\n\\r\\n然后这篇基本就算官网[快速入门](https://electronjs.org/docs/tutorial/quick-start)的照搬\\r\\n\\r\\n\"\n- abbrlink: 11zuc81\n  title: Electron_上手铺垫\n  categories:\n    - note\n    - electron\n  comments: true\n  tags:\n    - electron\n  series: electron\n  date: 2019-10-03T22:35:21.000Z\n  char_count: 7548\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n## Introduction\\r\\n\\r\\n官方指南不叫指南，叫document，于是乎开始无教程纯瞎子摸石头，于是想着把整个官方指南都看一遍，然后梳理梳理。\\r\\n\\r\\n- 关于electron的命名空间\\r\\n- 主进程和渲染进程\\r\\n  - 区别\\r\\n  - 通信方式\\r\\n- 添加功能\\r\\n  - 通知\\r\\n  - 任务栏进度bar\\r\\n  - 其他\\r\\n\\r\\n\\r\\n\\r\\n## Electron Namespace\\r\\n\\r\\n`electron` 模块所提供的功能都是通过命名空间暴露出来的。 比如说： `electron.app`负责管理Electron 应用程序的生命周期， `electron.BrowserWindow`类负责创建窗口。\\r\\n\\r\\n从0.37开始，可以使用 [destructuring assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) (es6解构赋值)来使内置模块更容易使用。\\r\\n\\r\\n\"\n- abbrlink: 1q1lo3l\n  title: Electron_打包你的HelloWorld为exe\n  categories:\n    - note\n    - electron\n  comments: true\n  tags:\n    - electron\n    - helloworld\n  series: electron\n  date: 2017-11-23T13:02:21.000Z\n  char_count: 5611\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n{% cq %}\\r\\n\\r\\nEXE什么的，看着就忍不住要双击它！\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n- - -\\r\\n\\r\\n首先介绍一下Electron打包应用的方式：\\r\\n- 打包成asar分发；这种方式弊端很多而且不好操作，[详情见](https://electronjs.org/docs/tutorial/application-packaging)。\\r\\n- 重构官网提供的二进制release，这种方式也比较麻烦。\\r\\n- 通过打包工具：\\r\\n  - [electron-forge](https://github.com/electron-userland/electron-forge)\\r\\n  - [electron-builder](https://github.com/electron-userland/electron-builder)\\r\\n  - [electron-packager](https://github.com/electron-userland/electron-packager)\\r\\n- 重编译源码二进制文件...\\r\\n\\r\\n用打包工具进行打包比较傻瓜式，两年前的时候，我用过packager，但是现在不知道为啥不好使了，老卡住，然后我转试builder。\\r\\n\"\n- abbrlink: 1y7ozg8\n  title: Electron_配置相关与对象\n  categories:\n    - note\n    - electron\n  comments: true\n  tags:\n    - electron\n  series: electron\n  date: 2019-10-10T09:03:21.000Z\n  char_count: 20338\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n有了一些铺垫之后，我们就能开始了解一下Electron的主体功能都提供了什么东西，具体的列表可以看：https://electronjs.org/docs/api\\r\\n\\r\\n- 配置相关与对象\\r\\n  - app：整个应用程序生命周期相关的api和事件\\r\\n  - BrowserView：创建和控制视图\\r\\n  - BrowserWindow：创建和控制浏览器窗口\\r\\n  - webContent：渲染以及控制 web 页面\\r\\n  - screen：检索有关屏幕大小、显示器、光标位置等的信息。\\r\\n  - session：管理浏览器会话、cookie、缓存、代理设置等。\\r\\n  - process：nodejs的process对象的扩展\\r\\n- UI\\r\\n  - 对话框\\r\\n  - 菜单\\r\\n  - 任务栏\\r\\n  - 托盘\\r\\n- 功能\\r\\n  - 快捷键/系统快捷键：\\r\\n  - 剪切板\\r\\n  - 操作文件\\r\\n\"\n- abbrlink: 1tzsbbu\n  title: Express Middleware\n  categories:\n    - note\n    - nodejs\n  tags:\n    - express\n    - nodejs\n  series: express\n  date: 2019-10-03T16:31:00.000Z\n  char_count: 2462\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n{% cq %}\\r\\n\\r\\n翻译自官方文档\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n## Writing Middleware\\r\\n\\r\\n中间件能够在请求响应周期中访问 [request object](http://www.expressjs.com.cn/en/4x/api.html#req) (`req`)，和 [response object](http://www.expressjs.com.cn/en/4x/api.html#res) (`res`)，以及 `next`方法。`next`方法用于在路由过程中执行当前中间件紧接着的下一个中间件。\\r\\n\\r\\n中间件能够完成以下事情：\\r\\n\\r\\n- Execute any code.\\r\\n- Make changes to the request and the response objects.\\r\\n- End the request-response cycle.\\r\\n- Call the next middleware in the stack.\\r\\n\\r\\n如果当前中间件不结束该次请求响应周期，它必须调用next方法，将控制传递到下一个中间件，否则请求会被挂起。\\r\\n\\r\\n下图展示了中间件功能的基本元素：\\r\\n\\r\\n\"\n- abbrlink: 1n8vn13\n  title: Express Routing\n  categories:\n    - note\n    - nodejs\n  tags:\n    - express\n    - nodejs\n  series: express\n  date: 2019-10-03T13:38:00.000Z\n  char_count: 9044\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n{% cq %}\\r\\n\\r\\n翻译自官方文档\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n##  Routing\\r\\n\\r\\n**Routing（路由）**指的是一个应用服务器的endpoints（URLs）怎么去响应客户端的请求。\\r\\n\\r\\n你可以通过使用Express的`app`对象中和HTTP请求名称对应的方法去定义应用的路由行为；比如，`app.get()`方法用于处理GET请求或者使用`app.post()`方法去处理POST请求。完整的方法列表可以参考[app.METHOD](http://www.expressjs.com.cn/en/4x/api.html#app.METHOD)。你还可以使用[app.all()](http://www.expressjs.com.cn/en/4x/api.html#app.all) 去处理所有的HTTP方法，也可以使用[app.use()](http://www.expressjs.com.cn/en/4x/api.html#app.use) 去指定特定的回调方法 （参考[Using middleware](http://www.expressjs.com.cn/en/guide/using-middleware.html) ）。\\r\\n\\r\\n这些路由方法指定一个回调方法（有时候又称为Handler方法）在Web应用收到对特定路由（endpoints）发出特定方式的请求的时候被调用。换句话说，应用程序能够监听所有请求，如果监听到请求的路由路径和请求方式有与之相配的路由方法，那么就调用该回调方法。\\r\\n\\r\\n事实上，路由方法可以有多个回调函数作为参数，当设计这样的路由处理的时候，提供一个`next`方法作为参数到回调函数中是很有必要的，调用`next()`在回调方法体内来传递到下一个回调方法中。\\r\\n\\r\\n下面这段代码展示了一个最基本的路由：\\r\\n\\r\\n```javascript\\r\\nvar express = require('express')\\r\\nvar app = express()\\r\\n```\\n\"\n- abbrlink: 1jvfs4t\n  title: GC Algorithm Implementation\n  categories:\n    - note\n    - thinking\n    - GC\n  tags:\n    - gc\n    - gc-algorithm\n  date: 2019-04-05T05:11:00.000Z\n  char_count: 16767\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n前面说了挺多关于GC的算法思路，接下来这篇说说在JVM里实际实现的GC算法，翻译、参考自[plumbr.io](https://plumbr.io/handbook/garbage-collection-algorithms-implementations)\\r\\n\\r\\n我们首先要清楚地认识到一个事情：除了G1回收器以外，垃圾回收算法分为**“针对新生代”**，**“针对老年代”**两种\\r\\n\\r\\n每种垃圾回收算法又有不同的实现，然后你可以随意组合，下面这张表展示了在Java8下常用的四种GC算法的组合\\r\\n\\r\\n| **Young**             | **Tenured**      | **JVM options**                              |\\r\\n| :-------------------- | :--------------- | :------------------------------------------- |\\r\\n| **Serial**            | **Serial**       | **-XX:+UseSerialGC**                         |\\r\\n| **Parallel Scavenge** | **Parallel Old** | **-XX:+UseParallelGC -XX:+UseParallelOldGC** |\\r\\n| **Parallel New**      | **CMS**          | **-XX:+UseParNewGC -XX:+UseConcMarkSweepGC** |\\r\\n| **G1**                |                  | **-XX:+UseG1GC**                             |\\r\\n\\r\\n实际上还有其他搭配，但是这些搭配要么是不支持了，要么是不实用了，所以接下来我们只关注这四种\\r\\n\\r\\n### Serial GC\\r\\n\\r\\n**Serail GC**使用[标记-复制](https://youyinnn.github.io/?to=post&number=77#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-2.%20Mark-Copy)算法回收年轻代，使用[标记-整理]()算法回收老年代\\r\\n\\r\\n\"\n- abbrlink: q0aas8\n  title: Graduation Design\n  categories:\n    - 随笔\n  comments: true\n  date: 2018-11-02T21:56:10.000Z\n  char_count: 1855\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n#### Graduation Design\\r\\n\\r\\n- Title：Tracing Monitoring System of Kafka-Cluster with Opentracing API\\r\\n- Framework：B/S\\r\\n- Technology stack：\\r\\n    - back-end：\\r\\n        - Microservice：spring-boot\\r\\n        - MessageSystem：kafka\\r\\n        - TracingSystem：opentracing\\r\\n\\r\\n    - front-end：\\r\\n\\r\\n        - normal html/css/js\\r\\n\\r\\n\\r\\n\\r\\n#### System Design：\\r\\n\\r\\n> ##### Demo：\\r\\n>\\r\\n> 1. We got three microservice application : \\r\\n\"\n- abbrlink: 1f3qusx\n  title: Hashing\n  categories:\n    - note\n    - algorithm\n  tags:\n    - algorithm\n    - hash\n  date: 2019-02-02T20:40:00.000Z\n  char_count: 5563\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### What is HashTable\\r\\n\\r\\nOf all structure we learn before like \\\"array\\\" or \\\"stack\\\", the element's position on their structure is not absolute, it's uncertain which means there is no pattern on it.  \\r\\n\\r\\nSo the searching operation was always base on \\\"comparing\\\",  the searching efficiency of them were dependence on the times they perform compare.\\r\\n\\r\\nIn a perfect situation is that we don't want to do any comparing opts, them we grape the element at once. So we need something to record the relationship between key value and the place where it store. Then next time we seek a key, we would able to use this relationship to grape it immediately.\\r\\n\\r\\nWe define the relationship as **\\\"Hash\\\"**.\\r\\n\\r\\n\\r\\n\\r\\nAnd we will discuss two aspect of it: **\\\"Hash Method\\\"** & **\\\"Collision Handle\\\"**\\r\\n\\r\\n### Hash Method\\r\\n\\r\\nThere are many ways to hash, and we better know what is a good hash method before we code it.\\r\\n\\r\\nA good hash method will mapping any key to a un-used place, which means there is no collision for all elements. The probability of it is all with the same. We call it **Uniform Hash Method**.\\r\\n\\r\\n**Capture information on key**\\r\\n\"\n- abbrlink: 12iaggv\n  title: Help GC A Favor & JIT Introduction\n  categories:\n    - note\n    - thinking\n    - GC\n  tags:\n    - JVM\n    - GC\n    - JIT\n    - OOM\n  date: 2019-03-04T04:19:00.000Z\n  char_count: 9345\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n之前我们了解过GC的很多行为和特点了，也大致知道OOM发生的地点和原因，然后还深入了解了Java中的Reference\\r\\n\\r\\n接下来我们简单说一下如何避免OOM，帮GCor们一个小忙\\r\\n\\r\\n### Help GC\\r\\n\\r\\n#### Make Object Eligible For GC\\r\\n\\r\\n1. **Object Inside A Method**\\r\\n\\r\\n    之前有提到过一嘴*“对象分配在堆上变得不是那么绝对了”*，对，对象并不都是分配在堆，对象还可以直接分配在每个线程的栈空间中，这个事情后面再说\\r\\n\\r\\n    我们在**方法内定义的新对象**，在没有指派方法外的强引用引用这些对象的时候，**等到方法结束之后，这些对象就变为了匿名对象**，转变为不可达状态，于是它们成为了GCor的关注对象之一\\r\\n\\r\\n2. **Reassigning reference variable**\\r\\n\\r\\n    重新指派引用，一个对象没有其他引用引用它了，那它也就凉了\\r\\n\\r\\n3. **Nullifying reference variable**\\r\\n\"\n- abbrlink: 2032k5\n  title: Introductions of eBay Tess\n  categories:\n    - note\n    - eBay\n  tags:\n    - eBay\n    - tess\n  date: 2018-11-15T16:18:00.000Z\n  char_count: 6317\n  short_contant: \"\\r\\n\\r\\n### Tess\\r\\n\\r\\n#### 0. What is Tess? \\r\\n\\r\\nTess.IO is eBay’s cluster manager, with a vision of ensuring a world-class **build, ship and run** experience for eBay’s applications at scale, while ensuring high efficiency, security, and agility to the developers. Tess.IO leverages Kubernetes under its hood. Kubernetes (commonly referred to as “k8s”) is an open source container cluster manager that aims to provide a “platform for automating deployment, scaling, and operations of application containers across clusters of hosts.”\\r\\n\\r\\nTess makes DevOps a breeze.\\r\\n\\r\\n> So, you don't have to setup k8s or docker on your server anymore.\\r\\n>\\r\\n> Tess is not an new tech, it's a plus-version of k8s cli with eBay's own way.\\r\\n\\r\\n#### 0.1. Further Reading\\r\\n\\r\\nTo best introduce topics, the following instructions suggest a way of consuming this documentation such that topics build upon previous topics.\\r\\n\\r\\nFirst, you’ll want to understand what Tess.IO is. For this, read the [Introduction](https://tess.io/userdocs/getting-start/intro). Next, you’ll want to set up your machine with the necessary tools and configuration to talk to Tess.IO. For this, read [Setup](https://tess.io/userdocs/getting-start/setup). Finally, you’ll want to run the [Hello World](https://tess.io/userdocs/getting-start/hello-world) example.\\r\\n\\r\\nFrom here, you can branch out depending on your needs. Consider starting with [Model Workloads](https://tess.io/userdocs/getting-start/models) followed by [Build and Deploy](https://tess.io/userdocs/getting-start/build-and-deploy).\\r\\n\\r\\nFor a better understanding of Kubernetes we recommend reading the following documentation:\\r\\n\\r\\n- Core Kubernetes [documentation](https://kubernetes.io/docs/home)\\r\\n\"\n- abbrlink: 13tt0au\n  title: Java's Refernece\n  categories:\n    - note\n    - thinking\n    - GC\n  tags:\n    - reference-type\n  date: 2019-03-02T21:08:00.000Z\n  char_count: 7749\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n本篇主要内容：\\r\\n\\r\\n1. Java 到底是值传递还是引用传递\\r\\n2. Java 中的引用类型详解以其应用场景\\r\\n\\r\\n### Pass-By-Value Or Pass-By-Reference ?\\r\\n\\r\\nJava中的所有传递都是值传递，并不存在所谓的引用传递\\r\\n\\r\\n要理解这个问题的关键在于：\\r\\n\\r\\n```java\\r\\nDog myDog;\\r\\n```\\r\\n\\r\\n其中的`myDog`并不是真正的Dog对象，而是一个*pointer*，这个指针可以指向一个Dog对象\\r\\n\\r\\n意思是说：\\r\\n\\r\\n\"\n- abbrlink: bu9klx\n  title: Java并发编程第一坎\n  categories:\n    - note\n    - booknote\n    - 《艺术》与《技术》\n  comments: true\n  tags:\n    - java\n    - thread\n    - wait/notify\n  date: 2018-06-05T22:09:00.000Z\n  series: 并发\n  char_count: 11646\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 前言\\r\\n\\r\\n本**系列**文章主要是为Java并发入门做铺垫，集中清点：\\r\\n\\r\\n- **Thread的基本概念**\\r\\n- **生命周期**\\r\\n- **创建和使用**\\r\\n- **线程的魅力所在**\\r\\n  - **从线程不同步到线程安全**\\r\\n    - **锁**\\r\\n    - **死锁情况**\\r\\n  - **从线程各自独立到线程通信**\\r\\n    - **停止线程**\\r\\n    - **唤醒线程**\\r\\n    - **通信**\\r\\n- **Java中的并发编程**\\r\\n- **并发和单例模式的那些事**\\r\\n\\r\\n本系列除了参考*《Java并发编程的艺术》*和*《Java多线程编程核心技术》*这两本书之外，还会参考JDK的源码和[API文档](https://docs.oracle.com/javase/8/docs/api/)，**会翻译文档中部分重要的说明，比如过期方法为什么过期和官方解决办法等等**\\r\\n\\r\\n本篇主要介绍一下三部分\\r\\n\"\n- abbrlink: u4sgci\n  title: Java并发编程第七坎-2\n  categories:\n    - note\n    - booknote\n    - 《艺术》与《技术》\n  comments: true\n  tags:\n    - java\n    - thread\n    - AQS\n  date: 2018-12-30T12:58:48.000Z\n  series: 并发\n  char_count: 19988\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n上节我们介绍了Java并发编程的一个新的阶段——Java并发包中的`Lock`接口以及`AbstractQueuedSynchronizer`的配合使用\\r\\n\\r\\n并且尝试实现了一个简单的独占锁Mutex，借此我们了解到，并发编程还能如此灵活与优雅\\r\\n\\r\\n本节还是属于第七坎，因为第七坎应该是关于整个Java并发包的基础内容，所以会分成多节进行\\r\\n\\r\\n在上节的最后我们运用`Lock`和`AbstractQueuedSynchronizer`去简单地实现了一个独占锁，本节我们紧接着要分析一下`AbstractQueuedSynchronizer`的部分方法的实现原理，了解同步器为什么能如此强大\\r\\n\\r\\n本篇参考书本上，试图分析**独占式同步状态的获取和释放/共享式同步状态的获取和释放**的源码\\r\\n\\r\\n观察源码之前我们需要回顾一下：\\r\\n\\r\\n>  对于同步器中的方法，我们需要实现的是：**对同步状态的“尝试”获取/释放**的一类方法\\r\\n>\\r\\n> - try方法只返回是否获取同步状态成功（独占式）/获取到了1个以上的同步状态（共享式）\\r\\n> - 这类方法被模板方法第一次尝试调用：\\r\\n>     - 若成功，则线程获取到锁；\\r\\n>     - 若失败，则模板方法继续管理同步队列\\r\\n> - 在线程成为结点加入到同步队列的过程中，结点在自旋的时候也在不断地try获取同步状态\\r\\n\"\n- abbrlink: 7kdfk8\n  title: Java并发编程第七坎\n  categories:\n    - note\n    - booknote\n    - 《艺术》与《技术》\n  comments: true\n  tags:\n    - java\n    - thread\n    - AQS\n    - Lock-Api\n  date: 2018-12-25T22:22:48.000Z\n  series: 并发\n  char_count: 9194\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n> 事前吐槽：*Doug Lea*老爷子的注释可真难读，也许是我英语太菜鸡了- -（本来还挺自信的，现在哭着学英语）\\r\\n\\r\\n接下来我们进入Java并发编程的一个崭新的阶段\\r\\n\\r\\n前面我们对于锁的实现和同步的编程，都是基于`synchronized`关键字的实现，现在开始接触到的，是Java并发包中提供的锁相关的API，首先可以了解到的是，我们可以通过API的方式去实现**“获取锁”**和**“释放锁”**，从而更灵活的去进行并发编程\\r\\n\\r\\n至此，以后我们再谈起**“Java中的锁”**，它可能指的是多个意义上的，讨论之前先要明确一个方向：\\r\\n\\r\\n- `synchronized`/`volatile`关键字的使用\\r\\n- 锁的几种**等级**和区别\\r\\n- 锁的几种**类型**和使用场景\\r\\n- **Lock API**的使用以及和`synchronized`的区别\\r\\n\\r\\n### Lock 接口\\r\\n\\r\\n在Lock之前，Java是靠`synchronized`关键字去实现锁的，Java5之后，并发包中新增了Lock接口\\r\\n\\r\\n\"\n- abbrlink: 1h1ww1y\n  title: Java并发编程第三坎\n  categories:\n    - note\n    - booknote\n    - 《艺术》与《技术》\n  comments: true\n  tags:\n    - java\n    - thread\n    - CAS\n  date: 2018-07-18T14:15:22.000Z\n  series: 并发\n  char_count: 2526\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 前言\\r\\n\\r\\n前两篇基本说了线程的基本概念和基本使用，这回说说Java并发编程第三坎，关于锁的好多基本概念的提前了解\\r\\n\\r\\n在讲锁之前，我们还需要介绍一个很重要的原理——CAS（Compare And Swap）操作，这个操作是保证并发过程中每个操作具有**“原子性”**的利器\\r\\n\\r\\n- **关键概念说明：**临界区、排他锁、共享式锁、Java对象头\\r\\n- **什么是CAS操作：**原子性、CAS\\r\\n\\r\\n暂时只有这些概念，如果有什么提前概念我会继续补充\\r\\n\\r\\n-------\\r\\n\\r\\n### 关键概念说明\\r\\n\\r\\n#### 临界区\\r\\n\\r\\n在操作系统的解释上，临界区代表的是**“不允许多个进程访问的资源叫临界资源，而访问临界资源的代码段叫临界区”**\\r\\n\\r\\n而在这里，我们可以笼统地说：**锁包括的范围就是临界区，临界区的资源需要保证内存可见性，需要对所有线程任何时刻都保持一致性**\\r\\n\\r\\n\"\n- abbrlink: 1clnpuk\n  title: Java并发编程第二坎\n  categories:\n    - note\n    - booknote\n    - 《艺术》与《技术》\n  comments: true\n  tags:\n    - java\n    - thread\n    - interrupt\n    - stop&suspend&resume\n  date: 2018-07-15T10:53:22.000Z\n  series: 并发\n  char_count: 12469\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 前言\\r\\n\\r\\n前一篇基本说了线程的基本概念和如何创建一个线程，以及非常基本的几个线程方法，接下来我们说说线程的前几个控制相关的方法，包括和暂停一个线程（PAUSE）、让暂停的线程恢复（RESUME）、让线程终止（STOP）\\r\\n\\r\\n这篇我们但是这几个方法不能直接去用，因为这些方法都**过期了**！下面就着Java官方的文档解释，说说为什么过期这几个方法，以及贴出官方给的模板方法去实现这几个过期方法，具体的实现会在后面有例子\\r\\n\\r\\n-------\\r\\n\\r\\n\\r\\n#### 中断线程\\r\\n\\r\\n我们现在已经可以跑起来一个线程了，但是对于线程的控制力度还不够，我们希望在处理线程子任务的时候，碰到需要暂停任务的情况的时候，我们有能力马上就退出\\r\\n\\r\\n但是停止线程的任务并不简单，总的来说，停止线程的方式有这么三种：\\r\\n\\r\\n- **让run方法执行完**，线程就停了\\r\\n- **使用stop方法**，但是这个方法**绝对不能够使用**，因为不安全而被列为**过期方法**\\r\\n- **使用interrupt方法去中断线程**\\r\\n\\r\\n这么看来，如果要在线程任务中间去停止线程，只能使用**interrupt方法**，但是这个方法也**不是说停就停**的\\r\\n\\r\\n\"\n- abbrlink: 1xo3tpx\n  title: Java并发编程第五坎\n  categories:\n    - note\n    - booknote\n    - 《艺术》与《技术》\n  comments: true\n  tags:\n    - java\n    - thread\n    - JMM\n    - happens-before\n    - volatile语义\n    - 锁语义\n  date: 2018-07-21T19:33:48.000Z\n  series: 并发\n  char_count: 9425\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 前言\\r\\n\\r\\n前面说了好多好多刀枪剑，还说了一些最前置的内功心法，这回说说更深层的内功心法——**JMM，Java Memory Model，Java内存模型！**\\r\\n\\r\\nJava线程之间的通信对程序员是完全透明的（你是很难感知得到的），所以内存可见性问题经常称为并发的通病之一，这坎说的内存模型，是让你更好地去感知，去推断线程内存通信的有力武器。\\r\\n\\r\\n这坎基本就是*《核心》*的第三章内容，我就这书总结一下，然后调一下排版，主要说的内容：\\r\\n\\r\\n- **JMM基础：介绍基本概念**\\r\\n- **JMM中的顺序一致性：重排序和顺序一致性内存**\\r\\n- **三个同步原语synchronized、volatile的内存语义**\\r\\n- **重排序规则**\\r\\n- **JMM设计原理**\\r\\n\\r\\n-------\\r\\n\\r\\n### JMM基础\\r\\n\\r\\n#### 并发编程的两个关键问题\\r\\n\\r\\n线程之间如何进行通信？线程之间如何进行同步？在命令式编程中，线程通信机制有两种：共享内存和消息通信\\r\\n\"\n- abbrlink: 1u7rv30\n  title: Java并发编程第八坎\n  categories:\n    - note\n    - booknote\n    - 《艺术》与《技术》\n  comments: true\n  tags:\n    - java\n    - thread\n    - Lock-Api\n    - reentrantLock\n    - reentrantReadWriteLock\n  date: 2019-01-07T22:46:48.000Z\n  series: 并发\n  char_count: 16206\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n我们对Lock和AQS有了一定的了解了之后，可以尝试着接触一些Lock+AQS的基本实现了，本篇会了解到最基本的同步组件`ReentrantLock`和`ReentrantReadWriteLock`，前者提供了排他锁的实现，并且支持重入，后者在前者的基础上，支持锁的分级，写锁排他读锁共享。特别的，重入锁的获取还有公平和非公平之分，我们先从这部分入手。\\r\\n\\r\\n#### Fair Lock & Nonfair Lock\\r\\n\\r\\n公平锁：锁的获取次序和请求锁的时间顺序一致，即在绝对的时间里，等待时间越久的线程越先获取到锁。\\r\\n\\r\\n非公平锁：锁的获取和瞬间的竞争有关，一瞬间谁运气好就能获取到锁，而且锁的获取即同步状态的获取，刚获取到同步状态的线程，再次获取到状态的机会比较大。\\r\\n\\r\\n说明：虽然非公平锁可能会造成“饥饿”情况，但是大多数情况下还是非公平锁用的多，因为公平锁在释放锁又再获取锁的时候，总是会**切换线程**，而非公平锁一段时间内很可能总是那一个线程不停放锁持锁，**线程切换的开销小就意味着——吞吐量大**\\r\\n\\r\\n再说多一点，公平性和非公平性是**“针对未入队结点”**和**“已入队结点”**而言，上一篇文章已经提到过，队列中的结点都是公平获取锁的，遵从FIFO，至于具体的体现，继续往下读，读到FairSync的`tryAcquire`和`hasQueuedPredecessors`方法就知道了\\r\\n\\r\\n#### ReentrantLock\\r\\n\\r\\n重入锁可以通过构造器来决定公平机制，默认是非公平锁：\\r\\n\\r\\n``` java\\r\\n/**\\r\\n * Creates an instance of {@code ReentrantLock}.\\r\\n```\\n\"\n- abbrlink: 139027a\n  title: Java并发编程第六坎\n  categories:\n    - note\n    - booknote\n    - 《艺术》与《技术》\n  comments: true\n  tags:\n    - java\n    - thread\n    - dead-lock\n    - wait/notify\n    - consumer/producer\n    - double-check-singleton\n  date: 2018-07-25T21:33:48.000Z\n  series: 并发\n  char_count: 11557\n  short_contant: \"\\r\\n\\r\\n\\r\\n### 前言\\r\\n\\r\\n不知不觉写到第六坎了，前面刀剑磨刀石内功心法都有了，感觉自己应该很厉害了，其实不是，这一个月因为考试末尾和实习，断断续续的看，反反复复的看，越看越精神，越看越心虚。\\r\\n\\r\\n无论怎么说，短板还是得慢慢补上来，保持谦逊，虚心学习。\\r\\n\\r\\n回到整体，前面由内到外说了Java并发中很基本的几件事：\\r\\n\\r\\n- 基本的线程API和使用\\r\\n- 基本的并发概念\\r\\n- volatile和synchronized和锁概念\\r\\n\\r\\n我觉得是时候得停一下，综合一下这些东西，真刀真枪干几次，所以这篇算是我们并发游戏世界中，主人翁的**“初出茅庐”**篇，又可以叫做小试牛刀，在这篇我尝试例出并发编程中最基本的场景如：\\r\\n\\r\\n- **死锁**\\r\\n- **“等待-通知”**\\r\\n- **有超时的“等待-通知”**\\r\\n- **“生产者-消费者”模式**\\r\\n- **双重检查锁延迟初始化的错误与正确示范**\\r\\n\\r\\n-------\\r\\n\\r\\n\"\n- abbrlink: db3vx3\n  title: Java并发编程第四坎\n  categories:\n    - note\n    - booknote\n    - 《艺术》与《技术》\n  comments: true\n  tags:\n    - java\n    - thread\n    - volatile\n    - synchronized\n  date: 2018-07-18T14:16:48.000Z\n  series: 并发\n  char_count: 12106\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 前言\\r\\n\\r\\n这回说说Java并发编程第四坎，最常用的**volatile和synchronized关键字**，这两个关键字是理解java同步编程的第一步，，特别是**synchronized关键字**在*《Java多线程编程核心技术》*中不经意的道出了**线程同步的真谛之一：避免脏读**\\r\\n\\r\\n- **关键字的解说**\\r\\n  - **volatile的含义、底层实现和使用**\\r\\n  - **synchronized的含义、底层实现和使用**\\r\\n    - Java中的几种锁\\r\\n    - Java中的锁到底是什么？\\r\\n  - **两个关键字的对比**\\r\\n\\r\\n------\\r\\n\\r\\n### 关键字的解说\\r\\n\\r\\n关键字的解说分别从三个方面进行，首先解释关键字的基本含义，然后上一些基本使用的代码，最后结合两本书来说说关键字的底层实现。\\r\\n\\r\\n以下两段摘自*《艺术》P96*\\r\\n\\r\\n> **关键字volatile**可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量的方位你的可见性。\\r\\n\\r\\n\"\n- abbrlink: 1pf7qyq\n  title: Java运算符的阴谋论\n  categories:\n    - note\n  comments: true\n  tags:\n    - java\n    - operator\n  date: 2018-06-03T21:28:00.000Z\n  char_count: 7996\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n{% cq %}\\r\\n\\r\\n小心点，一不小心你就栽跟头了 :ghost:\\r\\n\\r\\n{% endcq%}\\r\\n\\r\\n\\r\\n\\r\\n### 你画我猜\\r\\n\\r\\n下面程序输出多少？\\r\\n\\r\\n```java\\r\\npublic static void main(String[] args) {\\r\\n    int i = 2;\\r\\n    i += i -= i *= i;\\r\\n    System.out.println(i);\\r\\n}\\r\\n```\\r\\n\\r\\n答案：0\\r\\n\"\n- abbrlink: 1arzjog\n  title: Jenkins Introductions&Setup\n  categories:\n    - note\n    - jenkins\n  tags:\n    - setup\n    - jenkins\n  date: 2018-11-19T14:51:00.000Z\n  series: jenkins\n  char_count: 4227\n  short_contant: \"\\r\\n\\r\\n### Introductions\\r\\n\\r\\n首先Jenkins要吐槽一下，Jenkins的Logo真的是太丑了，虽然很明显是一个管家形象- -\\r\\n\\r\\n\\r\\n\\r\\nJenkins的默认UI也有点丑，还不如官网的UI好看\\r\\n\\r\\n但是不影响这玩意的强大表现\\r\\n\\r\\n### Installation on CentOS\\r\\n\\r\\n#### Fetch yum repo\\r\\n\\r\\nAdd the Jenkins repository to the yum repos, and install Jenkins from here.\\r\\n\\r\\nThere is also [a LTS YUM repository](http://pkg.jenkins-ci.org/redhat-stable/) for the [LTS Release Line](https://wiki.jenkins.io/display/JENKINS/LTS+Release+Line)\\r\\n\\r\\n- `sudo wget -O /etc/yum.repos.d/jenkins.repo` `http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo`\\r\\n- `sudo rpm --import` `https://jenkins-ci.org/redhat/jenkins-ci.org.key`\\r\\n- `sudo yum install jenkins`\\r\\n\\r\\n#### Installation of Java\\r\\n\"\n- abbrlink: 17hjlts\n  title: JettyDocument_ZH_CN_Translation_Part1\n  tags:\n    - jetty\n    - document\n  categories:\n    - translation\n  series: JettyDocument_ZH_CN_Translation\n  date: 2018-05-07T17:30:01.000Z\n  char_count: 25573\n  short_contant: \"\\r\\n\\r\\n### Ⅰ.开始使用Jetty\\r\\n<span id=\\\"top\\\"></span>\\r\\n  - 1. [关于Jetty的介绍](#1关于jetty的介绍)\\r\\n    - [什么是Jetty](#11什么是jetty)\\r\\n    - [我应该使用哪个版本](#12我应该使用哪个版本)\\r\\n    - [Jetty和JavaEE的Web规范](#13jetty和javaee的web规范)\\r\\n    - [在Maven里面找到Jetty](#14在maven里面找到jetty)\\r\\n  - 2. [使用Jetty](#2使用jetty)\\r\\n    - [下载Jetty](#21下载jetty)\\r\\n    - [运行Jetty](#22运行jetty)\\r\\n      - [Demo Base](#221demo-base)\\r\\n      - [创建Jetty Base](#222创建jetty-base)\\r\\n      - [更改Jetty的端口号](#223更改jetty的端口号)\\r\\n      - [为HTTPS和HTTP2添加SSL](#224为https和http2添加ssl)\\r\\n      - [更改HTTPS的端口号](#225更改https的端口号)\\r\\n      - [获取更多的start.jar选项](#226获取更多的startjar选项)\\r\\n    - [部署Web应用](#23部署web应用)\\r\\n  - 3. [关于Jetty Configuration的介绍](#3关于jetty-configuration的介绍)\\r\\n    - [如何配置Jetty](#31如何配置jetty)\\r\\n      - [使用POJO的方法配置](#311使用pojo的方法配置)\\r\\n      - [使用Start配置文件配置](#312使用start配置文件配置)\\r\\n      - [其他配置文件](#313其他配置文件)\\r\\n      - [Jetty的IoC XML的形式配置](#314jetty的ioc-xml的形式配置)\\r\\n\"\n- abbrlink: cc3kmk\n  title: JettyDocument_ZH_CN_Translation_Part3-13\n  tags:\n    - jetty\n    - document\n  categories:\n    - translation\n  series: JettyDocument_ZH_CN_Translation\n  date: 2018-05-07T17:30:01.000Z\n  char_count: 14556\n  short_contant: \"\\r\\n\\r\\n<span id=\\\"top\\\"></span>\\r\\n### Ⅲ. Jetty管理者指南-13.注释\\r\\n  - 13. [注解](#13注解)\\r\\n    - [快速设置](#131快速设置)\\r\\n      - [关于Jetty发行版](#1311关于jetty发行版)\\r\\n      - [关于Jetty Maven Plugin](#1312关于jetty-maven-plugin)\\r\\n      - [关于嵌入式](#1313关于嵌入式)\\r\\n    - [使用注解](#132使用注解)\\r\\n      - [支持哪些注解](#1321支持哪些注解)\\r\\n      - [检测注解和自检注解的对比](#1322检测注解和自检注解的对比)\\r\\n      - [哪些jar包支持扫描检查注解](#1323哪些jar包支持扫描检查注解)\\r\\n      - [多线程注解扫描](#1324多线程注解扫描)\\r\\n      - [ServletContainerInitializers](#1325servletcontainerinitializers)\\r\\n    - [在Jetty嵌入式开发中使用注解](#133在jetty嵌入式开发中使用注解)\\r\\n      - [设置类路径](#1331设置类路径)\\r\\n      - [栗子](#1332栗子)\\r\\n- - -\\r\\n\\r\\n<span id=\\\"13注解\\\"></span>\\r\\n#### 13、注解\\r\\n- 13.1、[快速设置](#131快速设置)\\r\\n- 13.2、[使用注解](#132使用注解)\\r\\n- 13.3、[在Jetty嵌入式开发中使用注解](#133在jetty嵌入式开发中使用注解)\\r\\n\"\n- abbrlink: 18rke1\n  title: JettyDocument_ZH_CN_Translation_Part4-21\n  tags:\n    - jetty\n    - document\n  categories:\n    - translation\n  series: JettyDocument_ZH_CN_Translation\n  date: 2018-05-07T17:30:01.000Z\n  char_count: 36623\n  short_contant: \"\\r\\n\\r\\n<span id=\\\"top\\\"></span>\\r\\n### Ⅳ. Jetty开发指南-21.嵌入式开发\\r\\n  - 21. [嵌入式开发](#21嵌入式开发)\\r\\n    - [Jetty的嵌入式Hello World](#211jetty的嵌入式hello-world)\\r\\n      - [下载Jar包](#2111下载jar包)\\r\\n      - [Hello World栗子](#2112hello-world栗子)\\r\\n      - [编译Hello World栗子](#2113编译hello-world栗子)\\r\\n      - [运行Handler和Server](#2114运行handler和server)\\r\\n      - [下一步](#2115下一步)\\r\\n    - [Jetty的嵌入式开发](#212jetty的嵌入式开发)\\r\\n      - [概述](#2121概述)\\r\\n      - [创建Server](#2122创建server)\\r\\n      - [使用Handler](#2123使用handler)\\r\\n        - [一个Handler的Hello World](#21231一个handler的hello-world)\\r\\n        - [运行HelloWorldHandler](#21232运行helloworldhandler)\\r\\n        - [Handler Collections和Wrappers](#21233handler-collections和wrappers)\\r\\n        - [Scoped Handlers](#21234scoped-handlers)\\r\\n        - [Resource Handler](#21235resource-handler)\\r\\n      - [嵌入Connectors](#2124嵌入connectors)\\r\\n        - [一个Connectors](#21241一个connectors)\\r\\n        - [多个Connectors](#21242多个connectors)\\r\\n      - [嵌入Servlets](#2125嵌入servlets)\\r\\n      - [嵌入Contexts](#2126嵌入contexts)\\r\\n\"\n- abbrlink: 1cei7aq\n  title: JettyDocument_ZH_CN_Translation_Part4-23\n  tags:\n    - jetty\n    - document\n  categories:\n    - translation\n  series: JettyDocument_ZH_CN_Translation\n  date: 2018-05-07T17:30:01.000Z\n  char_count: 16624\n  short_contant: \"\\r\\n\\r\\n<span id=\\\"top\\\"></span>\\r\\n### Ⅳ. Jetty开发指南-23.Jetty和Maven\\r\\n- 23. [Jetty和Maven](#23jetty和maven)\\r\\n  - [使用Maven](#231使用maven)\\r\\n    - [使用Maven做嵌入式Jetty开发](#2311使用maven做嵌入式jetty开发)\\r\\n    - [使用Maven开发标准的WebApp](#2321使用maven开发标准的wabapp)\\r\\n  - [配置Jetty的Maven插件](#232配置jetty的maven插件)\\r\\n    - [快速开始](#2321快速开始)\\r\\n    - [支持目标](#2322支持目标)\\r\\n    - [配置Jetty容器](#2323配置jetty容器)\\r\\n    - [配置你的WebApp](#2324配置你的webapp)\\r\\n    - [jetty:run](#2325jettyrun)\\r\\n    - [jetty:run-war](#2326jettyrunwar)\\r\\n    - [jetty:run-exploded](#2327jettyrunexploded)\\r\\n    - [jetty:run-forked](#2328jettyrunforked)\\r\\n    - [jetty:start](#2329jettystart)\\r\\n    - [jetty:stop](#23210jettystop)\\r\\n    - [jetty:effective-web-xml](#23211jettyeffectivewebxml)\\r\\n    - [使用覆盖war](#23212使用覆盖war)\\r\\n    - [配置Security](#23213配置security)\\r\\n    - [使用多个WebappRoot目录](#23214使用多个webapproot目录)\\r\\n    - [运行一个以上的Webapp](#23215运行一个以上的webapp)\\r\\n    - [设置系统属性](#23216设置系统属性)\\r\\n\"\n- abbrlink: n8gsoq\n  title: JettyDocument_ZH_CN_Translation_README\n  tags:\n    - jetty\n    - document\n    - readme\n  categories:\n    - translation\n  series: JettyDocument_ZH_CN_Translation\n  date: 2018-05-07T17:30:01.000Z\n  char_count: 2979\n  short_contant: \"\\r\\n\\r\\n# Jetty : Servlet Engine and HTTP server\\r\\n创立时间：2017年8月25日16:13:49\\r\\n\\r\\n官方文档地址：http://www.eclipse.org/jetty/documentation/9.4.6.v20170531/\\r\\n- - -\\r\\nMaven依赖：\\r\\n```\\r\\n<properties>\\r\\n    <jetty-version>9.4.6.v20170531</jetty-version>\\r\\n</properties>\\r\\n\\r\\n<dependencies>\\r\\n\\r\\n    <!-- jetty-server部分 -->\\r\\n    <dependency>\\r\\n        <groupId>org.eclipse.jetty</groupId>\\r\\n        <artifactId>jetty-server</artifactId>\\r\\n        <version>${jetty-version}</version>\\r\\n    </dependency>\\r\\n\\r\\n    <!-- jetty-servlet部分 -->\\r\\n    <dependency>\\r\\n        <groupId>org.eclipse.jetty</groupId>\\r\\n```\\n\"\n- abbrlink: u28b7l\n  title: kafka-helloworld-concept\n  categories:\n    - note\n    - kafka\n  tags:\n    - kafka\n  date: 2018-11-06T15:39:00.000Z\n  char_count: 7071\n  short_contant: \"\\r\\n\\r\\n### 前言\\r\\n\\r\\n因为Intern Job的原因，要接触到kafka和Microservice，虽然目前接触的不是很多，对于kafka的场景还不是很熟悉，但是总觉得这个东西是必学的，也是很重要的一种趋势\\r\\n\\r\\n于是前几天给帖老板写的Graduation Design里写的就是kafka+springboot+opentracing的tracing监控系统\\r\\n\\r\\n难度还是有的，springboot刚上手，opentracing的api在前一个月的工作里面也算是熟悉了，关键就是kafka以及如何把这几个玩意整合起来\\r\\n\\r\\nanyway，这篇是关于kafka的入门理论基础\\r\\n\\r\\n绝大部分转自：http://orchome.com\\r\\n\\r\\n----\\r\\n\\r\\n### 简单说明什么是kafka\\r\\n\\r\\nApache kafka是消息中间件的一种，我发现很多人不知道消息中间件是什么，在开始学习之前，我这边就先简单的解释一下什么是消息中间件，只是粗略的讲解，目前kafka已经可以做`更多`的事情。\\r\\n\\r\\n举个例子，生产者消费者，生产者生产鸡蛋，消费者消费鸡蛋，生产者生产一个鸡蛋，消费者就消费一个鸡蛋，假设消费者消费鸡蛋的时候噎住了（系统宕机了），生产者还在生产鸡蛋，那新生产的鸡蛋就丢失了。再比如生产者很强劲（大交易量的情况），生产者1秒钟生产100个鸡蛋，消费者1秒钟只能吃50个鸡蛋，那要不了一会，消费者就吃不消了（消息堵塞，最终导致系统超时），消费者拒绝再吃了，”鸡蛋“又丢失了，这个时候我们放个篮子在它们中间，生产出来的鸡蛋都放到篮子里，消费者去篮子里拿鸡蛋，这样鸡蛋就不会丢失了，都在篮子里，而这个篮子就是”kafka“。\\r\\n鸡蛋其实就是“数据流”，系统之间的交互都是通过“数据流”来传输的（就是tcp、http什么的），也称为报文，也叫“消息”。\\r\\n消息队列满了，其实就是篮子满了，”鸡蛋“ 放不下了，那赶紧多放几个篮子，其实就是kafka的扩容。\\r\\n各位现在知道kafka是干什么的了吧，它就是那个\\\"篮子\\\"。\\r\\n\\r\\n\"\n- abbrlink: 1ro5m3y\n  title: kafka-topic-storage-detail\n  categories:\n    - note\n    - kafka\n  tags:\n    - kafka\n  date: 2018-11-06T16:34:00.000Z\n  char_count: 6219\n  short_contant: \"\\r\\n\\r\\n### Topic & Partition\\r\\n\\r\\nkafka中的Message以topic为分类去组织的，每个topic又可以分为不同的partition去存储：\\r\\n\\r\\n\\r\\n\\r\\n我们引用官方的Introduction中的一节，看官方是怎么解释的：\\r\\n\\r\\nEach partition is an ordered, immutable sequence of records that is continually appended to—a structured commit log. The records in the partitions are each assigned a sequential id number called the *offset* that uniquely identifies each record within the partition.\\r\\n\\r\\n每个分区都是一个**有序的，不可变的记录序列**，不断附加到结构化的提交日志中。分区中的记录每个都分配了一个称为偏移的顺序ID号，它唯一地标识分区中的每个记录。\\r\\n\\r\\nThe Kafka cluster durably persists all published records—whether or not they have been consumed—using a configurable retention period. For example, if the retention policy is set to two days, then for the two days after a record is published, it is available for consumption, after which it will be discarded to free up space. Kafka's performance is effectively constant with respect to data size so storing data for a long time is not a problem.\\r\\n\\r\\nKafka集群使用**可配置的保留期（configurable retention period）**，来持久保存所有已发布的记录，无论是否已**消费（consume）**。\\r\\n\\r\\n例如，如果保留策略设置为两天，则在发布记录后的两天内，它都是可供消费（consume）的，之后将被**丢弃（discarded）**以释放空间。Kafka的性能在数据大小方面实际上是恒定的，因此长时间存储数据不是问题。\\r\\n\\r\\nIn fact, the only metadata retained on a per-consumer basis is the offset or position of that consumer in the log. This offset is controlled by the consumer: normally a consumer will advance its offset linearly as it reads records, but, in fact, since the position is controlled by the consumer it can consume records in any order it likes. For example a consumer can reset to an older offset to reprocess data from the past or skip ahead to the most recent record and start consuming from \\\"now\\\".\\r\\n\\r\\n实际上，基于每个消费者保留的唯一元数据是该消费者在日志中的**偏移或位置（offset/position）**。\\r\\n\\r\\n这种偏移由消费者控制：通常消费者在读取记录时会线性地提高其偏移量，但事实上，由于该位置由消费者控制，因此它可以按照自己喜欢的任何顺序消费记录。\\r\\n\"\n- abbrlink: 2gps3g\n  title: Leetcode-11~15\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n  date: 2019-02-27T21:42:00.000Z\n  series: leetcode\n  char_count: 10244\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 11. Container With Most Water(Medium)\\r\\n\\r\\nGiven *n* non-negative integers *a1*, *a2*, ..., *an* , where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\\r\\n\\r\\n**Note:** You may not slant the container and *n* is at least 2.\\r\\n\\r\\n\\r\\n\\r\\nThe above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\\r\\n\\r\\n**Example:**\\r\\n\\r\\n```\\r\\nInput: [1,8,6,2,5,4,8,3,7]\\r\\nOutput: 49\\r\\n```\\r\\n\\r\\n#### Ⅰ. Brute Force - O(n^2)\\r\\n\\r\\n```java\\r\\npublic int maxArea2(int[] height) {\\r\\n```\\n\"\n- abbrlink: 3yl2hx\n  title: Leetcode-16~20\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n  date: 2019-03-06T20:13:00.000Z\n  series: leetcode\n  char_count: 8697\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 16.3SumClosest(Medium)\\r\\n\\r\\nGiven an array `nums` of *n* integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.\\r\\n\\r\\n**Example:**\\r\\n\\r\\n```\\r\\nGiven array nums = [-1, 2, 1, -4], and target = 1.\\r\\n\\r\\nThe sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\\r\\n```\\r\\n\\r\\n和上一题一样，只不过这一题并不用废心思处理重复\\r\\n\\r\\n```java\\r\\npublic int threeSumClosest2(int[] nums, int target) {\\r\\n    Arrays.sort(nums);\\r\\n    int closest = nums[0] + nums[1] + nums[nums.length - 1];\\r\\n    for (int i = 0; i < nums.length - 2; i++) {\\r\\n        int l = i + 1, r = nums.length - 1;\\r\\n        while (l < r) {\\r\\n```\\n\"\n- abbrlink: pn2ezr\n  title: Leetcode-1~5\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n  date: 2019-02-02T19:51:00.000Z\n  series: leetcode\n  char_count: 19284\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 1. TwoSum(Easy)\\r\\n\\r\\nGiven an array of integers, return **indices** of the two numbers such that they add up to a specific target.\\r\\n\\r\\nYou may assume that each input would have **exactly** one solution, and you may not use the *same* element twice.\\r\\n\\r\\n**Example:**\\r\\n\\r\\n```\\r\\nGiven nums = [2, 7, 11, 15], target = 9,\\r\\n\\r\\nBecause nums[0] + nums[1] = 2 + 7 = 9,\\r\\nreturn [0, 1].\\r\\n```\\r\\n\\r\\n#### Ⅰ.Brute Force\\r\\n\\r\\n``` java\\r\\npublic int[] twoSum(int[] nums, int target) {\\r\\n    for (int i = 0; i < nums.length; i++) {\\r\\n        for (int j = i + 1; j < nums.length; j++) {\\r\\n```\\n\"\n- abbrlink: 1hrw4sv\n  title: Leetcode-21~25\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n  date: 2019-03-06T21:17:00.000Z\n  series: leetcode\n  char_count: 10446\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 21. Merge Two Sorted Lists(Easy)\\r\\n\\r\\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\\r\\n\\r\\n**Example:**\\r\\n\\r\\n```\\r\\nInput: 1->2->4, 1->3->4\\r\\nOutput: 1->1->2->3->4->4\\r\\n```\\r\\n\\r\\n#### Brute Force(Beat 90.65%)\\r\\n\\r\\n```java\\r\\npublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\r\\n    if (l1 == null || l2 == null) {\\r\\n        return l1 == null ? l2 : l1;\\r\\n    }\\r\\n    ListNode pre = new ListNode(0);\\r\\n    pre.next = l1;\\r\\n    ListNode head = l1;\\r\\n```\\n\"\n- abbrlink: 448jer\n  title: Leetcode-26~30\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n  date: 2019-03-09T16:21:00.000Z\n  series: leetcode\n  char_count: 13026\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 26. Remove Duplicated From Sorted Array(Easy)\\r\\n\\r\\nGiven a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each element appear only *once* and return the new length.\\r\\n\\r\\nDo not allocate extra space for another array, you must do this by **modifying the input array in-place** with O(1) extra memory.\\r\\n\\r\\n**Example 1:**\\r\\n\\r\\n```\\r\\nGiven nums = [1,1,2],\\r\\n\\r\\nYour function should return length = 2, with the first two elements of nums being 1 and 2 respectively.\\r\\n\\r\\nIt doesn't matter what you leave beyond the returned length.\\r\\n```\\r\\n\\r\\n**Example 2:**\\r\\n\\r\\n```\\r\\nGiven nums = [0,0,1,1,1,2,2,3,3,4],\\r\\n\\r\\n```\\n\"\n- abbrlink: dbne5d\n  title: Leetcode-31~35\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n  date: 2019-03-16T21:46:00.000Z\n  series: leetcode\n  char_count: 8259\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 31. Next Permutation(Medium)\\r\\n\\r\\nImplement **next permutation**, which rearranges numbers into the lexicographically next greater permutation of numbers.\\r\\n\\r\\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\\r\\n\\r\\nThe replacement must be **in-place** and use only constant extra memory.\\r\\n\\r\\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\\r\\n\\r\\n```\\r\\n1,2,3` → `1,3,2`\\r\\n`3,2,1` → `1,2,3`\\r\\n`1,1,5` → `1,5,1\\r\\n```\\r\\n\\r\\n#### From Back(7ms)\\r\\n\\r\\n不难，找规律找出来就好了，首先弄清楚字典顺序是怎么回事，比如序列1 2 3 4，往后的序列是\\r\\n\\r\\n```\\r\\n```\\n\"\n- abbrlink: v6ei19\n  title: Leetcode-36~40\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n    - sudoku\n    - combination-sum\n  date: 2019-03-20T19:46:00.000Z\n  series: leetcode\n  char_count: 8384\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 36. Valid Sudoku(Medium)\\r\\n\\r\\nDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:\\r\\n\\r\\n1. Each row must contain the digits `1-9` without repetition.\\r\\n2. Each column must contain the digits `1-9` without repetition.\\r\\n3. Each of the 9 `3x3` sub-boxes of the grid must contain the digits `1-9` without repetition.\\r\\n\\r\\n\\r\\n\\r\\nA partially filled sudoku which is valid.\\r\\n\\r\\nThe Sudoku board could be partially filled, where empty cells are filled with the character `'.'`.\\r\\n\\r\\n**Example 1:**\\r\\n\\r\\n```\\r\\nInput:\\r\\n[\\r\\n  [\\\"5\\\",\\\"3\\\",\\\".\\\",\\\".\\\",\\\"7\\\",\\\".\\\",\\\".\\\",\\\".\\\",\\\".\\\"],\\r\\n  [\\\"6\\\",\\\".\\\",\\\".\\\",\\\"1\\\",\\\"9\\\",\\\"5\\\",\\\".\\\",\\\".\\\",\\\".\\\"],\\r\\n```\\n\"\n- abbrlink: 11z93zc\n  title: Leetcode-41~45\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n  date: 2019-03-20T20:03:00.000Z\n  series: leetcode\n  char_count: 11222\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 41. First Missing Postive(Hard)\\r\\n\\r\\nGiven an unsorted integer array, find the smallest missing positive integer.\\r\\n\\r\\n**Example 1:**\\r\\n\\r\\n```\\r\\nInput: [1,2,0]\\r\\nOutput: 3\\r\\n```\\r\\n\\r\\n**Example 2:**\\r\\n\\r\\n```\\r\\nInput: [3,4,-1,1]\\r\\nOutput: 2\\r\\n```\\r\\n\\r\\n**Example 3:**\\r\\n\\r\\n```\\r\\n```\\n\"\n- abbrlink: jywoys\n  title: Leetcode-46~50\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n    - permutation\n    - backtrack\n    - mypow\n  date: 2019-03-27T07:39:00.000Z\n  series: leetcode\n  char_count: 6755\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 46. Permutation(Medium)\\r\\n\\r\\nGiven a collection of **distinct** integers, return all possible permutations.\\r\\n\\r\\n**Example:**\\r\\n\\r\\n```\\r\\nInput: [1,2,3]\\r\\nOutput:\\r\\n[\\r\\n  [1,2,3],\\r\\n  [1,3,2],\\r\\n  [2,1,3],\\r\\n  [2,3,1],\\r\\n  [3,1,2],\\r\\n  [3,2,1]\\r\\n]\\r\\n```\\r\\n\\r\\n#### Backtracking\\r\\n\\r\\n\"\n- abbrlink: xmbex2\n  title: Leetcode-51~55\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n    - n-queens\n    - backtrack\n  date: 2019-03-30T02:57:00.000Z\n  series: leetcode\n  char_count: 12505\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 51. N-Queens(Hard)\\r\\n\\r\\nThe *n*-queens puzzle is the problem of placing *n* queens on an *n*×*n* chessboard such that no two queens attack each other.\\r\\n\\r\\n\\r\\n\\r\\nGiven an integer *n*, return all distinct solutions to the *n*-queens puzzle.\\r\\n\\r\\nEach solution contains a distinct board configuration of the *n*-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space respectively.\\r\\n\\r\\n**Example:**\\r\\n\\r\\n```\\r\\nInput: 4\\r\\nOutput: [\\r\\n [\\\".Q..\\\",  // Solution 1\\r\\n  \\\"...Q\\\",\\r\\n  \\\"Q...\\\",\\r\\n  \\\"..Q.\\\"],\\r\\n\\r\\n [\\\"..Q.\\\",  // Solution 2\\r\\n```\\n\"\n- abbrlink: 1kv61wq\n  title: Leetcode-56~60\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n    - n-queens\n    - backtrack\n  date: 2019-03-30T13:16:00.000Z\n  series: leetcode\n  char_count: 7432\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 56.Merge Intervals(Medium)\\r\\n\\r\\nGiven a collection of intervals, merge all overlapping intervals.\\r\\n\\r\\n**Example 1:**\\r\\n\\r\\n```\\r\\nInput: [[1,3],[2,6],[8,10],[15,18]]\\r\\nOutput: [[1,6],[8,10],[15,18]]\\r\\nExplanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].\\r\\n```\\r\\n\\r\\n**Example 2:**\\r\\n\\r\\n```\\r\\nInput: [[1,4],[4,5]]\\r\\nOutput: [[1,5]]\\r\\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\\r\\n```\\r\\n\\r\\n\\r\\n\"\n- abbrlink: 1cu6q2d\n  title: Leetcode-61~65\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n  date: 2019-04-02T06:18:00.000Z\n  series: leetcode\n  char_count: 6088\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 61.Rotate List(Medium)\\r\\n\\r\\nGiven a linked list, rotate the list to the right by *k* places, where *k* is non-negative.\\r\\n\\r\\n**Example 1:**\\r\\n\\r\\n```\\r\\nInput: 1->2->3->4->5->NULL, k = 2\\r\\nOutput: 4->5->1->2->3->NULL\\r\\nExplanation:\\r\\nrotate 1 steps to the right: 5->1->2->3->4->NULL\\r\\nrotate 2 steps to the right: 4->5->1->2->3->NULL\\r\\n```\\r\\n\\r\\n**Example 2:**\\r\\n\\r\\n```\\r\\nInput: 0->1->2->NULL, k = 4\\r\\nOutput: 2->0->1->NULL\\r\\nExplanation:\\r\\nrotate 1 steps to the right: 2->0->1->NULL\\r\\n```\\n\"\n- abbrlink: z9pvg9\n  title: Leetcode-66~70\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n    - mysqrt\n    - binary-question\n  date: 2019-04-02T14:40:00.000Z\n  series: leetcode\n  char_count: 9155\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 66.Plus One(Easy)\\r\\n\\r\\nGiven a **non-empty** array of digits representing a non-negative integer, plus one to the integer.\\r\\n\\r\\nThe digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\\r\\n\\r\\nYou may assume the integer does not contain any leading zero, except the number 0 itself.\\r\\n\\r\\n**Example 1:**\\r\\n\\r\\n```\\r\\nInput: [1,2,3]\\r\\nOutput: [1,2,4]\\r\\nExplanation: The array represents the integer 123.\\r\\n```\\r\\n\\r\\n**Example 2:**\\r\\n\\r\\n```\\r\\nInput: [4,3,2,1]\\r\\nOutput: [4,3,2,2]\\r\\n```\\n\"\n- abbrlink: t1f0vq\n  title: Leetcode-6~10\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n  date: 2019-02-17T13:18:00.000Z\n  series: leetcode\n  char_count: 15033\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 6. ZigZag Conversion(Medium)\\r\\n\\r\\nThe string `\\\"PAYPALISHIRING\\\"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\\r\\n\\r\\n```\\r\\nP   A   H   N\\r\\nA P L S I I G\\r\\nY   I   R\\r\\n```\\r\\n\\r\\nAnd then read line by line: `\\\"PAHNAPLSIIGYIR\\\"`\\r\\n\\r\\nWrite the code that will take a string and make this conversion given a number of rows:\\r\\n\\r\\n```\\r\\nstring convert(string s, int numRows);\\r\\n```\\r\\n\\r\\n**Example 1:**\\r\\n\\r\\n```\\r\\n```\\n\"\n- abbrlink: i9becb\n  title: Leetcode-71~75\n  categories:\n    - note\n    - algorithm\n    - leetcode\n  tags:\n    - leetcode\n    - mysqrt\n    - binary-question\n  date: 2019-04-04T07:35:00.000Z\n  series: leetcode\n  char_count: 9315\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 71. SimplifyPath(Medium)\\r\\n\\r\\nGiven an **absolute path** for a file (Unix-style), simplify it. Or in other words, convert it to the **canonical path**.\\r\\n\\r\\nIn a UNIX-style file system, a period `.` refers to the current directory. Furthermore, a double period `..` moves the directory up a level. For more information, see: [Absolute path vs relative path in Linux/Unix](https://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/)\\r\\n\\r\\nNote that the returned canonical path must always begin with a slash `/`, and there must be only a single slash `/` between two directory names. The last directory name (if it exists) **must not** end with a trailing `/`. Also, the canonical path must be the **shortest** string representing the absolute path.\\r\\n\\r\\n \\r\\n\\r\\n**Example 1:**\\r\\n\\r\\n```\\r\\nInput: \\\"/home/\\\"\\r\\nOutput: \\\"/home\\\"\\r\\nExplanation: Note that there is no trailing slash after the last directory name.\\r\\n```\\r\\n\\r\\n**Example 2:**\\r\\n\\r\\n```\\r\\n```\\n\"\n- abbrlink: spovqu\n  title: Linux安装MySql\n  categories:\n    - reprinted\n  tags:\n    - mysql\n    - linux\n  date: 2018-05-03T16:05:01.000Z\n  char_count: 3302\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n# Linux安装MySql\\r\\n一位哲人说过，只会用 FTP 工具的人都是傻子。\\r\\n## 原料\\r\\n去 [Mysql官网](https://www.mysql.com/downloads/) 下载\\r\\nmysql-5.7.19-linux-glibc2.12x86_64.tar.gz。\\r\\n## 步骤\\r\\n- 上传至 /usr/local/\\r\\n- 解压、重命名\\r\\n```\\r\\ntar -xvz -f mysql-5.7.19-linuxglibc2.12x86_64.tar.gz\\r\\nmv /usr/local/mysql-5.7.19-linuxglibc2.12x86_64 /usr/local/mysql\\r\\n```\\r\\n此时 MySql 的位置在 /usr/local/mysql/\\r\\n- 更改mysql用户组,如果没有 mysql 用户和用户组，新建即可\\r\\n```\\r\\nchown mysql:mysql /usr/local/mysql/\\r\\n```\\r\\n这里要提一句，**Linux中有关于 MySql 的配置文件，最好都将文件所属用户和用户组设置为 mysql，因为在 MySql 启动时会读取或写入数据**。\\r\\n- 在 /usr/local/mysql/support-files 新建 my_default.cnf 默认配置文件（当然可以改），并添加默认配置，以下是我的 my_default.cnf 。\\r\\n```\\r\\n[mysqld]\\r\\n```\\n\"\n- abbrlink: nff3ic\n  title: Log4j2_Appenders\n  comments: true\n  tags:\n    - log4j2\n    - learning\n  categories:\n    - note\n    - toolslearning\n    - log4j2\n  date: 2017-11-17T16:37:18.000Z\n  series: Log4j2\n  char_count: 6218\n  short_contant: \"\\r\\n\\r\\n{% cq %}\\r\\n\\r\\n上篇介绍了使用Log4j2之前的准备工作和简单介绍了一个HelloWorld\\r\\n\\r\\n现在我们来了解配置中的第一个关键配置：Appenders\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n<!-- more -->\\r\\n\\r\\n官方文档给出的可用的Appender非常多：有Async（异步输出）、Console（控制台输出）、File（文件输出）、甚至还有JDBC和HTTP等24种输出源方式，然而我日常使用的就几个：Console、RollingFile；一个作为本地host调试的时候log，一个作为远程主机调试的时候写log。其他的我就不仔细去研究了。\\r\\n\\r\\n- - -\\r\\n\\r\\n### ConsoleAppender\\r\\n\\r\\n`ConsoleAppender`，使用的是`System.out`或者`System.err`作为输出源，把log打印在控制台上，默认的情况下使用的是`System.out`。\\r\\n\\r\\n``` xml\\r\\n<Console name=\\\"Console\\\" target=\\\"SYSTEM_OUT\\\">\\r\\n    <PatternLayout pattern=\\\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\\\"/>\\r\\n</Console>\\r\\n```\\r\\n\"\n- abbrlink: 3fjm8j\n  title: Log4j2_Filters\n  categories:\n    - note\n    - toolslearning\n    - log4j2\n  comments: true\n  tags:\n    - log4j2\n    - learning\n  date: 2017-12-09T12:41:20.000Z\n  series: Log4j2\n  char_count: 2496\n  short_contant: \"\\r\\n\\r\\n{% cq %}\\r\\n\\r\\nFilters：过滤你的日志信息\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n<!-- more -->\\r\\n\\r\\n### 重要概念\\r\\n\\r\\n#### 枚举值\\r\\n\\r\\nFilters可以用来对日志事件进行过滤，过滤器会返回一个枚举类型的值，枚举值包含三个：ACCEPT、DENY和NEUTRAL。\\r\\n\\r\\n- ACCEPT：时会跳过这一级别的其它过滤器,进入下个级别的过滤器；\\r\\n\\r\\n- DENY：时会直接终止事件的传递；\\r\\n\\r\\n- NEUTRAL：时会继续交给同级别的其它过滤器处理（若已经是同级别最后一个过滤器，那么将日志事件传递给下个级别）。\\r\\n\\r\\n#### 过滤位置\\r\\n\\r\\n可以在以下四个位置配置过滤器：\\r\\n\"\n- abbrlink: en4hhw\n  title: Log4j2_HelloWorld\n  tags:\n    - log4j2\n    - learning\n  categories:\n    - note\n    - toolslearning\n    - log4j2\n  comments: true\n  date: 2017-11-17T16:13:21.000Z\n  series: Log4j2\n  char_count: 3771\n  short_contant: \"\\r\\n\\r\\n{% cq %}\\r\\n\\r\\nLo4j2是啥就不解释了，之前无论是使用log4j还是log4j2，同样只是简单的各种百度然后复制粘贴没有系统的总结一下，今天把一个小小的Ajax的测试程序放服务器上面都不知道怎么查错，然后想写一下log来看看哪错了吧，发现还是不会独立配置log4j，于是想总结一波。基本的思路是总结官方文档和官方推荐的中文文档，尽量简洁表达出原理以及应用。\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n<!-- more -->\\r\\n\\r\\n- - -\\r\\n\\r\\n### 准备工作\\r\\n\\r\\n#### Maven依赖\\r\\n\\r\\n``` xml\\r\\n<dependencies>\\r\\n  <dependency>\\r\\n    <groupId>org.apache.logging.log4j</groupId>\\r\\n    <artifactId>log4j-api</artifactId>\\r\\n    <version>2.9.1</version>\\r\\n  </dependency>\\r\\n  <dependency>\\r\\n    <groupId>org.apache.logging.log4j</groupId>\\r\\n```\\n\"\n- abbrlink: yvgzwi\n  title: Log4j2_Layouts\n  categories:\n    - note\n    - toolslearning\n    - log4j2\n  comments: true\n  tags:\n    - log4j2\n    - learning\n  date: 2017-12-08T14:39:16.000Z\n  series: Log4j2\n  char_count: 1251\n  short_contant: \"\\r\\n\\r\\n{% cq %}\\r\\n\\r\\nLayout：定制你的输出模式\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n<!-- more -->\\r\\n\\r\\n[Layouts](https://logging.apache.org/log4j/2.x/manual/layouts.html)里提到了许多种Layout方式，我最常用的是PatternLayout。\\r\\n\\r\\n### Pattern Layout 模式输出\\r\\n\\r\\n是一种通过pattern字符串来配置的灵活的输出方式。\\r\\n\\r\\n属性：\\r\\n- charset：string：所使用的字符集\\r\\n- pattern：string：定制你的输出模式\\r\\n- header：string：这是一个可选项，它会包含在每个log文件的开头\\r\\n- footer：string：这是一个可选项....\\r\\n\\r\\n#### Patterns\\r\\n\\r\\n##### Logger Name模式\\r\\n\"\n- abbrlink: 3zxt7z\n  title: Log4j2_Lookups\n  categories:\n    - note\n    - toolslearning\n    - log4j2\n  comments: true\n  tags:\n    - log4j2\n    - learning\n  date: 2017-12-09T15:28:15.000Z\n  series: Log4j2\n  char_count: 1609\n  short_contant: \"\\r\\n\\r\\n{% cq %}\\r\\n\\r\\nLookups：让你的配置更灵活\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n<!-- more -->\\r\\n\\r\\n### Lookups\\r\\n\\r\\nLookups使得我们可以自由地在Log4j2配置文件中添加某些值（使用占位符设置变量），它们是一种特殊类型的插件，并且实现了StrLookup接口。\\r\\n\\r\\n#### ContextMap Lookup\\r\\n\\r\\nContextMapLookup使得我们可以在Log4j2的ThreadContext Map中保存值，并在Log4j2的配置文件中可以取得值。\\r\\n\\r\\n**引用方法：`$${ctx:KEY}`**\\r\\n\\r\\n代码中写：\\r\\n``` java\\r\\nThreadContext.put(\\\"aaa\\\", \\\"bbb\\\");\\r\\n```\\r\\n\\r\\n\"\n- abbrlink: 1k4djcz\n  title: RegExp_1_overview\n  tags:\n    - learning\n    - RegExp\n  categories:\n    - note\n    - booknote\n    - 《Mastering Regular Expression(Third Edition)》\n  comments: true\n  date: 2017-11-17T00:00:56.000Z\n  series: 《Mastering Regular Expression(Third Edition)》\n  char_count: 1332\n  short_contant: \"\\r\\n\\r\\n*引言：接触计算机编程以来，无数次碰到过这个名词“正则表达式”，刚开始肯定是不懂，但是听到“表达式”三个字就发现事情并不简单。*\\r\\n\\r\\n<!-- more -->\\r\\n\\r\\n*第一次接触到它还是在我进NTJ2EE的招新机试的时候，机试题有一道题：“有一个字符串，其中包含中文字符、英文字符和数字字符，请统计和打印出各个字符的个数。”，当时只会用取字符对照ascii的方法来做这道题，然后正好学长看了我的做法，他说还有种东西叫做“正则表达式”，然后他给我打开了在线的JDK-1.6的API，找到了里面介绍正则表达式的页，然后还百度了一篇正则表达式的教程给我看（对，就是那个通篇斜杠写反的那盘），然后我就头皮发麻了。*\\r\\n\\r\\n*在之后无论是正式学习还是运用到实际当中，我的处理都是：百度——ctrl+c——ctrl+v，然后下次碰到另一个字符串处理问题的时候还是这样做，毫无意义，甚至还不能完全匹配我的应用场景。然后这次的工程中心项目，我负责写前端，对输入框需要用到字符串过滤的需求，就这么简单的一个功能我都实现不了，感觉非常丢人，我不想再复制粘贴了，所以开始以blog的形式记录我学习`regular-expression`的过程。*\\r\\n\\r\\n**所有笔记的学习都基于：《Mastering Regular Expression(Third Edition)》——Jeffrey E. F. Friedl一书的中文版**\\r\\n\\r\\n- - -\\r\\n\\r\\n### 释义与场景\\r\\n\\r\\n#### 释义\\r\\n首先我们来看看`Regular Expression`这两个单词\\r\\n\\r\\nRegular：\\r\\n> *adj.* 定期的；有规律的；合格的；整齐的；普通的\\r\\n>\\r\\n> *n.* 常客；正式队员；中坚分子\\r\\n>\\r\\n> *adv.* 定期地；经常地\\r\\n\"\n- abbrlink: huiysg\n  title: RegExp_2_metacharacters\n  categories:\n    - note\n    - booknote\n    - 《Mastering Regular Expression(Third Edition)》\n  comments: true\n  tags:\n    - learning\n    - RegExp\n  date: 2017-11-17T00:02:06.000Z\n  series: 《Mastering Regular Expression(Third Edition)》\n  char_count: 2422\n  short_contant: \"\\r\\n\\r\\n{% cq %}\\r\\n\\r\\nMetacharacters：元字符\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n<!-- more -->\\r\\n\\r\\n### 元字符的解释\\r\\n\\r\\n完整的正则表达式由两种字符组成：\\r\\n- 特殊字符，即`元字符`，它们一般具有特殊的含义，并不匹配字面字符。\\r\\n- 文字，即普通`文本字符`，匹配的就是字面字符。\\r\\n\\r\\n- - -\\r\\n\\r\\n#### 行的起始和结束\\r\\n\\r\\n> `^` 脱字符号，在检查一行文本的时候，`^`代表一行的开始。\\r\\n\\r\\n> `$` 美元符号，在检查一行文本的时候，`$`代表一行的结束。\\r\\n\\r\\n- `^cat` ：表示匹配以cat开头的行，如categories\\r\\n\"\n- abbrlink: 1x7azit\n  title: Some Backtracking Problem In Leetcode\n  categories:\n    - note\n    - leetcode\n  tags:\n    - leetcode\n    - backtracking\n  date: 2019-03-24T08:26:00.000Z\n  char_count: 11255\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n在Leetcode上做到某些题的时候，会发现这些题的解法大致都是差不多，将**ans容器**传递到某个方法中，这个方法一般有`dfs`，`backtracking`，`bfs`，等命名，然后方法中会有递归调用，然后到达某一个出口的时候，就会将当前的**tmp答案**放置到**ans容器**中，于是达到探索所有解的目的\\r\\n\\r\\n这篇大概也是各个题的题解，只是在评论区里看到有人[整理](https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning))了，我就一起整理下来分析分析\\r\\n\\r\\n> This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum.\\r\\n\\r\\n\\r\\n\\r\\n### Subset\\r\\n\\r\\nGiven a set of **distinct** integers, *nums*, return all possible subsets (the power set).\\r\\n\\r\\n**Note:** The solution set must not contain duplicate subsets.\\r\\n\\r\\n**Example:**\\r\\n\\r\\n```\\r\\nInput: nums = [1,2,3]\\r\\nOutput:\\r\\n```\\n\"\n- abbrlink: 1gukab6\n  title: Tess login on Jenkins\n  categories:\n    - note\n    - eBay\n  tags:\n    - tess\n  date: 2018-11-16T14:10:08.000Z\n  char_count: 7042\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Tess login on Jenkins\\r\\n\\r\\n#### Use tess with Rheos tess-base agent\\r\\n\\r\\nAssume that you are at \\\"Job Configure\\\" panel now.\\r\\n\\r\\n##### Configure Agent\\r\\n\\r\\nIn order to use tess **effectively and legally**, we should check **\\\"Restrict where this project can be run\\\"** on **\\\"Job Notifications\\\"** and select `tess-builder-numsg`, this is a image for tess-user that build from ***Rheos team***, it prepared every thing we need for tess.\\r\\n\\r\\nThe configuration of this agent is at Jenkins: **[Manage Jenkins(系统管理)] -> [Configure System(系统设置)]->[Cloud(云)]->[Kubernetes]->[images]** , named **\\\"tess-builder-numsg\\\"**\\r\\n\\r\\n##### Configure \\\"Parameterized Build(参数化构建过程)\\\"\\r\\n\\r\\n###### For production cluster login\\r\\n\\r\\nWe will need four parameters: `tess_username`,` tess_cluster`, `tess_pin`, `tess_yubikey_token_twice`\\r\\n\\r\\n>  **Notice:** \\r\\n>\\r\\n> 1. If your want to use two **YubiKey Token**, you have to configure a **Multi-line String Parameter**, to catch two **YubiKey Token** on a **single parameter(`tess_yubikey_token_twice`)**. It will prevent **\\\"auto enter\\\"** to trigger the build action while we use YubiKey to input access token.\\r\\n\"\n- abbrlink: 46bhg0\n  title: The Revelation of Java String\n  categories:\n    - note\n    - thinking\n  tags:\n    - java-string\n    - string-pool\n  date: 2019-03-02T13:50:00.000Z\n  char_count: 13339\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\nJava中的`String`其实有很多东西可以深入的，比如最快拼接效率，比如常量池，比如老生常谈的`==`问题\\r\\n\\r\\n研究它们的时候我们始终要记住，`String`是不可变的**（immutable）**\\r\\n\\r\\n还有比如它的本质是一个`char[]`数组这些事实就简单带过了\\r\\n\\r\\n我们需要深入的是`String`的内存问题，既然它是一成不变的，有一个对象是一个对象，那么JVM是如何减少内存的开销的？以及它引申出的一系列内存问题\\r\\n\\r\\n而我想写这篇文章的引子，则是[Hollis前辈](https://github.com/hollischuang)的一篇：[为什么阿里巴巴不建议在for循环中使用\\\"+\\\"进行字符串拼接](https://mp.weixin.qq.com/s/Zs8en3T8TxCMbxGWHkDwBw?comefrom=http://blogread.cn/news/)\\r\\n\\r\\n### Constant Pool & Runtime Constant Pool\\r\\n\\r\\n关于常量池，它用于存放Java编译期生成的各种字面量和符号引用，于是每个Class文件都会有一个Constant Pool，具体的你可以通过`javap -v ClassName`一个类去看到；\\r\\n\\r\\n而在JVM装载class文件的时候，会读取Constant Pool里的内容到Runtime Constant Pool，而Runtime Constant Pool会在程序运行的时候动态产生新的常量；\\r\\n\\r\\n### Literal\\r\\n\\r\\n我们知道String有两种创建的方式：\\r\\n\"\n- abbrlink: 1nz9lo5\n  title: Tree Plan-1\n  categories:\n    - note\n    - algorithm\n  tags:\n    - algorithm\n    - binary-tree\n  date: 2019-01-28T15:11:00.000Z\n  char_count: 5460\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Should have a PLAN!\\r\\n\\r\\nI was asked a tree problem when I was having a face to face interview at *PayPal* last Friday, and I might failed on this question.\\r\\n\\r\\nIt's been too long that I'm almost forgot the knowledge of TREE, and I've never truly go over it and it's time to get it done.\\r\\n\\r\\nThe question:\\r\\n\\r\\n<pre class=\\\"nhi\\\">\\r\\nA tree like:                          Node structure:\\r\\n              5a &lt;-- root node             Node ┬ int  value\\r\\n            /   \\\\                               ├ Node left\\r\\n           5b    5c                             └ Node right\\r\\n          / \\\\     \\\\\\r\\n         6   5d    7a\\r\\n                  / \\\\\\r\\n                 5e  7b\\r\\nQuestion: \\r\\nA \\\"Group\\\" is defined as a set that it's Nodes have the same value and within \\r\\nthe relationship of Parent-Child. Find the number of group of provided tree.\\r\\ne.g：the tree above will have 4 groups [5a,5b,5c,5d],[6],[7a,7b],[5e]\\r\\n</pre>\\r\\n\"\n- abbrlink: 1vj2lew\n  title: Tree Plan-Binary Tree\n  categories:\n    - note\n    - algorithm\n  tags:\n    - algorithm\n    - binary-tree\n    - tree\n    - dfs\n    - bfs\n  date: 2019-01-30T21:36:20.000Z\n  char_count: 4610\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Basic Algorithm In Binary Tree\\r\\n\\r\\n#### Traverse\\r\\n\\r\\nA Tree is typically traversed in two ways:\\r\\n\\r\\n- Breadth First Traversal (Or Level Order Traversal)\\r\\n- Depth First Traversals\\r\\n    - Inorder Traversal (Left-Root-Right)\\r\\n    - Preorder Traversal (Root-Left-Right)\\r\\n    - Postorder Traversal (Left-Right-Root)\\r\\n\\r\\n```\\r\\n            1\\r\\n          /   \\\\\\r\\n         2     3\\r\\n       /  \\\\\\r\\n      4    5\\r\\n\\r\\nBFS and DFSs of above Tree\\r\\nBreadth First Traversal : 1 2 3 4 5\\r\\n```\\n\"\n- abbrlink: 1w97yet\n  title: Understanding the nodejs' event loop\n  categories:\n    - reprinted\n  tags:\n    - nodejs\n  date: 2019-10-02T15:47:20.000Z\n  char_count: 6790\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n> 转载自：http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/\\r\\n\\r\\n### Understanding the nodejs' event loop\\r\\n\\r\\nThe first basic thesis of node.js is that I/O is expensive:\\r\\n\\r\\n\\r\\n\\r\\nSo the largest waste with current programming technologies comes from waiting for I/O to complete. There are several ways in which one can deal with the performance impact (from [Sam Rushing](http://www.nightmare.com/medusa/async_sockets.html)):\\r\\n\\r\\n- **synchronous**: you handle one request at a time, each in turn. *pros*: simple *cons*: any one request can hold up all the other requests\\r\\n- **fork a new process**: you start a new process to handle each request. *pros*: easy *cons*: does not scale well, hundreds of connections means hundreds of processes. fork() is the Unix programmer's hammer. Because it's available, every problem looks like a nail. It's usually overkill\\r\\n- **threads**: start a new thread to handle each request. *pros*: easy, and kinder to the kernel than using fork, since threads usually have much less overhead *cons*: your machine may not have threads, and threaded programming can get very complicated very fast, with worries about controlling access to shared resources.\\r\\n\\r\\nThe second basis thesis is that thread-per-connection is memory-expensive: [e.g. that graph everyone showns about Apache sucking up memory compared to Nginx]\\r\\n\\r\\nApache is multithreaded: it spawns a [thread per request](http://httpd.apache.org/docs/2.0/mod/worker.html) (or [process](http://httpd.apache.org/docs/2.0/mod/prefork.html), it depends on the conf). You can see how that overhead eats up memory as the number of concurrent connections increases and more threads are needed to serve multiple simulataneous clients. Nginx and Node.js are not multithreaded, because threads and processes carry a heavy memory cost. They are single-threaded, but event-based. This eliminates the overhead created by thousands of threads/processes by handling many connections in a single thread.\\r\\n\\r\\n### **Node.js keeps a single thread for your code...**\\r\\n\"\n- abbrlink: rku8jh\n  title: 从头到尾读ArrayList\n  categories:\n    - thinking\n    - 从头到尾读系列\n  comments: true\n  date: 2018-06-05T08:31:21.000Z\n  tags:\n    - arraylist\n    - collections-framework\n  series: 从头到尾读\n  char_count: 16208\n  short_contant: \"\\r\\n\\r\\n#### ArrayList类\\r\\n\\r\\n对终于要正式开始读**ArrayList**的源码了，虽然**ArrayList**的源码价值并不是那么地大，但作为集合框架源码阅读的第一站来说，我选择了在这里站稳脚跟\\r\\n\\r\\n这个计划搁置了很久，大概有15天，中间跑去面试了一个星期，面试下来发现自己的基础已经忘的差不多了，决定回来好好沉淀一段时间，暑期实习offer有没有已经不重要了，**剑指秋招！**\\r\\n\\r\\n为什么要读它，因为线性表几乎是数据结构的基础必备，昨晚花了将近1小时手撸了一个ArrayList的自实现，再搭配源码来看**自己在基础方法上有哪些没考虑到的点**，以及**实际投入使用的ArrayList到底优秀在哪里**\\r\\n\\r\\n#### 源码\\r\\n\\r\\n##### 类头\\r\\n\\r\\n``` java\\r\\npublic class ArrayList<E> extends AbstractList<E>\\r\\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\\r\\n{\\r\\n\\t//...\\r\\n}\\r\\n```\\r\\n\\r\\n首先继承了`AbstractList`\\r\\n\\r\\n我们顺着`AbstractList`往里摸，一直到最后我们发现，还有**Collection接口和Iterable接口**，这两个接口加上**List接口**为我们提供了非常重要的集合接口规范\\r\\n\"\n- abbrlink: faxga5\n  title: 从头到尾读Collection\n  categories:\n    - thinking\n    - 从头到尾读系列\n  comments: true\n  date: 2018-05-15T17:17:26.000Z\n  tags:\n    - collection\n    - collections-framework\n  series: 从头到尾读\n  char_count: 4924\n  short_contant: \"\\r\\n\\r\\n### Collection接口\\r\\n\\r\\n### 源代码解读\\r\\n\\r\\n#### 头部\\r\\n\\r\\n``` java\\r\\npublic interface Collection<E> extends Iterable<E> {\\r\\n  //...\\r\\n}\\r\\n```\\r\\n头部继承了`Iterable<E>`接口, 对, 这里要注意是extends一个接口, 为什么是extends, 我们去看`Iterable<E>`接口里到底有啥, [跳转文章](https://youyinnn.github.io/?to=post&number=44).\\r\\n\\r\\n所以我们知道, Collection继承了这个`接口`就代表着它拥有了容器内元素可迭代访问的功能.\\r\\n\\r\\n#### 方法\\r\\n\\r\\n##### 查询操作 Query Operations\\r\\n\\r\\n###### size()方法\\r\\n\\r\\n``` java\\r\\n    /**\\r\\n```\\n\"\n- abbrlink: 1kakozs\n  title: 从头到尾读Iterable与Iterator\n  categories:\n    - thinking\n    - 从头到尾读系列\n  comments: true\n  date: 2018-05-15T17:22:14.000Z\n  tags:\n    - iterable\n    - iterator\n    - collections-framework\n  series: 从头到尾读\n  char_count: 2521\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Iterable接口\\r\\n\\r\\n含义: 这个接口的含义是, 容器的元素是否支持**迭代器**访问\\r\\n\\r\\n#### 源码\\r\\n\\r\\n``` java\\r\\n/**\\r\\n * 实现这个接口, 意味着对象可以使用forEach循环进行操作\\r\\n */\\r\\npublic interface Iterable<T> {\\r\\n    /**\\r\\n     * 返回一个迭代器\\r\\n     */\\r\\n    Iterator<T> iterator();\\r\\n\\r\\n    /**\\r\\n     * (1)和lambda有关, 执行这个方法等效于\\r\\n     *  for (E element : collection) {\\r\\n     *      //对e进行每一个action操作\\r\\n     *  }\\r\\n```\\n\"\n- abbrlink: jhpq7e\n  title: 关于JVM的GC行为和内存分配\n  categories:\n    - note\n    - booknote\n    - 深入理解Java虚拟机\n  comments: true\n  date: 2018-11-17T15:35:00.000Z\n  tags:\n    - jvm\n    - generation-type\n    - gc\n    - gc算法\n    - root-point\n    - saft-point\n    - safe-area\n  series: JVM\n  char_count: 6639\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 对象分代和朝生夕灭\\r\\n\\r\\n对象所在的内存区按照对象存活的时间长久会简单分为：新生代、老年代\\r\\n\\r\\n**Garbage Collector**的行为和对象内存所在的区域有很大关系，所以在分析**Collector**之前，我们得先了解一下对象内存的分区\\r\\n\\r\\n我们需要清楚的是，Java中**98%**的对象都是**朝生夕灭**的，所以新生代区往往是GC要重点照顾的区域\\r\\n\\r\\n这是书上提到的，也是我们容易想象得到的，书上P92页还提到**两种**GC事件（实际上是三种）\\r\\n\\r\\n按照GC位置的不同，我们先讲GC的事件分为：\\r\\n\\r\\n- **Minor GC：**即发生在新生代的GC，这部分的GC速度很快，但是在GC之前，会检查一下**空间分配担保**\\r\\n- **Major GC/Full GC：**发生在老年代的GC，一般至少伴随着一次Minor GC，因为回收的是老年代，回收策略比较严谨，所以Major GC的速度会非常慢\\r\\n\\r\\n> **空间分配担保**：\\r\\n>\\r\\n> 在**Minor GC**之前，虚拟机会检查老年代**最大可用连续空间**，是否能够容纳下新生代区的所有对象：\\r\\n>\\r\\n> - 若可以：则代表这次GC是安全的\\r\\n> - 若不可：则需要检查是否设置了允许**担保失败**：\\r\\n\"\n- abbrlink: 18669ga\n  title: 关于JVM的对象创建与访问\n  categories:\n    - note\n    - booknote\n    - 深入理解Java虚拟机\n  comments: true\n  date: 2018-11-14T21:45:00.000Z\n  tags:\n    - jvm\n    - jvm对象创建\n  series: JVM\n  char_count: 3149\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### HotSpot虚拟机对象内存\\r\\n\\r\\n深入讨论HotSpot虚拟机在Java堆中的对象分配、内存布局和对象访问的过程\\r\\n\\r\\n#### 对象创建流程\\r\\n\\r\\n##### 过程\\r\\n\\r\\n1. **加载类**\\r\\n\\r\\n    当虚拟机遇到一个**new指令**的时候，就会检查指令参数是否能在常量池中定位到一个类的符号引用，并坚持这个符号代表的类是否已经被加载、解析和初始化过，如果没有，则需要必须进行类加载过程\\r\\n\\r\\n    在类加载的过程完成后，**对象所需的内存大小已经完全可以确定**\\r\\n\\r\\n2. **选择内存分配算法**\\r\\n\\r\\n- **指针碰撞（Bump the Pointer）**\\r\\n\\r\\n    假设**Java堆的内存是绝对规整**，即所有**用过的内存放一边**，**空闲的内存放另一边**，中间有一个指针作为**分界点**，此时对象内存分配仅是把指针向**空闲方向**挪动**一个对象内存的距离**\\r\\n\\r\\n- **空闲列表（Free List）**\\r\\n\"\n- abbrlink: rikltc\n  title: 关于JVM的运行时数据区\n  categories:\n    - note\n    - booknote\n    - 深入理解Java虚拟机\n  comments: true\n  date: 2018-06-02T22:48:00.000Z\n  tags:\n    - jvm\n    - 运行时数据区\n  series: JVM\n  char_count: 3174\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 前言\\r\\n\\r\\n本书第二版为止，其实还是针对于Java SE 7 Specification（后简称Spec），然而到了Java8，情况又有很大的不同，比如最出名的Permanent Generation，就在8中被HotSpot虚拟机移除掉了，所以这一系列的文章，我后续还需要慢慢地研究和重写\\r\\n\\r\\n然后是一篇关于Java SE 7 Spec的[好文](http://blog.jamesdbloom.com/JVMInternals.html#threads)\\r\\n\\r\\n### JVM运行时数据区\\r\\n\\r\\n基本上整个第二章说的都是**运行时数据取区**,，Java虚拟机在执行Java程序的时候,，会把它所管理的内存划分为若干个不同的数据区域\\r\\n\\r\\n这些数据区域有**各自的用途**以及**各自的生命周期**(创建和销毁策略)\\r\\n\\r\\n\\r\\n\\r\\n我们得特别注意，这里我们再将**JVM的运行时数据区**划分为：**线程共享数据区**，**线程私有数据区**\\r\\n\\r\\n\\r\\n\\r\\n#### 1. 程序计数器（PCR）\\r\\n\\r\\n##### 作用\\r\\n\"\n- abbrlink: d5ykz8\n  title: 关于JVM的运行时数据区上的GC\n  categories:\n    - note\n    - booknote\n    - 深入理解Java虚拟机\n  comments: true\n  date: 2018-11-14T22:45:00.000Z\n  tags:\n    - jvm\n    - gc\n    - reference-type\n    - finalize\n  series: JVM\n  char_count: 2883\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n本篇主要介绍什么是GC，GC一般发生在哪里，GC在这些地方都干些什么\\r\\n\\r\\n顺带简单提一下四种**引用类型**以及`finalize()`方法\\r\\n\\r\\n\\r\\n\\r\\n### About Garbage Collection\\r\\n\\r\\n你已经是一个成熟的JVM了，应该自己学会智能GC了\\r\\n\\r\\n> 说起GC，很多人把这项技术当作Java语言的伴生产物。事实上，GC的历史比Java更久远，1960年诞生于MIT的Lisp语言是第一门真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期的时候，人们就在思考GC需要完成的事情：\\r\\n>\\r\\n> - 哪些内存需要回收？\\r\\n> - 什么时候回收？\\r\\n> - 如何回收？\\r\\n>\\r\\n> 经过半个多世纪的发展，目前内存的动态分配和内存回收技术已经非常成熟了，一切看起来都进入了“自动化”时代，那我们为什么还要去了解GC和内存分配呢？——当需要排查各种内存溢出、内存泄漏问题的时候，当垃圾收集称为系统达到**更高并发量**的瓶颈的时候，我们就需要对这些自动化的技术实施必要的监控和调节。\\r\\n\\r\\n我们前面知道了JVM的内存区域会分成：Java堆、方法区、栈（本地方法栈、虚拟机栈）、程序计数器，我们一个一个来看\\r\\n\"\n- abbrlink: wlvrl9\n  title: 再谈对象分代和GC事件\n  categories:\n    - note\n    - thinking\n    - GC\n  tags:\n    - gc\n    - gc-event\n    - generation-type\n  date: 2019-03-18T20:46:00.000Z\n  char_count: 2517\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n之前在搜OOM的时候，无意中发现了[https://plumbr.io/](https://plumbr.io/)这个网站，它们的产品就是做内存监控工具之类的，于是官网上也有很多关于JVM的GC方面的技术博客，简直和挖到宝藏了一样- -\\r\\n\\r\\n本篇主要是针对对象在堆上的分代和GC事件再做一些细致的了解，主要也是参考网站里的内容\\r\\n\\r\\n### Object Generation\\r\\n\\r\\n从我们熟悉的开始，堆内存大致可以分为三个区域，Young——新生代、Turned——老年代、PermGen——永久代\\r\\n\\r\\n其中新生代里又默认以8：1：1分为Eden：Survivor：Survivor\\r\\n\\r\\n\\r\\n\\r\\n#### Eden\\r\\n\\r\\n在以前一篇[关于JVM的对象创建与访问](https://youyinnn.github.io/?to=post&number=70)里提到过的TLAB（Thead Local Allocatipn Buffer），它主要用于解决对象分配的时候需要先划定一些内存空间，一个内存空间仅允许一个线程进行操作，这样就可以避免用同步的**高耗时**代价去保证对象分配的正常进行\\r\\n\\r\\n于是Eden空间进一步划分一个或者多个TLAB区域，并且保留一块公共区域，当TLAB空间不够分配对象的时候，会选择到公共区域继续分配，如果这里也没有空间了的话，那就会出发一次年轻代的GC，也就是**Minor GC**\\r\\n\\r\\n这里有个GC的细节，也是之前没提到过的，我们说GC的基本操作是，扫描引用链，然后清除掉和根引用无关的对象，但是我们需要知道，对象之间的引用是可以跨代的，比如新生代对象可以挂在老年代对象上，所以一次直白的**Reachability Analysis**，可能会跨代进行\\r\\n\"\n- abbrlink: 1xetsy3\n  title: 写在21岁的最后一天\n  categories:\n    - 随笔\n  date: 2018-11-17T15:53:00.000Z\n  char_count: 3599\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n#### 0. 特定的时刻\\r\\n\\r\\n我是完全不过生日的, 不要礼物不要钱, 不请朋友大鱼大肉也不买蛋糕许愿望更不拉帮结派开party, 过生日我只会想家人想妈妈\\r\\n\\r\\n但是今年这个生日有点特殊吧\\r\\n\\r\\n不知道什么时候在哪里听到过一句话, 说**人生可以分成7年7年的组合去过, 每次都把7年当成一辈子去过**\\r\\n\\r\\n**你要认真地, 过好每一个7年, 过好每一辈子**\\r\\n\\r\\n所以在第3个7年的最后一天要结束的时候, 想把时间往前推7年, 看看我这第一个重要的7年过的到底怎么样\\r\\n\\r\\n但是- -\\r\\n\\r\\n记性不太好, 差不多只能回忆近况吧\\r\\n\\r\\n#### 1. 上海eBay\\r\\n\\r\\n现在是18年11月, 离开武汉来魔都已经一个多月了, 现在的状态很舒适和安逸, 但是也**太过于舒适和安逸**了\\r\\n\\r\\n:right_anger_bubble: 500强公司的Intern, 310一天的工资, 租的复式小阁楼房子, 一室一厅独卫空调电视, 十一期间该买的都买了, 房子置办的温馨又懒惰:cat2:\\r\\n\"\n- abbrlink: nr7s9o\n  title: 初探Java8之lambda\n  categories:\n    - thinking\n  comments: true\n  date: 2018-05-15T10:05:00.000Z\n  tags:\n    - java8\n    - lambda\n  char_count: 6344\n  short_contant: \"\\r\\n\\r\\n{% cq %}\\r\\n\\r\\n本文从为知笔记迁移过来, 本文的写作时间是 : 2016/10/17 下午12:28:14, 两年前的文章, 言语难免幼稚, 思维难免浅显, 多多包含.\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n### 引例\\r\\n\\r\\n``` java\\r\\n    List<Integer> intlist = new ArrayList<Integer>();\\r\\n\\r\\n    intlist.add(1);\\r\\n    intlist.add(2);\\r\\n    intlist.add(3);\\r\\n\\r\\n    intlist.forEach((num)->System.out.println(num));\\r\\n```\\r\\n​\\r\\n这里就有一个疑问：ArrayList为什么会有一个forEach()函数，而且传进去的变量是这样的形式？\\r\\n\\r\\n于是我向上找了`forEach()`方法的源码，发现这个方法是被定义在 \\_ `Iterable`接口里面的，接口里面为什么能定义方法？\\r\\n\\r\\n``` java\\r\\n```\\n\"\n- abbrlink: 1bhsyh3\n  title: 初探Java8之方法引用\n  categories:\n    - thinking\n  comments: true\n  date: 2018-05-15T10:40:00.000Z\n  tags:\n    - java8\n    - 方法引用\n  char_count: 3977\n  short_contant: \"\\r\\n\\r\\n{% cq %}\\r\\n\\r\\n本文从为知笔记迁移过来, 本文的写作时间是 : 2016/10/18 下午1:41:28, 两年前的文章, 言语难免幼稚, 思维难免浅显, 多多包含.\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n > 在学习这个东西的时候，找了很多资料，网上说的也都很笼统，找不到一个比较容易上手的例子，直到我看到一篇文章，作者在整体讲述Java5-8的新特性，其中讲完Java8的lambda表达式之后，马上就讲方法引用这个特性，我才更加清楚的意识到，方法引用其实是比lambda更加简洁的一个语法糖（不知道我这样理解对不对），但是，常识告诉我们，越简单的技术，限制条件就越多，为什么网上的关于方法引用的讲解都很散，因为方法引用的使用条件有点多。\\r\\n\\r\\n根据这篇文章，我又自己写了一个例子，来说明为什么方法引用可以是一个更加简洁的lambda：\\r\\n\\r\\n#### 引例\\r\\n\\r\\n``` java\\r\\npublic class methodReferences {\\r\\n    \\r\\n    //标准FI\\r\\n    interface methodReferencesFI{\\r\\n        List<String> toList(String[] string);\\r\\n    }\\r\\n    \\r\\n    public static void main(String[] args) {\\r\\n        \\r\\n        //lambda登场，这时候干了哪两件事？\\r\\n```\\n\"\n- abbrlink: 188zp6j\n  title: 地痞（DP）成长记\n  categories:\n    - note\n    - algorithm\n  comments: true\n  tags:\n    - algorithm\n    - dp\n  date: 2018-08-30T20:58:01.000Z\n  char_count: 20222\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 大声BB\\r\\n\\r\\n为了以后看到一道我知道是用DP但是不知道如何去DP的问题再也不会束手无策\\r\\n\\r\\n决心做一个地痞，至少下次看到一个DP不会再被它DP\\r\\n\\r\\n-------------------\\r\\n\\r\\n### 什么是DP？\\r\\n\\r\\n动态规划（Dynamic Programming），最初并不是应用于计算机科学当中，而是一种数学方法，在20世纪50年代初由美国数学家*Richard Bellman*发明，意图用来求解某类最优问题。\\r\\n\\r\\n在DP的思想当中：如果问题是由交叠的子问题构成的，我们就可以用DP去解决这个问题。一般这样的子问题出现在对给定问题的求解**递推关系**中，这个**递推关系**中包含了相同类型的更小子问题的解**（已经解出来了的）**。\\r\\n\\r\\nDP建议我们，与其对交叠子问题一次次的求解，还不如将每个子问题的解记录在**一张表**中，这样就可以在表中直接得到原始问题的解。\\r\\n\\r\\n### DP怎么操作？\\r\\n\\r\\n#### 斐波那契引例\\r\\n\\r\\n我们先来看一个斐波那契数列第n个数是多少的例子，寻常**递归解法**：\\r\\n\"\n- abbrlink: 1w60zyo\n  title: 字符编码笔记\n  categories:\n    - reprinted\n  tags:\n    - encoding\n  date: 2020-02-14T19:34:01.000Z\n  char_count: 21650\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n想来想去终于决定写一个关于计算机字符编码的笔记了( 应该说终于愿意去学了..(๑•ᴗ•๑)), 原本的目的只是搞清楚Unicode的, 考虑到字符编码问题是一个有趣, 在开发中经常会遇到并且稍微有点麻烦和棘手的问题, 但是在网络上却很难找到将这个说的比较细致和成体系的文章, 所以我决定倾尽精力去写这篇笔记, 我会尽量的去查资料和参考他人的文章和博客, 将关于计算机编码的问题捣鼓清楚.\\r\\n\\r\\n在笔记的后半部分, 我也会针对Python3的Unicode做一些说明, 并且当说到Unicode的时候, 我会尝试说明一些关于UTF-8 with BOM在Linux/Unix内核中的一些矛盾.\\r\\n\\r\\n**关于我搜寻和参考的资料, 都会贴在文章的最后.**\\r\\n\\r\\n> 这个世界上没有纯文本, 如果你想要读出它, 就要知道它的编码.\\r\\n\\r\\n\\r\\n\\r\\n# 基本概念\\r\\n\\r\\n首先我们要说明一些关于字符编码的基本概念, 有了这些概念的理解阅读后面的内容才不费劲~. 由于我默认将文章的受众定位成了有计算机科学基础的学生, 所以最基本的概念就直接一笔带过了.\\r\\n\\r\\n## 位\\r\\n\\r\\n就是我们熟知的比特(Bit), 也是二进制位, 因此有0和1两个值. Bit是`Binary digit`的缩写.\\r\\n\\r\\n是计算机用来表示信息的最小单位.\\r\\n\\r\\n## 字节, 字, 字长\\r\\n\"\n- abbrlink: djlqql\n  title: 字节跳动2019-03-16后端笔试\n  categories:\n    - note\n    - algorithm\n  tags:\n    - 笔试\n  date: 2019-03-16T22:22:00.000Z\n  char_count: 6582\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n就A了签到题，我觉得这次笔试很简单了，可是后面3题没过一个case，题目不难，各种各样的失误8，说到底菜才是原罪，还是得多刷题\\r\\n\\r\\n和leecode不一样的是：\\r\\n\\r\\n- **阅读理解**很重要，这次读题特别耽误；\\r\\n- 多条件真的不要怕，一步一步地**组合条件**；\\r\\n\\r\\n### Q1 Z国硬币找零\\r\\n\\r\\n\\r\\n>  z国4种硬币，面值1、16、64、1024，小明用1024买东西，求找出的最小硬币数。\\r\\n>\\r\\n>  如买200，找824，可找12枚64、3枚16、2枚4\\r\\n>  输入200，输出17\\r\\n\\r\\n\\r\\n``` java\\r\\npublic static void main(String[] args) {\\r\\n    Scanner in = new Scanner(System.in);\\r\\n```\\n\"\n- abbrlink: 14k0uek\n  title: 对持续集成(CI)的一些理解\n  tags:\n    - CI\n  categories:\n    - thinking\n  date: 2018-05-08T15:53:01.000Z\n  char_count: 1467\n  short_contant: \"\\r\\n\\r\\n### 什么是CI\\r\\n\\r\\n**持续集成（Continuous integration）** 不是什么新概念\\r\\n\\r\\n> _持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。_\\r\\n\\r\\n以上引自百度百科的定义。\\r\\n\\r\\n通俗来说，持续集成的操作很明确，我可以根据自己的实际开发经验，而分别从两个层次去说明：\\r\\n\\r\\n#### 小层次\\r\\n\\r\\n首先我们得有一个前提，软件组中的一个小组在开发一个模块，这个模块由若干名成员开发，模块的成品标准已经定义好，模块也已经开发好第一版基础版，即可以投入小范围使用的版本，我们称这个版本为**主模块版本**。\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n现在我们需要对这个模块进行改良和升级，假设为**Module-A**，我们对这此升级定好几个方向和目标，假设有**Module-A-1、Module-A-2、Module-A-3…Module-A-n**，每个成员负责一个小模块或者一个小目标**Module-A-k**，当成员完成小模块**Module-A-k**之后，就把小模块和小组开发的**主模块版本**进行**合并与测试**，**如果测试通过**，则合并的结果直接进行**发布**，并将这个结果更新为当前的**主模块版本**，而不用等待整体的**Module-A**的其他子任务完成之后，统一整合再发布。\\r\\n\\r\\n\\r\\n\\r\\n#### 大层次\\r\\n\\r\\n\"\n- abbrlink: pjff39\n  title: 微服务架构理论基础-康威定律\n  categories:\n    - reprinted\n  date: 2018-11-06T10:44:01.000Z\n  char_count: 7156\n  short_contant: \"\\r\\n\\r\\n### 前言\\r\\n\\r\\n> 可能出乎很多人意料之外的一个事实是，微服务很多核心理念其实在半个世纪前的一篇文章中就被阐述过了，而且这篇文章中的很多论点在软件开发飞速发展的这半个世纪中竟然一再被验证，这就是康威定律。\\r\\n\\r\\n### 概述\\r\\n\\r\\n微服务是最近非常火热的新概念，大家都在追，也都觉得很对，但是似乎没有很充足的理论基础说明这是正确的，给人的感觉是 **不明觉厉** 。前段时间看了Mike Amundsen [《远距离条件下的康威定律——分布式世界中实现团队构建》](http://www.infoq.com/cn/presentations/team-building-implementation-in-distributed-world)（是Design RESTful API的作者）在InfoQ上的一个分享，觉得很有帮助，结合自己的一些思考，整理了该演讲的内容。\\r\\n\\r\\n可能出乎很多人意料之外的一个事实是，微服务很多核心理念其实在半个世纪前的一篇文章中就被阐述过了，而且这篇文章中的很多论点在软件开发飞速发展的这半个世纪中竟然一再被验证，这就是[康威定律（Conway's Law）](http://www.melconway.com/Home/Conways_Law.html)。\\r\\n\\r\\n\\r\\n\\r\\n在康威的这篇文章中，最有名的一句话就是：\\r\\n\\r\\n> Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. - Melvin Conway(1967)\\r\\n\\r\\n中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。看看下面的图片（来源于互联网，侵删），再想想Apple的产品、微软的产品设计，就能形象生动的理解这句话。\\r\\n\\r\\n\\r\\n用通俗的说法就是：组织形式等同系统设计。\\r\\n\\r\\n这里的系统按原作者的意思并不局限于软件系统。据说这篇文章最初投的哈佛商业评论，结果程序员屌丝的文章不入商业人士的法眼，无情被拒，康威就投到了一个编程相关的杂志，所以被误解为是针对软件开发的。最初这篇文章显然不敢自称定律（law），只是描述了作者自己的发现和总结。后来，在Brooks Law著名的人月神话中，引用这个论点，并将其“吹捧”成了现在我们熟知“康威定律”。\\r\\n\\r\\n\"\n- abbrlink: 1kb6gry\n  title: 微服务（Microservice）那点事\n  categories:\n    - reprinted\n  date: 2018-11-06T10:21:00.000Z\n  char_count: 7992\n  short_contant: \"\\r\\n\\r\\n### 前言\\r\\n\\r\\n> 微服务架构被提出很短的时间内，就被越来越多的开发人员推崇，简单来说其主要的目的是有效的拆分应用，实现敏捷开发和部署 。\\r\\n>\\r\\n> 本分享即尝试介绍微服务架构的一些实施细节和要求，探询微服务架构的由来，并最终提供我们团队内部的一些实践总结，希望对大家有帮助。\\r\\n\\r\\n### WHAT - 什么是微服务\\r\\n\\r\\n#### 微服务简介\\r\\n\\r\\n这次参加JavaOne2015最大的困难就是听Microservice相关的session，无论内容多么水，只要题目带microservice，必定报不上名，可见Microservice有多火。最喜欢其中一页。关于这个典故，可以参考[this](\\r\\n<http://knowyourmeme.com/memes/you-keep-using-that-word-i-do-not-think-it-means-what-you-think-it-means)，此图适用于一切高大上的名字——技术有SOA，Agile，CLOUD，DevOps等等，古代有道，气，八卦等等。此类名词的最大特点就是 **一解释就懂，一问就不知，一讨论就打架。** \\r\\n\\r\\n\\r\\n微服务的流行，Martin功不可没，这老头也是个奇人，特别擅长抽象归纳和制造概念，我觉的这就是最牛逼的markting啊，感觉这也是目前国人欠缺的能力。\\r\\n\\r\\n> Martin Fowler是国际著名的OO专家，敏捷开发方法的创始人之一，现为ThoughtWorks公司的首席科学家.福勒（Martin Fowler），在面向对象分析设计、UML、模式、软件开发方法学、XP、重构等方面，都是世界顶级的专家，现为Thought Works公司的首席科学家。Thought Works是一家从事企业应用开发和集成的公司。早在20世纪80年代，Fowler就是使用对象技术构建多层企业应用的倡导者，他著有几本经典书籍：《企业应用架构模式》、《UML精粹》和《重构》等。—— 百度百科\\r\\n\\r\\n先来看看传统的web开发方式，通过对比比较容易理解什么是Microservice Architecture。和Microservice相对应的，这种方式一般被称为Monolithic（比较难传神的翻译）。所有的功能打包在一个WAR包里，基本没有外部依赖（除了容器），部署在一个JEE容器（Tomcat，JBoss，WebLogic）里，包含了DO/DAO，Service，UI等所有逻辑。\\r\\n\\r\\n\\r\\nMonolithic比较适合小项目，优点是：\\r\\n\\r\\n\"\n- abbrlink: a9wle2\n  title: 我认为的规范的git commit msg\n  top: true\n  categories:\n    - thinking\n  comments: true\n  tags:\n    - tips\n    - github\n    - git\n  date: 2017-11-29T18:30:01.000Z\n  char_count: 2786\n  short_contant: \"\\r\\n\\r\\n{% cq %}\\r\\n\\r\\n其实必要的时候使用`git commit -m \\\"xxxxx\\\"`也木有关系 但你也别每条都这样写\\r\\n\\r\\n{% endcq %}\\r\\n\\r\\n<!-- more -->\\r\\n\\r\\n好久没更博了，最近一直在疯狂的推[数据快速导入](https://github.com/DomBro96/dataimport)的项目，推的使用在使用git做一些fix和optimize等工作，经常会进行版本回退和msg查阅，看看我昨天晚上到底干了些什么。\\r\\n\\r\\n然后发现我特么看不懂前一天晚上写的什么鬼msg，这时候才觉得，有一个良好的commit习惯是多么重要！\\r\\n\\r\\n之前有转过一篇：[5 Useful Tips For A Better Commit Message](https://youyinnn.github.io/post/ce7091ac.html)\\r\\n\\r\\n按照这篇文章，我自己给我自己的commit msg做个规范。\\r\\n\\r\\n### 第一行\\r\\n使用规定的标识符表明当次commit一共做了哪些工作,不同的提示符使用空格` `分隔，提示符规定如下（持续补充）：\\r\\n\\r\\n我把一次工作的标识符分“动作”、“对象”两部分描述：\\r\\n\\r\\n* 可能的动作前缀有：\\r\\n  - 基本操作前缀：\\r\\n\"\n- abbrlink: ofa68o\n  title: 把HashMap安排得明明白白\n  categories:\n    - thinking\n    - 从头到尾读系列\n  comments: true\n  date: 2018-08-16T12:12:21.000Z\n  tags:\n    - hashmap\n    - collections-framework\n  series: 从头到尾读\n  char_count: 23275\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 前言\\r\\n\\r\\n一言难尽 直接开始吧 时间有限 就不一一解读接口了\\r\\n\\r\\n这篇是逐行级别的`HashMap`的**“基础操作”**源码解读，仅仅分析一些核心的**单元素基础操作（CRUD）**，尽可能从大框架思路去分析实现思路，一些太细的变量和无关操作，就不分析太多了\\r\\n\\r\\n本篇因为时间和精力有限，也跳过了一些很底层的分析如hash计算，比特位计算等，网上还有好多大神对于这个分析的比我好得多\\r\\n\\r\\n**多元素操作如`putAll`**以及一些克隆和序列化的操作的话，就不分析了\\r\\n\\r\\n开篇即是对于作者实现笔记的解读，你可能觉得就是一篇源码英文翻译，但是到后面到了方法的时候，每行都是根据自己的理解去解读的，如果您有其他的看法，可以留言讨论。\\r\\n\\r\\n---------------------\\r\\n\\r\\n### Document介绍\\r\\n\\r\\n> 基于哈希表实现的`Map`接口。这个实现提供了所有可选的映射操作，并允许空值和空键。(HashMap类大致相当于Hashtable，但它是非同步的，并且允许为空。)这个类不保证映射的顺序；特别地，它不能保证顺序会随时间保持不变（也就是说顺序可能会在其他的操作中被改变）。\\r\\n>\\r\\n> 这个实现为基本操作（`get`和`put`）提供了恒定时间的性能，假设哈希函数将元素适当地分散在各个桶（ **buckets，存储元素的结构，后文用仓位描述这个概念** ）中。对集合视图的遍历迭代所花费的时间，与`HashMap`实例的 **“容量（capacity）”** 及其 **大小（键-值映射数）** 成比例。因此，如果迭代性能很重要，那么不要将初始容量设置得太高（或者负载系数太低），这是非常重要的。\\r\\n>\\r\\n> `HashMap`实例有两个影响其性能的参数：初始容量 **（initial capacity）** 和负载因子**（load factor）**。容量是哈希表中的桶数**（箱子数）**，初始容量只是创建哈希表时的容量。负载因子是在哈希表的容量自动增加之前，哈希表被允许达到的最大容量的度量**（阈值）**。当哈希表中的条目数量超过负载因子和当前容量的乘积时，哈希表就会被重新哈希(也就是说，重新构建内部数据结构)，这样哈希表的容量大约是原来的两倍。\\r\\n\"\n- abbrlink: 1b0rp9e\n  title: 排序大礼包\n  categories:\n    - note\n    - algorithm\n  comments: true\n  date: 2018-06-02T18:50:00.000Z\n  tags:\n    - algorithm\n    - sort\n  char_count: 15460\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 术语\\r\\n\\r\\n**稳定性：**算法排序前后，相同值的元素的相对位置是否不变，变了就不稳定\\r\\n\\r\\n**在位性：**算法排序是否要借助额外的内存空间，需要就不在位\\r\\n\\r\\n### 各数据对比\\r\\n\\r\\n#### 基本数据\\r\\n##### 小数据量\\r\\n\\r\\n|   算法   |     最好     |        平均         |    最坏    | 辅助空间 |          稳定性          |\\r\\n| :------: | :----------: | :-----------------: | :--------: | :------: | :----------------------: |\\r\\n| 冒泡排序 |   **O(n)**   |       O(n^2)        |   O(n^2)   |   O(1)   |    :heavy_check_mark:    |\\r\\n| 选择排序 |   **O(n)**   |       O(n^2)        |   O(n^2)   |   O(1)   | :heavy_multiplication_x: |\\r\\n| 插入排序 |   **O(n)**   |       O(n^2)        |   O(n^2)   |   O(1)   |    :heavy_check_mark:    |\\r\\n| 希尔排序 | **O(n^1.3)** | **O(nlogn)~O(n^2)** | **O(n^2)** |   O(1)   | :heavy_multiplication_x: |\\r\\n\\r\\n##### 大数据量\\r\\n|   算法   |   最好   |   平均   |    最坏    |     辅助空间     |          稳定性          |\\r\\n| :------: | :------: | :------: | :--------: | :--------------: | :----------------------: |\\r\\n\"\n- abbrlink: 1d9upzt\n  title: 最近点对及其相关问题\n  categories:\n    - note\n    - algorithm\n  comments: true\n  date: 2019-02-26T23:04:00.000Z\n  tags:\n    - algorithm\n    - twopoint\n  char_count: 6120\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Introduction\\r\\n\\r\\n二维坐标中有一堆点集，记为P，假设P中至少有2个点，那么求出P中距离最近的两个点；\\r\\n\\r\\n首先为了问题准备好点和求两点距离的方法，其中如果两点距离的输入只有一个点，那么它的距离代表无穷大，它表示没有解\\r\\n\\r\\n```java\\r\\nclass Point {\\r\\n    double x;\\r\\n    double y;\\r\\n\\r\\n    Point(double x, double y) {\\r\\n        this.x = x;\\r\\n        this.y = y;\\r\\n    }\\r\\n\\r\\n    @Override\\r\\n    public String toString() {\\r\\n        return \\\"Point{\\\" +\\r\\n                \\\"x=\\\" + x +\\r\\n                \\\", y=\\\" + y +\\r\\n```\\n\"\n- abbrlink: bg6w8m\n  title: 查找大礼包\n  categories:\n    - note\n    - algorithm\n  comments: true\n  date: 2018-08-22T13:10:00.000Z\n  tags:\n    - algorithm\n    - search\n  char_count: 13520\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n#### 小声BB\\r\\n\\r\\n整理一波查找相关的东西\\r\\n\\r\\n- 几个元素查找算法如：\\r\\n  - 顺序查找\\r\\n  - 二分查找\\r\\n  - 分块查找\\r\\n  - 哈希查找\\r\\n- 字符串匹配：\\r\\n  - 蛮力法\\r\\n  - KMP\\r\\n\\r\\n-----------------\\r\\n\\r\\n#### 术语\\r\\n\\r\\n##### ASL（Average Search Length）\\r\\n\\r\\n平均查找长度：为确定记录在查找表中的位置，需和给定值进行比较的关键字的个数的期望值；\\r\\n\\r\\n\"\n- abbrlink: 8lcrnu\n  title: 算法回收站\n  categories:\n    - note\n    - algorithm\n  comments: true\n  date: 2018-08-11T13:41:10.000Z\n  tags:\n    - algorithm\n  char_count: 2245\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 前言\\r\\n\\r\\n这篇记录下从今天开始，复习到、新遇到的所有算法题\\r\\n\\r\\n- 栈相关\\r\\n- 数学逻辑相关\\r\\n\\r\\n------\\r\\n\\r\\n#### 栈相关\\r\\n\\r\\n##### 汉诺塔（递归方法）\\r\\n\\r\\n###### C语言实现\\r\\n\\r\\n``` c\\r\\nvoid hanoi(int n, char source, char help, char target) {\\r\\n    // 讲塔座上按照直径大小自上而下编号为1到n的n个圆盘按规则搬到塔座target上，help做辅助塔\\r\\n    if (n == 1) {\\r\\n        move(source, 1, target);\\r\\n    } else {\\r\\n```\\n\"\n- abbrlink: 1gfw5vx\n  title: 自实现ArrayList\n  categories:\n    - note\n  comments: true\n  date: 2018-06-04T22:47:12.000Z\n  tags:\n    - arraylist\n  char_count: 5090\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n#### 前言\\r\\n\\r\\n最近在复习**数据结构**和**算法**，这两个玩意也是被称之为**“程序员的基本素养”**，我最近比较想干的一件事就是读集合框架的源码\\r\\n\\r\\n基于这个伟大目标，我开启了源码阅读的**“从头到尾读”**系列，目前只完成了**Collection接口、Iterable接口、Iterator接口**这三个章节，正打算开始读**ArrayList**的源码\\r\\n\\r\\n为什么想要写自实现的ArrayList，主要也是为了配合ArrayList的源码阅读\\r\\n\\r\\n大二的时候也学过数据结构这门课，也用Java实现过简单的ArrayList和其他常见的结构，但是这次的自实现，我的目标是**往JDK源码上面靠拢**，意在学习大师级的**设计手法以及精妙的算法**\\r\\n\\r\\n话不多说，开搞\\r\\n\\r\\n\\r\\n\\r\\n#### 热身\\r\\n在此之前还没开始阅读`ArrayList`，但是我们可以稍稍瞥一眼它的类头，\\r\\n\\r\\n``` java\\r\\npublic class ArrayList<E> extends AbstractList<E>\\r\\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\\r\\n{\\r\\n```\\n\"\n- abbrlink: mtg94p\n  title: 蓝桥杯Java一夜暴富\n  categories:\n    - 随笔\n  comments: false\n  tags:\n    - 蓝桥杯\n  date: 2018-03-30T16:59:43.000Z\n  char_count: 13214\n  short_contant: \"\\r\\n\\r\\n#### 目录\\r\\n- eclipse快捷键\\r\\n- 数组的使用\\r\\n - 初始化\\r\\n - for-each遍历\\r\\n - 使用底层API快速复制\\r\\n - 搭配Arrays类进行二分查找和排序\\r\\n- String类\\r\\n - 截取/替换/匹配\\r\\n - 转其他类型\\r\\n - 分割/简单的单词提取/大小写字母转换\\r\\n- StringBuffer和StringBuilder类\\r\\n- Math类/Random类\\r\\n- 两个大数类\\r\\n- 集合框架的基本使用/及自定义排序的比较器实现:\\r\\n - ArrayList:放置/索引/移除/遍历\\r\\n - HashSet/TreeSet:放置/索引/移除/遍历\\r\\n - HashMap:放置/索引/移除/遍历\\r\\n - Stack/Vector:结构特性使用到算法当中去\\r\\n - 搭配Collections类进行:\\r\\n  - 二分查找(针对List且需要实现比较器)\\r\\n  - 最大最小值(针对List和Set且需要实现比较器)\\r\\n  - 快速替换(replaceAll,针对List)\\r\\n\"\n- abbrlink: 1k7g0p3\n  title: 计算机网络-谢希仁-1\n  categories:\n    - note\n    - booknote\n    - 计算机网络\n  comments: true\n  date: 2018-06-30T10:28:33.000Z\n  tags:\n    - 计算机网络\n  series: 《计算机网络》\n  char_count: 7615\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 前言\\r\\n\\r\\n一周前考完了计算机网络，不得不说，计算机网络确实是一个精妙而繁杂的体系产物，虽然民大的考试都很水，但是计网这门课我是认认真真复习好了的，并不是当作考试去复习，每个点都看了，书上的课后习题都大概刷了80%（谢希仁前辈出的这本书，习题量很多），基本上每个点都吃透了一遍。\\r\\n\\r\\n虽然后面还有两门考试，但很容易就过，也不需要准备，主要的复习科目也考完了，所以趁热打铁，马上进行计网的笔记整理和复习。\\r\\n\\r\\n因为学时有限，学校上的课程只教到第五章运输层，后面的没教，我准备先把前五章的笔记都整理下来，再继续看后面的内容，看完再整理。\\r\\n\\r\\n所以这一系列的笔记也是按照谢希仁前辈的《计算机网络》第七版的内容顺序整理的**（可能会跳一些顺序，可能会改一些章节标题）**。\\r\\n\\r\\n本来想的只是按需记录，但是觉得还是要对得起自己的劳动，所以这一系列的笔记等于是考试重点笔记，意思是事无巨细的都记下来，甚至把课本后的习题解答（自己的解答）都记录下来。\\r\\n\\r\\n\\r\\n\\r\\n### Chapter1-概述\\r\\n\\r\\n#### 1.1 计算机网络与信息时代\\r\\n\\r\\n##### Internet\\r\\n\\r\\n（1）因特网（旧译）\\r\\n\"\n- abbrlink: 1nz333d\n  title: 计算机网络-谢希仁-2\n  categories:\n    - note\n    - booknote\n    - 计算机网络\n  comments: true\n  date: 2018-07-03T20:44:33.000Z\n  tags:\n    - 计算机网络\n  series: 《计算机网络》\n  char_count: 3322\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### Chapter2-物理层\\r\\n\\r\\n物理层是计网体系结构中的最下面一层，本章主要介绍：\\r\\n\\r\\n1. 物理层的基本任务\\r\\n2. 几种常用的信道复用技术\\r\\n3. 几种常用的宽带接入技术\\r\\n\\r\\n#### 2.1 物理层基本概念\\r\\n\\r\\n##### 物理层的主要任务\\r\\n\\r\\n物理层的主要任务是确定与传输媒体的接口有关的一些特性：\\r\\n\\r\\n1. **机械特性：**指明接口所用界掀起的形状和尺寸、引脚数目和排列、固定和锁定装置。平时常见的各种规格的接插件都有严格的标准化规定。\\r\\n2. **电气特性：**指明在接口电缆的各条线上出现的电压的范围。\\r\\n3. **功能特性：**指明某条线上出现的某个电平的意义。\\r\\n4. **过程特性：**指明对于不同功能的各种可能事件的出现顺序。\\r\\n5. **传输方式转换：**计算机内部大多采用**并行传输**，但是数据通信线路上一般都是**串行传输（处于经济上的考虑）**，所以需要转换。\\r\\n\\r\\n\\r\\n\"\n- abbrlink: 9h3hmp\n  title: 记一次设计模式之旅\n  categories:\n    - note\n  comments: true\n  date: 2018-08-09T15:21:33.000Z\n  tags:\n    - design-pattern\n  char_count: 19385\n  short_contant: \"\\r\\n\\r\\n\\r\\n\\r\\n### 前言\\r\\n\\r\\n我\\r\\n\\r\\n面试（大约两个月前）\\r\\n\\r\\n被问线程安全单例\\r\\n\\r\\n实际上写得出\\r\\n\\r\\n只是不知道可以这样写\\r\\n\\r\\n所以没答好- -\\r\\n\\r\\n回来一看\\r\\n\\r\\n可以答\\r\\n\\r\\n耻辱\\r\\n\\r\\n说明：本篇代码大部分引自：https://github.com/iluwatar/java-design-patterns \\r\\n\"\n- abbrlink: n0hez3\n  title: 这，就是Lambda！\n  categories:\n    - note\n  comments: true\n  date: 2018-06-02T10:52:00.000Z\n  tags:\n    - lambda\n    - java8\n  char_count: 9025\n  short_contant: \"\\r\\n\\r\\n### HelloWorld\\r\\n\\r\\n昨天的小米笔试题: **请用Lambda写一个将int数组[1,2,3]转换为String数组[\\\"1\\\",\\\"2\\\",\\\"3\\\"]**\\r\\n\\r\\n当时没写完整，就这个为例作为开始吧, 完整代码如下:\\r\\n\\r\\n``` java\\r\\n  int[] si = {1, 2, 3};\\r\\n  Function<int[], String[]> f = (int[] ar) -> {\\r\\n      String[] ss = new String[ar.length];\\r\\n      for (int i = 0; i < ar.length ; i++) {\\r\\n          ss[i] = ar[i] + \\\"\\\";\\r\\n      }\\r\\n      return ss;\\r\\n  };\\r\\n  System.out.println(Arrays.toString(f.apply(si)));\\r\\n```\\r\\n\\r\\n看不懂是不是?看不懂就对了,Lambda是一个语法糖,它的语法你得看得懂,才知道上面的代码干了什么.\\r\\n\\r\\n\\r\\n\\r\\n### 语法\\r\\n\"\n");
