<hr>
<p>title: Leetcode-61~65
categories:</p>
<ul>
<li>note</li>
<li>algorithm</li>
<li>leetcode
tags:</li>
<li>leetcode
date: 2019-04-02 14:18:00 +8
series: leetcode</li>
</ul>
<hr>
<h3 id="61rotate-listmedium">61.Rotate List(Medium)</h3>
<p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
Explanation:
rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4
Output: 2-&gt;0-&gt;1-&gt;NULL
Explanation:
rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL
rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL
rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL
rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</code></pre><h4 id="solution">Solution</h4>
<p>追踪指针，简单直接</p>
<pre><code class="language-java">public ListNode rotateRight(ListNode head, int k) {
    if (head == null) {
        return null;
    }
    ListNode newHead, tail = null;
    int length = 0;
    ListNode now = head;
    // 遍历一般计算长度 标志尾巴
    while (now != null) {
        if (now.next == null) {
            tail = now;
        }
        now = now.next;
        length++;
    }

    // 处理k
    k %= length;
    if (k == 0) {
        return head;
    }
    int count = 0;
    ListNode pre = new ListNode(0);
    now = head;
    pre.next = head;
    // 遍历到转轴点
    while (count &lt; length - k) {
        pre = pre.next;
        now = now.next;
        count++;
    }
    // 断开转轴点
    pre.next = null;
    // 转轴点为新的头部
    newHead = now;
    // 尾部接上旧头部
    tail.next = head;
    return newHead;
}</code></pre>
<h3 id="62unique-pathsmedium">62.Unique Paths(Medium)</h3>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked &#39;Start&#39; in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img">
Above is a 7 x 3 grid. How many possible unique paths are there?</p>
<p><strong>Note:</strong> <em>m</em> and <em>n</em> will be at most 100.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -&gt; Right -&gt; Down
2. Right -&gt; Down -&gt; Right
3. Down -&gt; Right -&gt; Right</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: m = 7, n = 3
Output: 28</code></pre><h4 id="dp">DP</h4>
<p>机器人走方格，有多少种走法题目，在<a href="https://youyinnn.github.io/?to=post&amp;number=63#DP%E7%BB%83%E4%B9%A0-3%EF%BC%9A%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B5%B0%E6%96%B9%E6%A0%BC">地痞</a>解过的，这遍解不同的是，我简化了之前的思路，并不需要预置好pre数组的结果</p>
<pre><code class="language-java">public int uniquePaths(int m, int n) {
    int[] pre = new int[n];
    int[] now = new int[n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            now[j] = j &gt; 0 ? (now[j - 1] + pre[j]) : 1;
        }
        pre = Arrays.copyOf(now, now.length);
    }
    return now[n - 1];
}</code></pre>
<h3 id="63unique-paths-ii-medium">63.Unique Paths II (Medium)</h3>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked &#39;Start&#39; in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p>
<p>An obstacle and empty space is marked as <code>1</code> and <code>0</code> respectively in the grid.</p>
<p><strong>Note:</strong> <em>m</em> and <em>n</em> will be at most 100.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -&gt; Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right -&gt; Right</code></pre><h4 id="dp-1">DP</h4>
<p>稍微变种一下，因为有障碍物，所以我们处理第一行now的时候，还是预处理一下pre比较好</p>
<pre><code class="language-java">public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    int[] pre = new int[n];
    // 如果起点没有障碍物
    if (obstacleGrid[0][0] != 1) {
        pre[0] = 1;
        for (int i = 1; i &lt; pre.length; i++) {
            if (obstacleGrid[0][i] != 0) {
                pre[i] = 1;
            } else {
                // 一旦碰到障碍物 后面的路就断了
                break;
            }
        }
    }
    int[] now = new int[n];
    for (int i = 0; i &lt; m; i++) {
        for (int j = 0; j &lt; n; j++) {
            if (obstacleGrid[i][j] == 1) {
                now[j] = 0;
            } else {
                now[j] = j &gt; 0 ? (now[j - 1] + pre[j]) : pre[j];
            }
        }
        pre = Arrays.copyOf(now, now.length);
    }
    return now[n - 1];
}</code></pre>
<h3 id="64minimun-path-summedium">64.Minimun Path Sum(Medium)</h3>
<p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p>
<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>
<p><strong>Example:</strong></p>
<pre><code>Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.</code></pre><h4 id="dp-2">DP</h4>
<p>曾经有一道题，<a href="https://youyinnn.github.io/?to=post&amp;number=63#DP%E7%BB%83%E4%B9%A0-6%EF%BC%9A%E7%A1%AC%E5%B8%81%E6%94%B6%E9%9B%86%E9%97%AE%E9%A2%98">硬币收集问题</a>，这个就相当于收集到的最小币值</p>
<pre><code class="language-java">public int minPathSum(int[][] grid) {
    if (grid.length == 0 || grid[0].length == 0) {
        return 0;
    }
    int[] pre = new int[grid[0].length];
    int[] now = new int[grid[0].length];
    for (int i = 0; i &lt; grid.length; i++) {
        for (int j = 0; j &lt; grid[0].length; j++) {
            if (i == 0 &amp;&amp; j == 0) {
                now[0] = grid[0][0];
            } else if (i == 0) {
                now[j] = grid[0][j] + now[j - 1];
            } else if (j == 0) {
                now[j] = grid[i][0] + pre[j];
            } else {
                now[j] = grid[i][j] + Math.min(now[j - 1], pre[j]);
            }
        }
        pre = Arrays.copyOf(now, now.length);
    }
    return now[now.length - 1];
}</code></pre>
<h3 id="65valid-numberhard">65.Valid Number(Hard)</h3>
<p>不做，傻逼题</p>
