<hr>
<p>title: Express Middleware
categories:</p>
<ul>
<li>note</li>
<li>nodejs
tags:</li>
<li>express</li>
<li>nodejs
series: express
date: 2019-10-03 16:31:00</li>
</ul>
<hr>
<p>{% cq %}</p>
<p>翻译自官方文档</p>
<p>{% endcq %}</p>
<h2 id="writing-middleware">Writing Middleware</h2>
<p>中间件能够在请求响应周期中访问 <a href="http://www.expressjs.com.cn/en/4x/api.html#req">request object</a> (<code>req</code>)，和 <a href="http://www.expressjs.com.cn/en/4x/api.html#res">response object</a> (<code>res</code>)，以及 <code>next</code>方法。<code>next</code>方法用于在路由过程中执行当前中间件紧接着的下一个中间件。</p>
<p>中间件能够完成以下事情：</p>
<ul>
<li>Execute any code.</li>
<li>Make changes to the request and the response objects.</li>
<li>End the request-response cycle.</li>
<li>Call the next middleware in the stack.</li>
</ul>
<p>如果当前中间件不结束该次请求响应周期，它必须调用next方法，将控制传递到下一个中间件，否则请求会被挂起。</p>
<p>下图展示了中间件功能的基本元素：</p>
<p><img src="https://image.youyinnn.top/20191003170602.png" alt=""></p>
<h3 id="example--middleware-function-mylogger">Example:  Middleware function myLogger</h3>
<p>这里是一个简单的“myLogger”中间件，作用仅仅只是在有请求进来的时候打印。</p>
<pre><code class="language-javascript">var myLogger = function (req, res, next) {
  console.log(&#39;LOGGED&#39;)
  next()
}</code></pre>
<p>方法的最后一行调用了<code>next()</code>函数，这个函数不是Node.js或者Express API里的函数，而是从第三个方法参数传进来的下一个中间件的名称，将这个参数当作方法调用就是在调用下一个中间件；。</p>
<p>为了加载中间件，调用<code>app.use()</code>。比如下面的代码将<code>myLogger</code>中间件加载到根路径上。</p>
<pre><code class="language-javascript">var express = require(&#39;express&#39;)
var app = express()

var myLogger = function (req, res, next) {
  console.log(&#39;LOGGED&#39;)
  next()
}

app.use(myLogger)

app.get(&#39;/&#39;, function (req, res) {
  res.send(&#39;Hello World!&#39;)
})

app.listen(3000)</code></pre>
<p>中间件加载的顺序很重要：先加载的中间件其方法先被执行。</p>
<p>如果<code>myLogger</code>是在“路由到根路径”之后加载的话，那么任何请求都不会访问到它，因为根路径路由周期已经结束了。</p>
<h3 id="example-middleware-function-requesttime">Example: Middleware function requestTime</h3>
<p>我们创建一个记录请求时间的中间件：</p>
<pre><code class="language-javascript">var requestTime = function (req, res, next) {
  req.requestTime = Date.now()
  next()
}</code></pre>
<p>回调方法也可以使用路由方法上的参数，去添加属性到<code>req</code>上：</p>
<pre><code class="language-javascript">var express = require(&#39;express&#39;)
var app = express()

var requestTime = function (req, res, next) {
  req.requestTime = Date.now()
  next()
}

app.use(requestTime)

app.get(&#39;/&#39;, function (req, res) {
  var responseText = &#39;Hello World!&lt;br&gt;&#39;
  responseText += &#39;&lt;small&gt;Requested at: &#39; + req.requestTime + &#39;&lt;/small&gt;&#39;
  res.send(responseText)
})

app.listen(3000)</code></pre>
<h3 id="configurable-middleware">Configurable middleware</h3>
<p>如果你需要你的中间件可以配置的话，那么你可以这样做：</p>
<p>File: <code>my-middleware.js</code></p>
<pre><code class="language-javascript">module.exports = function(options) {
  return function(req, res, next) {
    // Implement the middleware function based on the options object
    next()
  }
}</code></pre>
<p>然后在装载的时候指定参数：</p>
<pre><code class="language-javascript">var mw = require(&#39;./my-middleware.js&#39;)

app.use(mw({ option1: &#39;1&#39;, option2: &#39;2&#39; }))</code></pre>
<p>中间件<a href="https://github.com/expressjs/cookie-session">cookie-session</a> 和 <a href="https://github.com/expressjs/compression">compression</a> 都是以这样的形势去配置的。</p>
