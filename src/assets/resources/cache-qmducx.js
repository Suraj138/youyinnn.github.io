
    sessionStorage.setItem('postSeries', "[{\"se\":\"Cron4jDocument_ZH_CN_Translation\",\"ps\":[\"Cron4jDocument_ZH_CN_Translation_README===19jo7o1===1525713121000\",\"Cron4jDocument_ZH_CN_Translation===1ngl1pm===1525713901000\"]},{\"se\":\"docker\",\"ps\":[\"Docker Orientation&Setup===1ei198o===1542203411000\",\"Docker Containers&Dockerfile===uh480l===1542380711000\",\"Docker Service&Composefile===zkr55u===1543321142000\",\"Docker Swarm&ClusterSetup===1toixsk===1543439163000\",\"Docker Stack===u7sd0w===1543509960000\",\"Docker ConceptReview===rx7jt4===1543754349000\",\"Docker Persist Data Overview===lt42s8===1543916673000\",\"Docker Volumes===1ae6lng===1544005389000\"]},{\"se\":\"electron\",\"ps\":[\"Electron_一个HelloWorld===a08lib===1511388323000\",\"Electron_打包你的HelloWorld为exe===1q1lo3l===1511442141000\",\"Electron_上手铺垫===11zuc81===1570142121000\",\"Electron_配置相关与对象===1y7ozg8===1570698201000\",\"Electron_UI===kimeni===1570707861000\"]},{\"se\":\"express\",\"ps\":[\"Express Routing===1n8vn13===1570109880000\",\"Express Middleware===1tzsbbu===1570120260000\"]},{\"se\":\"Interesting Math\",\"ps\":[\"Interesting Math - Prime Number===1jy4sem===1587026619000\"]},{\"se\":\"并发\",\"ps\":[\"Java并发编程第一坎===bu9klx===1528236540000\",\"Java并发编程第二坎===1clnpuk===1531652002000\",\"Java并发编程第三坎===1h1ww1y===1531923322000\",\"Java并发编程第四坎===db3vx3===1531923408000\",\"Java并发编程第五坎===1xo3tpx===1532201628000\",\"Java并发编程第六坎===139027a===1532554428000\",\"Java并发编程第七坎===7kdfk8===1545776568000\",\"Java并发编程第七坎-2===u4sgci===1546174728000\",\"Java并发编程第八坎===1u7rv30===1546901208000\"]},{\"se\":\"jenkins\",\"ps\":[\"Jenkins Introductions&Setup===1arzjog===1542639060000\"]},{\"se\":\"JettyDocument_ZH_CN_Translation\",\"ps\":[\"JettyDocument_ZH_CN_Translation_README===n8gsoq===1525714201000\",\"JettyDocument_ZH_CN_Translation_Part4-23===1cei7aq===1525714201000\",\"JettyDocument_ZH_CN_Translation_Part4-21===18rke1===1525714201000\",\"JettyDocument_ZH_CN_Translation_Part3-13===cc3kmk===1525714201000\",\"JettyDocument_ZH_CN_Translation_Part1===17hjlts===1525714201000\"]},{\"se\":\"leetcode\",\"ps\":[\"Leetcode-1~5===pn2ezr===1549137060000\",\"Leetcode-6~10===t1f0vq===1550409480000\",\"Leetcode-11~15===2gps3g===1551303720000\",\"Leetcode-16~20===3yl2hx===1551903180000\",\"Leetcode-21~25===1hrw4sv===1551907020000\",\"Leetcode-26~30===448jer===1552148460000\",\"Leetcode-31~35===dbne5d===1552772760000\",\"Leetcode-36~40===v6ei19===1553111160000\",\"Leetcode-41~45===11z93zc===1553112180000\",\"Leetcode-46~50===jywoys===1553672340000\",\"Leetcode-51~55===xmbex2===1553914620000\",\"Leetcode-56~60===1kv61wq===1553951760000\",\"Leetcode-61~65===1cu6q2d===1554185880000\",\"Leetcode-66~70===z9pvg9===1554216000000\",\"Leetcode-71~75===i9becb===1554363300000\"]},{\"se\":\"Log4j2\",\"ps\":[\"Log4j2_HelloWorld===en4hhw===1510935201000\",\"Log4j2_Appenders===nff3ic===1510936638000\",\"Log4j2_Layouts===yvgzwi===1512743956000\",\"Log4j2_Filters===3fjm8j===1512823280000\",\"Log4j2_Lookups===3zxt7z===1512833295000\"]},{\"se\":\"《MySQL技术内幕：InnoDB存储引擎》笔记\",\"ps\":[\"MySQL InnoDB引擎概述===xfjqry===1591902734000\",\"MySQL InnoDB索引概述===a0p0f4===1592157644000\",\"MySQL InnoDB事务概述===tx6g0p===1592318726000\",\"MySQL InnoDB锁概述===dc5shg===1592402935000\"]},{\"se\":\"Python Note\",\"ps\":[\"The Basic Grammar Of Python (AB)===t3owl3===1588971615000\",\"The Basic Grammar Of Python (CD)===1ba9tuk===1589120354000\",\"The Basic Grammar Of Python (EF)===1xentt===1589728247000\",\"Python - Threading===2acnhf===1590005083000\"]},{\"se\":\"《Mastering Regular Expression(Third Edition)》\",\"ps\":[\"RegExp_1_overview===1k4djcz===1510876856000\",\"RegExp_2_metacharacters===huiysg===1510876926000\"]},{\"se\":\"从头到尾读\",\"ps\":[\"从头到尾读Collection===faxga5===1526404646000\",\"从头到尾读Iterable与Iterator===1kakozs===1526404934000\",\"从头到尾读ArrayList===rku8jh===1528187481000\",\"把HashMap安排得明明白白===ofa68o===1534421541000\"]},{\"se\":\"JVM\",\"ps\":[\"关于JVM的运行时数据区===rikltc===1527979680000\",\"关于JVM的对象创建与访问===18669ga===1542231900000\",\"关于JVM的运行时数据区上的GC===d5ykz8===1542235500000\",\"关于JVM的GC行为和内存分配===jhpq7e===1542468900000\"]},{\"se\":\"深入MySQL亿点点\",\"ps\":[\"再聊InnoDB索引===1lvzuh7===1592842893000\"]},{\"se\":\"《计算机网络》\",\"ps\":[\"计算机网络-谢希仁-1===1k7g0p3===1530354513000\",\"计算机网络-谢希仁-2===1nz333d===1530650673000\"]}]");
    sessionStorage.setItem('postMetadata', "[{\"title\":\"Connecting ModelSIM with Vscode & XQuartz on Mac\",\"categories\":[\"concordia\",\"coen6501\"],\"tags\":[\"nottag\"],\"date\":\"2021-10-5 19:22:5\",\"char_count\":1829,\"short_content\":\"\\n\\n\\n\\n\\n\\n### XQuartz setup\\n\\nhttps://www.xquartz.org/\\n\\n\",\"abbrlink\":\"xqh6xg\"},{\"title\":\"了解前缀树\",\"categories\":[\"algorithm\",\"searching\"],\"tags\":[\"trie\",\"leetcode\"],\"date\":\"2020-07-14T11:39:55.000Z\",\"char_count\":12090,\"short_content\":\"\\n\\n\\n\\n\\n\\n本篇主要介绍一个用于字符串前后缀快速搜索的数据结构——前缀树，这篇也是在Leetcode里的一个数据结构[专题](https://leetcode-cn.com/explore/learn/card/trie/)，专题里已经把前缀树的实现方式以及实际应用都介绍了一下，这里稍微整理一下这个专题\\n\\n关于前缀树的概念，可以参考：[什么是前缀树？](https://leetcode-cn.com/explore/learn/card/trie/165/introduction-to-trie/641/)\\n\\n\",\"abbrlink\":\"ooqfkn\"},{\"title\":\"带状态机的DP\",\"categories\":[\"algorithm\",\"dp\"],\"tags\":[\"dp\"],\"date\":\"2020-07-10T11:51:57.000Z\",\"char_count\":10121,\"short_content\":\"\\n\\n\\n\\n\\n\\n\\n\\n前几天碰到一套经典的题，《买卖股票》系列，其中最简单那道题我之前还在字节碰到过，然而当时我菜得连最简单的题都没做出来\\n\\n\",\"abbrlink\":\"f40uwq\"},{\"title\":\"再聊InnoDB索引\",\"categories\":[\"db\",\"mysql\",\"index\"],\"tags\":[\"mysql-index\",\"mys\"],\"series\":\"深入MySQL亿点点\",\"date\":\"2020-06-22T16:21:33.000Z\",\"char_count\":28480,\"short_content\":\"\\n\\n\\n\\n\\n\\n本篇主要是再来聊聊MySQL中InnoDB的索引的细节，主要聊到引擎是如何利用B+树去检索数据的\\n\\n以及整理一些关于索引的问题与回答，所以本篇的形式还是以问题点为驱动，回答一个个的问题\\n\\n\",\"abbrlink\":\"1lvzuh7\"},{\"title\":\"MySQL InnoDB锁概述\",\"categories\":[\"db\",\"mysql\",\"lock\"],\"tags\":[\"mysql-lock\"],\"series\":\"《MySQL技术内幕：InnoDB存储引擎》笔记\",\"date\":\"2020-6-17 10:8:55\",\"char_count\":6072,\"short_content\":\"\\n\\n\\n\\n### 概述\\n\\n本篇主要介绍InnoDB中的锁，以及它与隔离级别之间的关系。从锁的算法、锁的等级、锁解决的问题来为MySQL的InnoDB锁做一个概述\\n\\n我们能够轻易地想到，对数据库的数据进行操作的时候，为了保证数据一致性和持久性，我们会对这些操作上锁，但数据库中并不只有这些情况会上锁，其他地方也会有锁，比如缓冲池中页的增删改查的时候\\n\\n\",\"abbrlink\":\"dc5shg\"},{\"title\":\"MySQL InnoDB事务概述\",\"categories\":[\"db\",\"mysql\",\"transaction\"],\"tags\":[\"db-transaction\",\"mvcc\"],\"series\":\"《MySQL技术内幕：InnoDB存储引擎》笔记\",\"date\":\"2020-06-16T14:45:26.000Z\",\"char_count\":4856,\"short_content\":\"\\n\\n\\n\\n\\n\\n本篇介绍内容：\\n\\n- 数据库系统中事务的相关概念；\\n- SQL隔离级别要解决的问题；\\n\",\"abbrlink\":\"tx6g0p\"},{\"title\":\"MySQL InnoDB索引概述\",\"categories\":[\"db\",\"mysql\",\"index\"],\"tags\":[\"mysql\",\"mysql-index\"],\"series\":\"《MySQL技术内幕：InnoDB存储引擎》笔记\",\"date\":\"2020-6-14 14:0:44\",\"char_count\":11686,\"short_content\":\"\\n\\n\\n\\n本篇开始了解MySQL中InnoDB引擎的索引，索引是MySQL里非常重要的部分，它的出现极大地提升了MySQL处理数据的性能，而且索引使用的好坏也决定着一个系统的执行效率\\n\\n因此，想要高效地使用MySQL数据库，合理地创建索引，甚至是合理地编写SQL语句，都需要先了解索引在MySQL中的行为以及原理\\n\\nInnoDB的索引常见的有：B+树索引、全文索引、哈希索引\\n\\n\",\"abbrlink\":\"a0p0f4\"},{\"title\":\"优先队列&二叉堆（2-heap）\",\"categories\":[\"data structures\",\"heap\"],\"tags\":[\"queue\",\"priority-queue\",\"heap\",\"2-heap\"],\"date\":\"2020-6-13 12:8:2\",\"char_count\":6465,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n在排序算法中有堆排序，而要理解好堆排序，首先我们得先理解好堆的概念，一般在数据结构上，我们把优先队列的数据结构称为堆，那什么是有限队列呢？它能应用在哪些场景呢？这些是本篇要介绍的重点\\n\\n\\n\\n\",\"abbrlink\":\"2t44ld\"},{\"title\":\"MySQL InnoDB引擎概述\",\"categories\":[\"db\",\"mysql\",\"engines\"],\"tags\":[\"mysql-engins\",\"innodb\"],\"series\":\"《MySQL技术内幕：InnoDB存储引擎》笔记\",\"date\":\"2020-06-11T19:12:14.000Z\",\"char_count\":6556,\"short_content\":\"\\n\\n\\n\\n### 介绍\\n\\n本篇主要介绍了MySQL系统的核心引擎之一：***InnoDB***，本系列所有的内容是基于姜承尧老师所著*《MySQL技术内幕：InnoDB存储引擎》*再加上整理的网络笔记、MySQL5.7的[官方文档](https://dev.mysql.com/doc/refman/5.7/en/)和自己的一些理解\\n\\n### InnoDB引擎\\n\\n\",\"abbrlink\":\"xfjqry\"},{\"title\":\"Python - Threading\",\"categories\":[\"python\",\"concurrency\"],\"tags\":[\"python\",\"thread\"],\"series\":\"Python Note\",\"date\":\"2020-5-20 16:4:43\",\"char_count\":17088,\"short_content\":\"\\n\\n\\n\\n\\n\\nIntroduce how to use multi-thread tech with python, refer to: https://docs.python.org/3/library/threading.html\\n\\n### Lib - threading\\n\\n\",\"abbrlink\":\"2acnhf\"},{\"title\":\"The Basic Grammar Of Python (EF)\",\"categories\":[\"python\",\"grammar\"],\"tags\":[\"python\",\"grammar\"],\"series\":\"Python Note\",\"date\":\"2020-05-17T15:10:47.000Z\",\"char_count\":25166,\"short_content\":\"\\n\\n\\n\\n\\n\\n\\n\\nData Structures, Classes and Errors & Exceptions.\\n\\n\",\"abbrlink\":\"1xentt\"},{\"title\":\"The Basic Grammar Of Python (CD)\",\"categories\":[\"python\",\"grammar\"],\"tags\":[\"python\",\"grammar\"],\"series\":\"Python Note\",\"date\":\"2020-05-10T14:19:14.000Z\",\"char_count\":15622,\"short_content\":\"\\n\\n\\n\\nFlow control syntax, Function definition, Modules.\\n\\n## C\\n\\n### Flow Control\\n#### `if` statement\\n\",\"abbrlink\":\"1ba9tuk\"},{\"title\":\"The Basic Grammar Of Python (AB)\",\"categories\":[\"python\",\"grammar\"],\"tags\":[\"python\",\"grammar\"],\"series\":\"Python Note\",\"date\":\"2020-5-8 17:0:15\",\"char_count\":15915,\"short_content\":\"\\n\\n\\n\\nThe series of \\\\<Python Note\\\\> is talking about some basic grammar rules of python, for quick search while I might use python.\\n\\nThe first article will introduces  `print()` and `input()`, the comment syntax, variables assignment and some basic types in python.\\n\\n## A\\n\\n\",\"abbrlink\":\"t3owl3\"},{\"title\":\"Make Your Raspberry Pi Broadcasting TV News Every Morning\",\"categories\":[\"essay\"],\"tags\":[\"raspberry pi\"],\"date\":\"2020-04-23T22:46:59.000Z\",\"char_count\":7544,\"short_content\":\"\\n\\n### Preface\\n\\nI can't get up early recently, and yesterday I suddenly thought about why can't I use my idle raspberry pi to broadcast TV news every 7:00 a.m and wake me up?\\n\\nAnd how am I going to achieve that? There are some factors I should count in:\\n\\n- a cron to set timing task at 7:00 a.m;\\n- tools to control the mouse action;\\n\",\"abbrlink\":\"1xemds8\"},{\"title\":\"Interesting Math - Prime Number\",\"categories\":[\"mathematics\"],\"tags\":[\"prime\",\"math\"],\"series\":\"Interesting Math\",\"date\":\"2020-04-16T08:43:39.000Z\",\"char_count\":13184,\"short_content\":\"\\n\\n\\n\\n### Preface\\n\\nPrime number is important for computer science, especially in cryptography such as [public-key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography), which relies on the difficulty of [factoring](https://en.wikipedia.org/wiki/Integer_factorization) large numbers into their prime factors.\\n\\nSo I planed to summarize some concepts and algorithm of prime number.\\n\\n\",\"abbrlink\":\"1jy4sem\"},{\"title\":\"微信小程序支付后台接入\",\"categories\":[\"note\",\"project\"],\"tags\":[\"wechat\"],\"date\":\"2020-04-02T13:51:57.000Z\",\"char_count\":6211,\"short_content\":\"\\n\\n\\n\\n### 前言\\n\\n2月份的时候，疫情原因，学校实验室和学院要开发一款帮助小区居民批量采购的小程序，实验室团队人手不足，说是少后台开发，所以我就上了，看着微信的文档还有学长的帮助，也就吭哧吭哧写上线了\\n\\n### 操作流程\\n\\n\",\"abbrlink\":\"1csh4qm\"},{\"title\":\"一次博客的改版和升级\",\"categories\":[\"essay\"],\"comments\":true,\"date\":\"2020-03-13T11:23:00.000Z\",\"tags\":[\"blog\"],\"char_count\":8691,\"short_content\":\"\\n\\n\\n\\n### 前提\\n\\n当年玩上博客的时候，整过很多活儿，什么Hexo，WP甚至Jekyll都来了，还搭到服务器上用nginx，然后各种域名、备案、CNAME各种乱搞\\n\\n后面累了，不想折腾了，直接挂github pages，然后就还是用hexo\\n\\n\",\"abbrlink\":\"3rmqph\"},{\"title\":\"字符编码笔记\",\"categories\":[\"reprinted\"],\"tags\":[\"encoding\"],\"date\":\"2020-02-14T19:34:01.000Z\",\"char_count\":21763,\"short_content\":\"\\r\\n\\r\\n> 转自：[yaoxuannn-字符编码笔记](https://yaoxuannn.com/2017/12/12/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/)\\r\\n\\r\\n想来想去终于决定写一个关于计算机字符编码的笔记了( 应该说终于愿意去学了..(๑•ᴗ•๑)), 原本的目的只是搞清楚Unicode的, 考虑到字符编码问题是一个有趣, 在开发中经常会遇到并且稍微有点麻烦和棘手的问题, 但是在网络上却很难找到将这个说的比较细致和成体系的文章, 所以我决定倾尽精力去写这篇笔记, 我会尽量的去查资料和参考他人的文章和博客, 将关于计算机编码的问题捣鼓清楚.\\r\\n\\r\\n在笔记的后半部分, 我也会针对Python3的Unicode做一些说明, 并且当说到Unicode的时候, 我会尝试说明一些关于UTF-8 with BOM在Linux/Unix内核中的一些矛盾.\\r\\n\\r\\n**关于我搜寻和参考的资料, 都会贴在文章的最后.**\\r\\n\\r\\n\",\"abbrlink\":\"1w60zyo\"},{\"title\":\"Electron_UI\",\"categories\":[\"front-end\",\"electron\"],\"comments\":true,\"tags\":[\"electron\"],\"series\":\"electron\",\"date\":\"2019-10-10T11:44:21.000Z\",\"char_count\":6599,\"short_content\":\"\\n\\n\\n\\n### 对话框\\n\\n> 显示用于打开和保存文件、警报等的本机系统对话框。\\n\\n线程：[主线程](https://electronjs.org/docs/glossary#main-process)\\n\\n\",\"abbrlink\":\"kimeni\"},{\"title\":\"Electron_配置相关与对象\",\"categories\":[\"front-end\",\"electron\"],\"comments\":true,\"tags\":[\"electron\"],\"series\":\"electron\",\"date\":\"2019-10-10T09:03:21.000Z\",\"char_count\":19831,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n有了一些铺垫之后，我们就能开始了解一下Electron的主体功能都提供了什么东西，具体的列表可以看：https://electronjs.org/docs/api\\n\\n- 配置相关与对象\\n  - app：整个应用程序生命周期相关的api和事件\\n\",\"abbrlink\":\"1y7ozg8\"},{\"title\":\"Electron_上手铺垫\",\"categories\":[\"front-end\",\"electron\"],\"comments\":true,\"tags\":[\"electron\"],\"series\":\"electron\",\"date\":\"2019-10-03T22:35:21.000Z\",\"char_count\":7274,\"short_content\":\"\\n\\n\\n\\n## Introduction\\n\\n官方指南不叫指南，叫document，于是乎开始无教程纯瞎子摸石头，于是想着把整个官方指南都看一遍，然后梳理梳理。\\n\\n- 关于electron的命名空间\\n- 主进程和渲染进程\\n\",\"abbrlink\":\"11zuc81\"},{\"title\":\"Express Middleware\",\"categories\":[\"front-end\",\"nodejs\"],\"tags\":[\"express\",\"nodejs\"],\"series\":\"express\",\"date\":\"2019-10-03T16:31:00.000Z\",\"char_count\":2342,\"short_content\":\"\\n\\n\\n\\n{% cq %}\\n\\n翻译自官方文档\\n\\n{% endcq %}\\n\\n\",\"abbrlink\":\"1tzsbbu\"},{\"title\":\"Express Routing\",\"categories\":[\"front-end\",\"nodejs\",\"express\"],\"tags\":[\"express\",\"nodejs\"],\"series\":\"express\",\"date\":\"2019-10-03T13:38:00.000Z\",\"char_count\":8714,\"short_content\":\"\\n\\n\\n\\n{% cq %}\\n\\n翻译自官方文档\\n\\n{% endcq %}\\n\\n\",\"abbrlink\":\"1n8vn13\"},{\"title\":\"Understanding the nodejs' event loop\",\"categories\":[\"reprinted\"],\"tags\":[\"nodejs\"],\"date\":\"2019-10-02T15:47:20.000Z\",\"char_count\":6717,\"short_content\":\"\\n\\n\\n\\n\\n\\n> 转载自：http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/\\n\\n### Understanding the nodejs' event loop\\n\\n\",\"abbrlink\":\"1w97yet\"},{\"title\":\"GC Algorithm Implementation\",\"categories\":[\"java\",\"jvm\",\"gc\"],\"tags\":[\"gc\",\"gc-algorithm\"],\"date\":\"2019-04-05T05:11:00.000Z\",\"char_count\":16053,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n前面说了挺多关于GC的算法思路，接下来这篇说说在JVM里实际实现的GC算法，翻译、参考自[plumbr.io](https://plumbr.io/handbook/garbage-collection-algorithms-implementations)\\n\\n我们首先要清楚地认识到一个事情：除了G1回收器以外，垃圾回收算法分为**“针对新生代”**，**“针对老年代”**两种\\n\\n\",\"abbrlink\":\"1jvfs4t\"},{\"title\":\"Leetcode-71~75\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\",\"mysqrt\",\"binary-question\"],\"date\":\"2019-04-04T07:35:00.000Z\",\"series\":\"leetcode\",\"char_count\":8871,\"short_content\":\"\\n\\n\\n\\n### 71. SimplifyPath(Medium)\\n\\nGiven an **absolute path** for a file (Unix-style), simplify it. Or in other words, convert it to the **canonical path**.\\n\\nIn a UNIX-style file system, a period `.` refers to the current directory. Furthermore, a double period `..` moves the directory up a level. For more information, see: [Absolute path vs relative path in Linux/Unix](https://www.linuxnix.com/abslute-path-vs-relative-path-in-linuxunix/)\\n\\n\",\"abbrlink\":\"i9becb\"},{\"title\":\"Leetcode-66~70\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\",\"mysqrt\",\"binary-question\"],\"date\":\"2019-04-02T14:40:00.000Z\",\"series\":\"leetcode\",\"char_count\":8710,\"short_content\":\"\\n\\n\\n\\n### 66.Plus One(Easy)\\n\\nGiven a **non-empty** array of digits representing a non-negative integer, plus one to the integer.\\n\\nThe digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\\n\\n\",\"abbrlink\":\"z9pvg9\"},{\"title\":\"Leetcode-61~65\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\"],\"date\":\"2019-04-02T06:18:00.000Z\",\"series\":\"leetcode\",\"char_count\":5624,\"short_content\":\"\\n\\n\\n\\n### 61.Rotate List(Medium)\\n\\nGiven a linked list, rotate the list to the right by *k* places, where *k* is non-negative.\\n\\n**Example 1:**\\n\\n\",\"abbrlink\":\"1cu6q2d\"},{\"title\":\"Leetcode-56~60\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\",\"n-queens\",\"backtrack\"],\"date\":\"2019-03-30T13:16:00.000Z\",\"series\":\"leetcode\",\"char_count\":7029,\"short_content\":\"\\n\\n\\n\\n### 56.Merge Intervals(Medium)\\n\\nGiven a collection of intervals, merge all overlapping intervals.\\n\\n**Example 1:**\\n\\n\",\"abbrlink\":\"1kv61wq\"},{\"title\":\"Leetcode-51~55\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\",\"n-queens\",\"backtrack\"],\"date\":\"2019-03-30T02:57:00.000Z\",\"series\":\"leetcode\",\"char_count\":11884,\"short_content\":\"\\n\\n\\n\\n### 51. N-Queens(Hard)\\n\\nThe *n*-queens puzzle is the problem of placing *n* queens on an *n*×*n* chessboard such that no two queens attack each other.\\n\\n\\n\\n\",\"abbrlink\":\"xmbex2\"},{\"title\":\"Leetcode-46~50\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\",\"permutation\",\"backtrack\",\"mypow\"],\"date\":\"2019-03-27T07:39:00.000Z\",\"series\":\"leetcode\",\"char_count\":6440,\"short_content\":\"\\n\\n\\n\\n### 46. Permutation(Medium)\\n\\nGiven a collection of **distinct** integers, return all possible permutations.\\n\\n**Example:**\\n\\n\",\"abbrlink\":\"jywoys\"},{\"title\":\"Some Backtracking Problem In Leetcode\",\"categories\":[\"algorithm\",\"backtracking\"],\"tags\":[\"leetcode\",\"backtracking\"],\"date\":\"2019-03-24T08:26:00.000Z\",\"char_count\":10792,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n在Leetcode上做到某些题的时候，会发现这些题的解法大致都是差不多，将**ans容器**传递到某个方法中，这个方法一般有`dfs`，`backtracking`，`bfs`，等命名，然后方法中会有递归调用，然后到达某一个出口的时候，就会将当前的**tmp答案**放置到**ans容器**中，于是达到探索所有解的目的\\n\\n这篇大概也是各个题的题解，只是在评论区里看到有人[整理](https://leetcode.com/problems/permutations/discuss/18239/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partioning))了，我就一起整理下来分析分析\\n\\n\",\"abbrlink\":\"1x7azit\"},{\"title\":\"DP Again\",\"categories\":[\"algorithm\",\"dp\"],\"tags\":[\"dp\"],\"date\":\"2019-03-22T06:14:00.000Z\",\"char_count\":18172,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n我们先分析Leetcode的55题，是从45题Jump Game II 跳过来的，因为这题比II要简单一点，只需要判断序列是否能jump到终点就行，而45题是要找最小的jump次数；\\n\\n为什么这题要拿出篇幅来分析？因为这题包含了很多东西： \\n\\n\",\"abbrlink\":\"1flo1c0\"},{\"title\":\"Leetcode-41~45\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\"],\"date\":\"2019-03-20T20:03:00.000Z\",\"series\":\"leetcode\",\"char_count\":10695,\"short_content\":\"\\n\\n\\n\\n### 41. First Missing Postive(Hard)\\n\\nGiven an unsorted integer array, find the smallest missing positive integer.\\n\\n**Example 1:**\\n\\n\",\"abbrlink\":\"11z93zc\"},{\"title\":\"Leetcode-36~40\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\",\"sudoku\",\"combination-sum\"],\"date\":\"2019-03-20T19:46:00.000Z\",\"series\":\"leetcode\",\"char_count\":8096,\"short_content\":\"\\n\\n\\n\\n### 36. Valid Sudoku(Medium)\\n\\nDetermine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:\\n\\n1. Each row must contain the digits `1-9` without repetition.\\n2. Each column must contain the digits `1-9` without repetition.\\n\",\"abbrlink\":\"v6ei19\"},{\"title\":\"再谈对象分代和GC事件\",\"categories\":[\"java\",\"jvm\",\"memory\"],\"tags\":[\"gc\",\"gc-event\",\"generation-type\"],\"date\":\"2019-03-18T20:46:00.000Z\",\"char_count\":2378,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n之前在搜OOM的时候，无意中发现了[https://plumbr.io/](https://plumbr.io/)这个网站，它们的产品就是做内存监控工具之类的，于是官网上也有很多关于JVM的GC方面的技术博客，简直和挖到宝藏了一样- -\\n\\n本篇主要是针对对象在堆上的分代和GC事件再做一些细致的了解，主要也是参考网站里的内容\\n\\n\",\"abbrlink\":\"wlvrl9\"},{\"title\":\"字节跳动2019-03-16后端笔试\",\"categories\":[\"algorithm\",\"notes\"],\"tags\":[\"笔试\"],\"date\":\"2019-03-16T22:22:00.000Z\",\"char_count\":6307,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n就A了签到题，我觉得这次笔试很简单了，可是后面3题没过一个case，题目不难，各种各样的失误8，说到底菜才是原罪，还是得多刷题\\n\\n和leecode不一样的是：\\n\\n\",\"abbrlink\":\"djlqql\"},{\"title\":\"Leetcode-31~35\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\"],\"date\":\"2019-03-16T21:46:00.000Z\",\"series\":\"leetcode\",\"char_count\":7919,\"short_content\":\"\\n\\n\\n\\n### 31. Next Permutation(Medium)\\n\\nImplement **next permutation**, which rearranges numbers into the lexicographically next greater permutation of numbers.\\n\\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\\n\\n\",\"abbrlink\":\"dbne5d\"},{\"title\":\"Leetcode-26~30\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\"],\"date\":\"2019-03-09T16:21:00.000Z\",\"series\":\"leetcode\",\"char_count\":12579,\"short_content\":\"\\n\\n\\n\\n### 26. Remove Duplicated From Sorted Array(Easy)\\n\\nGiven a sorted array *nums*, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each element appear only *once* and return the new length.\\n\\nDo not allocate extra space for another array, you must do this by **modifying the input array in-place** with O(1) extra memory.\\n\\n\",\"abbrlink\":\"448jer\"},{\"title\":\"Leetcode-21~25\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\"],\"date\":\"2019-03-06T21:17:00.000Z\",\"series\":\"leetcode\",\"char_count\":10031,\"short_content\":\"\\n\\n\\n\\n### 21. Merge Two Sorted Lists(Easy)\\n\\nMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\\n\\n**Example:**\\n\\n\",\"abbrlink\":\"1hrw4sv\"},{\"title\":\"Leetcode-16~20\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\"],\"date\":\"2019-03-06T20:13:00.000Z\",\"series\":\"leetcode\",\"char_count\":8964,\"short_content\":\"\\n\\n\\n\\n### 16.3SumClosest(Medium)\\n\\nGiven an array `nums` of *n* integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.\\n\\n**Example:**\\n\\n\",\"abbrlink\":\"3yl2hx\"},{\"title\":\"Help GC A Favor & JIT Introduction\",\"categories\":[\"java\",\"jvm\",\"gc\"],\"tags\":[\"JVM\",\"GC\",\"JIT\",\"OOM\"],\"date\":\"2019-03-04T04:19:00.000Z\",\"char_count\":9091,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n之前我们了解过GC的很多行为和特点了，也大致知道OOM发生的地点和原因，然后还深入了解了Java中的Reference\\n\\n接下来我们简单说一下如何避免OOM，帮GCor们一个小忙\\n\\n\",\"abbrlink\":\"12iaggv\"},{\"title\":\"Java's Refernece\",\"categories\":[\"java\",\"grammar\"],\"tags\":[\"reference-type\"],\"date\":\"2019-03-02T21:08:00.000Z\",\"char_count\":7461,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n本篇主要内容：\\n\\n1. Java 到底是值传递还是引用传递\\n2. Java 中的引用类型详解以其应用场景\\n\",\"abbrlink\":\"13tt0au\"},{\"title\":\"The Revelation of Java String\",\"categories\":[\"java\",\"jvm\",\"memory\"],\"tags\":[\"java-string\",\"string-pool\"],\"date\":\"2019-03-02T13:50:00.000Z\",\"char_count\":15433,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\nJava中的`String`其实有很多东西可以深入的，比如最快拼接效率，比如常量池，比如老生常谈的`==`问题\\n\\n研究它们的时候我们始终要记住，`String`是不可变的**（immutable）**\\n\\n\",\"abbrlink\":\"46bhg0\"},{\"title\":\"Leetcode-11~15\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\"],\"date\":\"2019-02-27T21:42:00.000Z\",\"series\":\"leetcode\",\"char_count\":9865,\"short_content\":\"\\n\\n\\n\\n### 11. Container With Most Water(Medium)\\n\\nGiven *n* non-negative integers *a1*, *a2*, ..., *an* , where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\\n\\n**Note:** You may not slant the container and *n* is at least 2.\\n\\n\",\"abbrlink\":\"2gps3g\"},{\"title\":\"最近点对及其相关问题\",\"categories\":[\"algorithm\",\"notes\"],\"comments\":true,\"date\":\"2019-02-26T23:04:00.000Z\",\"tags\":[\"algorithm\",\"twopoint\"],\"char_count\":5911,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n二维坐标中有一堆点集，记为P，假设P中至少有2个点，那么求出P中距离最近的两个点；\\n\\n首先为了问题准备好点和求两点距离的方法，其中如果两点距离的输入只有一个点，那么它的距离代表无穷大，它表示没有解\\n\\n\",\"abbrlink\":\"1d9upzt\"},{\"title\":\"Leetcode-6~10\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\"],\"date\":\"2019-02-17T13:18:00.000Z\",\"series\":\"leetcode\",\"char_count\":16445,\"short_content\":\"\\n\\n\\n\\n### 6. ZigZag Conversion(Medium)\\n\\nThe string `\\\"PAYPALISHIRING\\\"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\\n\\n```graph\\nP   A   H   N\\n```\\n\",\"abbrlink\":\"t1f0vq\"},{\"title\":\"Hashing\",\"categories\":[\"data structures\",\"hash\"],\"tags\":[\"algorithm\",\"hash\"],\"date\":\"2019-02-02T20:40:00.000Z\",\"char_count\":5419,\"short_content\":\"\\n\\n\\n\\n### What is HashTable\\n\\nOf all structure we learn before like \\\"array\\\" or \\\"stack\\\", the element's position on their structure is not absolute, it's uncertain which means there is no pattern on it.  \\n\\nSo the searching operation was always base on \\\"comparing\\\",  the searching efficiency of them were dependence on the times they perform compare.\\n\\n\",\"abbrlink\":\"1f3qusx\"},{\"title\":\"Leetcode-1~5\",\"categories\":[\"algorithm\",\"leetcode\"],\"tags\":[\"leetcode\"],\"date\":\"2019-02-02T19:51:00.000Z\",\"series\":\"leetcode\",\"char_count\":19301,\"short_content\":\"\\n\\n\\n\\n### 1. TwoSum(Easy)\\n\\nGiven an array of integers, return **indices** of the two numbers such that they add up to a specific target.\\n\\nYou may assume that each input would have **exactly** one solution, and you may not use the *same* element twice.\\n\\n\",\"abbrlink\":\"pn2ezr\"},{\"title\":\"Tree Binary Tree\",\"categories\":[\"data structures\",\"tree\"],\"tags\":[\"algorithm\",\"binary-tree\",\"tree\",\"dfs\",\"bfs\"],\"date\":\"2019-01-30T21:36:20.000Z\",\"char_count\":4608,\"short_content\":\"\\n\\n\\n\\n### Basic Algorithm In Binary Tree\\n\\n#### Traverse\\n\\nA Tree is typically traversed in two ways:\\n\\n\",\"abbrlink\":\"1aew5v7\"},{\"title\":\"Tree Introduction\",\"categories\":[\"data structures\",\"tree\"],\"tags\":[\"algorithm\",\"binary-tree\"],\"date\":\"2019-01-28T15:11:00.000Z\",\"char_count\":5333,\"short_content\":\"\\n\\n\\n\\n### Should have a PLAN!\\n\\nI was asked a tree problem when I was having a face to face interview at *PayPal* last Friday, and I might failed on this question.\\n\\nIt's been too long that I'm almost forgot the knowledge of TREE, and I've never truly go over it and it's time to get it done.\\n\\n\",\"abbrlink\":\"1qvt6fv\"},{\"title\":\"Java并发编程第八坎\",\"categories\":[\"java\",\"concurrency\",\"《艺术》与《技术》\"],\"comments\":true,\"tags\":[\"java\",\"thread\",\"Lock-Api\",\"reentrantLock\",\"reentrantReadWriteLock\"],\"date\":\"2019-01-07T22:46:48.000Z\",\"series\":\"并发\",\"char_count\":15613,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n我们对Lock和AQS有了一定的了解了之后，可以尝试着接触一些Lock+AQS的基本实现了，本篇会了解到最基本的同步组件`ReentrantLock`和`ReentrantReadWriteLock`，前者提供了排他锁的实现，并且支持重入，后者在前者的基础上，支持锁的分级，写锁排他读锁共享。特别的，重入锁的获取还有公平和非公平之分，我们先从这部分入手。\\n\\n#### Fair Lock & Nonfair Lock\\n\\n\",\"abbrlink\":\"1u7rv30\"},{\"title\":\"CLH Lock Queue\",\"categories\":[\"data structures\",\"list\"],\"tags\":[\"algorithm\",\"clh-lock-queue\"],\"date\":\"2018-12-30T16:35:00.000Z\",\"char_count\":4711,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n在学习Java并发中的同步器源码的时候，注释中有提到过AQS的Node结构是参考CLH的一种变体：\\n\\n> The wait queue is a variant of a \\\"CLH\\\" (Craig, Landin, and Hagersten) lock queue. \\n>\\n\",\"abbrlink\":\"vywf17\"},{\"title\":\"Java并发编程第七坎-2\",\"categories\":[\"java\",\"concurrency\",\"《艺术》与《技术》\"],\"comments\":true,\"tags\":[\"java\",\"thread\",\"AQS\"],\"date\":\"2018-12-30T12:58:48.000Z\",\"series\":\"并发\",\"char_count\":19385,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n上节我们介绍了Java并发编程的一个新的阶段——Java并发包中的`Lock`接口以及`AbstractQueuedSynchronizer`的配合使用\\n\\n并且尝试实现了一个简单的独占锁Mutex，借此我们了解到，并发编程还能如此灵活与优雅\\n\\n\",\"abbrlink\":\"u4sgci\"},{\"title\":\"Java并发编程第七坎\",\"categories\":[\"java\",\"concurrency\",\"《艺术》与《技术》\"],\"comments\":true,\"tags\":[\"java\",\"thread\",\"AQS\",\"Lock-Api\"],\"date\":\"2018-12-25T22:22:48.000Z\",\"series\":\"并发\",\"char_count\":9004,\"short_content\":\"\\n\\n\\n\\n\\n\\n### Introduction\\n\\n> 事前吐槽：*Doug Lea*老爷子的注释可真难读，也许是我英语太菜鸡了- -（本来还挺自信的，现在哭着学英语）\\n\\n\",\"abbrlink\":\"7kdfk8\"},{\"title\":\"Docker Volumes\",\"categories\":[\"docker\",\"notes\"],\"tags\":[\"docker\",\"volume\"],\"date\":\"2018-12-05T10:23:09.000Z\",\"series\":\"docker\",\"char_count\":8431,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n> **Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.** While [bind mounts](https://docs.docker.com/storage/bind-mounts/) are dependent on the directory structure of the host machine, **volumes are completely managed by Docker**. Volumes have several advantages over bind mounts:\\n>\\n> - Volumes are easier to back up or migrate than bind mounts.\\n> - You can manage volumes using Docker CLI commands or the Docker API.\\n\",\"abbrlink\":\"1ae6lng\"},{\"title\":\"Docker Persist Data Overview\",\"categories\":[\"docker\",\"notes\"],\"tags\":[\"docker\",\"volume\"],\"date\":\"2018-12-04T09:44:33.000Z\",\"series\":\"docker\",\"char_count\":7276,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\nBy default all files created inside a container are stored on a writable container layer.\\n\\nThat means that the data doesn't persist when that container no longer exists, and it can be difficult to get the data out of the container if another process needs it.\\n\\n\",\"abbrlink\":\"lt42s8\"},{\"title\":\"Docker ConceptReview\",\"categories\":[\"docker\",\"notes\"],\"tags\":[\"docker\"],\"date\":\"2018-12-02T12:39:09.000Z\",\"series\":\"docker\",\"char_count\":7660,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\nIn this section, we will go through all the main concepts of docker technologies such as : **Docker Engine**, **Docker Architecture**, **Docker underlying technology**.\\n\\nBasically reprinted from: https://docs.docker.com/engine/docker-overview, but I will make some adjustment for better understanding.\\n\\n\",\"abbrlink\":\"rx7jt4\"},{\"title\":\"Docker Stack\",\"categories\":[\"docker\",\"notes\"],\"tags\":[\"docker\"],\"date\":\"2018-11-29T16:46:00.000Z\",\"series\":\"docker\",\"char_count\":6394,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\nAt the part of \\\"Container\\\", we've know we can define a `docker-compose.yaml` to deploy a service on our swarm so it can run on multiple machine.\\n\\nAs we practice before, our service just contains one container: a python app that provide web service with Flask.\\n\\n\",\"abbrlink\":\"u7sd0w\"},{\"title\":\"Docker Swarm&ClusterSetup\",\"categories\":[\"docker\",\"notes\"],\"tags\":[\"docker\",\"cluster\",\"swarm\"],\"date\":\"2018-11-28T21:06:03.000Z\",\"series\":\"docker\",\"char_count\":10989,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\nIn the last post, we discussed the relationship between Application and Service. \\n\\nSo they say: **Services are really just \\\"Containers in Production\\\".**\\n\\n\",\"abbrlink\":\"1toixsk\"},{\"title\":\"Docker Service&Composefile\",\"categories\":[\"docker\",\"notes\"],\"tags\":[\"docker\",\"compose-file\"],\"date\":\"2018-11-27T12:19:02.000Z\",\"series\":\"docker\",\"char_count\":5865,\"short_content\":\"\\n\\n\\n\\n### Service\\n\\nIn a distributed application, different pieces of the app are called “services.” For example, if you imagine a video sharing site, it probably includes **[1]a service for storing application data in a database**, **[2]a service for video transcoding in the background after a user uploads something**, **[3]a service for the front-end**, and so on.\\n\\nServices are really just “containers in production.” A service only runs one image, but it codifies the way that image runs:\\n\\n\",\"abbrlink\":\"zkr55u\"},{\"title\":\"Jenkins Introductions&Setup\",\"categories\":[\"jenkins\",\"notes\"],\"tags\":[\"setup\",\"jenkins\"],\"date\":\"2018-11-19T14:51:00.000Z\",\"series\":\"jenkins\",\"char_count\":4106,\"short_content\":\"\\n\\n### Introductions\\n\\n首先Jenkins要吐槽一下，Jenkins的Logo真的是太丑了，虽然很明显是一个管家形象- -\\n\\n\\n\\nJenkins的默认UI也有点丑，还不如官网的UI好看\\n\\n\",\"abbrlink\":\"1arzjog\"},{\"title\":\"写在21岁的最后一天\",\"categories\":[\"essay\"],\"date\":\"2018-11-17T15:53:00.000Z\",\"char_count\":3466,\"short_content\":\"\\n\\n\\n\\n#### 0. 特定的时刻\\n\\n我是完全不过生日的, 不要礼物不要钱, 不请朋友大鱼大肉也不买蛋糕许愿望更不拉帮结派开party, 过生日我只会想家人想妈妈\\n\\n但是今年这个生日有点特殊吧\\n\\n\",\"abbrlink\":\"1xetsy3\"},{\"title\":\"关于JVM的GC行为和内存分配\",\"categories\":[\"java\",\"jvm\",\"gc\"],\"comments\":true,\"date\":\"2018-11-17T15:35:00.000Z\",\"tags\":[\"jvm\",\"generation-type\",\"gc\",\"gc算法\",\"root-point\",\"saft-point\",\"safe-area\"],\"series\":\"JVM\",\"char_count\":6406,\"short_content\":\"\\n\\n\\n\\n### 对象分代和朝生夕灭\\n\\n对象所在的内存区按照对象存活的时间长久会简单分为：新生代、老年代\\n\\n**Garbage Collector**的行为和对象内存所在的区域有很大关系，所以在分析**Collector**之前，我们得先了解一下对象内存的分区\\n\\n\",\"abbrlink\":\"jhpq7e\"},{\"title\":\"Docker Containers&Dockerfile\",\"categories\":[\"docker\",\"notes\"],\"tags\":[\"docker\"],\"date\":\"2018-11-16T15:05:11.000Z\",\"series\":\"docker\",\"char_count\":9082,\"short_content\":\"\\n\\n### Introduction\\n\\n本篇主要介绍Docker里面Containers的概念，以及它的定义\\n\\n还有就是如何分享你创建的Containers到hub上面\\n\\n需要注意的是，containers的定义其实就是image的定义\\n\\n\",\"abbrlink\":\"uh480l\"},{\"title\":\"Tess login on Jenkins\",\"categories\":[\"eBay\"],\"tags\":[\"tess\"],\"date\":\"2018-11-16T14:10:08.000Z\",\"char_count\":6842,\"short_content\":\"\\n\\n\\n\\n### Tess login on Jenkins\\n\\n#### Use tess with Rheos tess-base agent\\n\\nAssume that you are at \\\"Job Configure\\\" panel now.\\n\\n\",\"abbrlink\":\"1gukab6\"},{\"title\":\"Introductions of eBay Tess\",\"categories\":[\"eBay\"],\"tags\":[\"eBay\",\"tess\"],\"date\":\"2018-11-15T16:18:00.000Z\",\"char_count\":6149,\"short_content\":\"\\n\\n### Tess\\n\\n#### 0. What is Tess? \\n\\nTess.IO is eBay’s cluster manager, with a vision of ensuring a world-class **build, ship and run** experience for eBay’s applications at scale, while ensuring high efficiency, security, and agility to the developers. Tess.IO leverages Kubernetes under its hood. Kubernetes (commonly referred to as “k8s”) is an open source container cluster manager that aims to provide a “platform for automating deployment, scaling, and operations of application containers across clusters of hosts.”\\n\\nTess makes DevOps a breeze.\\n\\n\",\"abbrlink\":\"2032k5\"},{\"title\":\"关于JVM的运行时数据区上的GC\",\"categories\":[\"java\",\"jvm\",\"gc\"],\"comments\":true,\"date\":\"2018-11-14T22:45:00.000Z\",\"tags\":[\"jvm\",\"gc\",\"reference-type\",\"finalize\"],\"series\":\"JVM\",\"char_count\":2770,\"short_content\":\"\\n\\n\\n\\n### Introduction\\n\\n本篇主要介绍什么是GC，GC一般发生在哪里，GC在这些地方都干些什么\\n\\n顺带简单提一下四种**引用类型**以及`finalize()`方法\\n\\n\",\"abbrlink\":\"d5ykz8\"},{\"title\":\"关于JVM的对象创建与访问\",\"categories\":[\"java\",\"jvm\",\"memory\"],\"comments\":true,\"date\":\"2018-11-14T21:45:00.000Z\",\"tags\":[\"jvm\",\"jvm对象创建\"],\"series\":\"JVM\",\"char_count\":3017,\"short_content\":\"\\n\\n\\n\\n### HotSpot虚拟机对象内存\\n\\n深入讨论HotSpot虚拟机在Java堆中的对象分配、内存布局和对象访问的过程\\n\\n#### 对象创建流程\\n\\n\",\"abbrlink\":\"18669ga\"},{\"title\":\"Docker Orientation&Setup\",\"categories\":[\"docker\",\"notes\"],\"tags\":[\"docker\"],\"date\":\"2018-11-14T13:50:11.000Z\",\"series\":\"docker\",\"char_count\":7527,\"short_content\":\"\\n\\n### Docker concepts\\n\\nDocker is a platform for developers and sysadmins to **develop, deploy, and run** applications with containers. The use of Linux containers to deploy applications is called *containerization*. Containers are not new, but their use for easily deploying applications is.\\n\\nContainerization is increasingly popular because containers are:\\n\\n- Flexible: Even the most complex applications can be containerized.\\n- Lightweight: Containers leverage and share the host kernel.\\n\",\"abbrlink\":\"1ei198o\"},{\"title\":\"kafka-topic-storage-detail\",\"categories\":[\"kafka\",\"notes\"],\"tags\":[\"kafka\"],\"date\":\"2018-11-06T16:34:00.000Z\",\"char_count\":6078,\"short_content\":\"\\n\\n### Topic & Partition\\n\\nkafka中的Message以topic为分类去组织的，每个topic又可以分为不同的partition去存储：\\n\\n\\n\\n我们引用官方的Introduction中的一节，看官方是怎么解释的：\\n\\n\",\"abbrlink\":\"1ro5m3y\"},{\"title\":\"kafka-helloworld-concept\",\"categories\":[\"kafka\",\"notes\"],\"tags\":[\"kafka\"],\"date\":\"2018-11-06T15:39:00.000Z\",\"char_count\":6890,\"short_content\":\"\\n\\n### 前言\\n\\n因为Intern Job的原因，要接触到kafka和Microservice，虽然目前接触的不是很多，对于kafka的场景还不是很熟悉，但是总觉得这个东西是必学的，也是很重要的一种趋势\\n\\n于是前几天给帖老板写的Graduation Design里写的就是kafka+springboot+opentracing的tracing监控系统\\n\\n难度还是有的，springboot刚上手，opentracing的api在前一个月的工作里面也算是熟悉了，关键就是kafka以及如何把这几个玩意整合起来\\n\\n\",\"abbrlink\":\"u28b7l\"},{\"title\":\"微服务架构理论基础-康威定律\",\"categories\":[\"reprinted\"],\"date\":\"2018-11-06T10:44:01.000Z\",\"char_count\":6981,\"short_content\":\"\\n\\n### 前言\\n\\n> 可能出乎很多人意料之外的一个事实是，微服务很多核心理念其实在半个世纪前的一篇文章中就被阐述过了，而且这篇文章中的很多论点在软件开发飞速发展的这半个世纪中竟然一再被验证，这就是康威定律。\\n\\n### 概述\\n\\n微服务是最近非常火热的新概念，大家都在追，也都觉得很对，但是似乎没有很充足的理论基础说明这是正确的，给人的感觉是 **不明觉厉** 。前段时间看了Mike Amundsen [《远距离条件下的康威定律——分布式世界中实现团队构建》](http://www.infoq.com/cn/presentations/team-building-implementation-in-distributed-world)（是Design RESTful API的作者）在InfoQ上的一个分享，觉得很有帮助，结合自己的一些思考，整理了该演讲的内容。\\n\\n\",\"abbrlink\":\"pjff39\"},{\"title\":\"微服务（Microservice）那点事\",\"categories\":[\"reprinted\"],\"date\":\"2018-11-06T10:21:00.000Z\",\"char_count\":7793,\"short_content\":\"\\n\\n### 前言\\n\\n> 微服务架构被提出很短的时间内，就被越来越多的开发人员推崇，简单来说其主要的目的是有效的拆分应用，实现敏捷开发和部署 。\\n>\\n> 本分享即尝试介绍微服务架构的一些实施细节和要求，探询微服务架构的由来，并最终提供我们团队内部的一些实践总结，希望对大家有帮助。\\n\\n### WHAT - 什么是微服务\\n\\n\",\"abbrlink\":\"1kb6gry\"},{\"title\":\"Graduation Design\",\"categories\":[\"essay\"],\"comments\":true,\"date\":\"2018-11-02T21:56:10.000Z\",\"char_count\":1796,\"short_content\":\"\\n\\n\\n\\n#### Graduation Design\\n\\n- Title：Tracing Monitoring System of Kafka-Cluster with Opentracing API\\n- Framework：B/S\\n- Technology stack：\\n    - back-end：\\n\",\"abbrlink\":\"q0aas8\"},{\"title\":\"地痞（DP）成长记\",\"categories\":[\"algorithm\",\"dp\"],\"comments\":true,\"tags\":[\"algorithm\",\"dp\"],\"date\":\"2018-08-30T20:58:01.000Z\",\"char_count\":19492,\"short_content\":\"\\n\\n\\n\\n### 大声BB\\n\\n为了以后看到一道我知道是用DP但是不知道如何去DP的问题再也不会束手无策\\n\\n决心做一个地痞，至少下次看到一个DP不会再被它DP\\n\\n\",\"abbrlink\":\"188zp6j\"},{\"title\":\"AVL树和红黑树\",\"categories\":[\"data structures\",\"tree\"],\"comments\":true,\"date\":\"2018-08-27T15:05:00.000Z\",\"tags\":[\"BST\",\"AVL\",\"RBT\",\"algorithm\",\"tree\"],\"char_count\":8649,\"short_content\":\"\\n\\n### 小声BB\\n\\n本篇尽量不po代码，仅仅过一遍AVL树和红黑树\\n\\n其中红黑树更是在HashMap中大展身手，肯定要研究一下为什么他们要用到RBT\\n\\n--------------\\n\\n\",\"abbrlink\":\"wji6g0\"},{\"title\":\"查找大礼包\",\"categories\":[\"algorithm\",\"searching\"],\"comments\":true,\"date\":\"2018-08-22T13:10:00.000Z\",\"tags\":[\"algorithm\",\"search\"],\"char_count\":13106,\"short_content\":\"\\n\\n\\n\\n#### 小声BB\\n\\n整理一波查找相关的东西\\n\\n- 几个元素查找算法如：\\n  - 顺序查找\\n\",\"abbrlink\":\"bg6w8m\"},{\"title\":\"把HashMap安排得明明白白\",\"categories\":[\"java\",\"collections-framework\"],\"comments\":true,\"date\":\"2018-08-16T12:12:21.000Z\",\"tags\":[\"hashmap\",\"collections-framework\"],\"series\":\"从头到尾读\",\"char_count\":24148,\"short_content\":\"\\n\\n\\n\\n### 前言\\n\\n一言难尽 直接开始吧 时间有限 就不一一解读接口了\\n\\n这篇是逐行级别的`HashMap`的**“基础操作”**源码解读，仅仅分析一些核心的**单元素基础操作（CRUD）**，尽可能从大框架思路去分析实现思路，一些太细的变量和无关操作，就不分析太多了\\n\\n\",\"abbrlink\":\"ofa68o\"},{\"title\":\"算法回收站\",\"categories\":[\"algorithm\",\"notes\"],\"comments\":true,\"date\":\"2018-08-11T13:41:10.000Z\",\"tags\":[\"algorithm\"],\"char_count\":2123,\"short_content\":\"\\n\\n\\n\\n### 前言\\n\\n这篇记录下从今天开始，复习到、新遇到的所有算法题\\n\\n- 栈相关\\n- 数学逻辑相关\\n\",\"abbrlink\":\"8lcrnu\"},{\"title\":\"记一次设计模式之旅\",\"categories\":[\"design-pattern\"],\"comments\":true,\"date\":\"2018-08-09T15:21:33.000Z\",\"tags\":[\"design-pattern\"],\"char_count\":18508,\"short_content\":\"\\n\\n\\n\\n### 前言\\n\\n我\\n\\n面试（大约两个月前）\\n\\n\",\"abbrlink\":\"9h3hmp\"},{\"title\":\"Java并发编程第六坎\",\"categories\":[\"java\",\"concurrency\",\"《艺术》与《技术》\"],\"comments\":true,\"tags\":[\"java\",\"thread\",\"dead-lock\",\"wait/notify\",\"consumer/producer\",\"double-check-singleton\"],\"date\":\"2018-07-25T21:33:48.000Z\",\"series\":\"并发\",\"char_count\":11132,\"short_content\":\"\\n\\n\\n### 前言\\n\\n不知不觉写到第六坎了，前面刀剑磨刀石内功心法都有了，感觉自己应该很厉害了，其实不是，这一个月因为考试末尾和实习，断断续续的看，反反复复的看，越看越精神，越看越心虚。\\n\\n无论怎么说，短板还是得慢慢补上来，保持谦逊，虚心学习。\\n\\n回到整体，前面由内到外说了Java并发中很基本的几件事：\\n\",\"abbrlink\":\"139027a\"},{\"title\":\"Java并发编程第五坎\",\"categories\":[\"java\",\"concurrency\",\"《艺术》与《技术》\"],\"comments\":true,\"tags\":[\"java\",\"thread\",\"JMM\",\"happens-before\",\"volatile语义\",\"锁语义\"],\"date\":\"2018-07-21T19:33:48.000Z\",\"series\":\"并发\",\"char_count\":9080,\"short_content\":\"\\n\\n\\n\\n### 前言\\n\\n前面说了好多好多刀枪剑，还说了一些最前置的内功心法，这回说说更深层的内功心法——**JMM，Java Memory Model，Java内存模型！**\\n\\nJava线程之间的通信对程序员是完全透明的（你是很难感知得到的），所以内存可见性问题经常称为并发的通病之一，这坎说的内存模型，是让你更好地去感知，去推断线程内存通信的有力武器。\\n\\n\",\"abbrlink\":\"1xo3tpx\"},{\"title\":\"Java并发编程第四坎\",\"categories\":[\"java\",\"concurrency\",\"《艺术》与《技术》\"],\"comments\":true,\"tags\":[\"java\",\"thread\",\"volatile\",\"synchronized\"],\"date\":\"2018-07-18T14:16:48.000Z\",\"series\":\"并发\",\"char_count\":11682,\"short_content\":\"\\n\\n\\n\\n### 前言\\n\\n这回说说Java并发编程第四坎，最常用的**volatile和synchronized关键字**，这两个关键字是理解java同步编程的第一步，特别是**synchronized关键字**\\n\\n而在*《Java多线程编程核心技术》*的第2.1节中，作者不经意的道出了**线程同步的真谛之一：避免脏读**\\n\\n\",\"abbrlink\":\"db3vx3\"},{\"title\":\"Java并发编程第三坎\",\"categories\":[\"java\",\"concurrency\",\"《艺术》与《技术》\"],\"comments\":true,\"tags\":[\"java\",\"thread\",\"CAS\",\"锁分类\"],\"date\":\"2018-07-18T14:15:22.000Z\",\"series\":\"并发\",\"char_count\":4267,\"short_content\":\"\\n\\n\\n\\n### 前言\\n\\n前两篇基本说了线程的基本概念和基本使用，这回说说Java并发编程第三坎，关于锁的好多基本概念的提前了解\\n\\n在讲锁之前，我们还需要介绍一个很重要的原理——CAS（Compare And Swap）操作，这个操作是保证并发过程中每个操作具有**“原子性”**的利器\\n\\n\",\"abbrlink\":\"1h1ww1y\"},{\"title\":\"Java并发编程第二坎\",\"categories\":[\"java\",\"concurrency\",\"《艺术》与《技术》\"],\"comments\":true,\"tags\":[\"java\",\"thread\",\"interrupt\",\"stop&suspend&resume\"],\"date\":\"2018-07-15T10:53:22.000Z\",\"series\":\"并发\",\"char_count\":12405,\"short_content\":\"\\n\\n\\n\\n### 前言\\n\\n前一篇基本说了线程的基本概念和如何创建一个线程，以及非常基本的几个线程方法，接下来我们说说线程的前几个控制相关的方法，包括和暂停一个线程（PAUSE）、让暂停的线程恢复（RESUME）、让线程终止（STOP）\\n\\n这篇我们但是这几个方法不能直接去用，因为这些方法都**过期了**！下面就着Java官方的文档解释，说说为什么过期这几个方法，以及贴出官方给的模板方法去实现这几个过期方法，具体的实现会在后面有例子\\n\\n\",\"abbrlink\":\"1clnpuk\"},{\"title\":\"计算机网络-谢希仁-2\",\"categories\":[\"booknotes\",\"计算机网络\"],\"comments\":true,\"date\":\"2018-07-03T20:44:33.000Z\",\"tags\":[\"计算机网络\"],\"series\":\"《计算机网络》\",\"char_count\":3188,\"short_content\":\"\\n\\n\\n\\n### Chapter2-物理层\\n\\n物理层是计网体系结构中的最下面一层，本章主要介绍：\\n\\n1. 物理层的基本任务\\n2. 几种常用的信道复用技术\\n\",\"abbrlink\":\"1nz333d\"},{\"title\":\"计算机网络-谢希仁-1\",\"categories\":[\"booknotes\",\"计算机网络\"],\"comments\":true,\"date\":\"2018-06-30T10:28:33.000Z\",\"tags\":[\"计算机网络\"],\"series\":\"《计算机网络》\",\"char_count\":7311,\"short_content\":\"\\n\\n\\n\\n### 前言\\n\\n一周前考完了计算机网络，不得不说，计算机网络确实是一个精妙而繁杂的体系产物，虽然民大的考试都很水，但是计网这门课我是认认真真复习好了的，并不是当作考试去复习，每个点都看了，书上的课后习题都大概刷了80%（谢希仁前辈出的这本书，习题量很多），基本上每个点都吃透了一遍。\\n\\n虽然后面还有两门考试，但很容易就过，也不需要准备，主要的复习科目也考完了，所以趁热打铁，马上进行计网的笔记整理和复习。\\n\\n\",\"abbrlink\":\"1k7g0p3\"},{\"title\":\"Java并发编程第一坎\",\"categories\":[\"java\",\"concurrency\",\"《艺术》与《技术》\"],\"comments\":true,\"tags\":[\"java\",\"thread\",\"wait/notify\"],\"date\":\"2018-06-05T22:09:00.000Z\",\"series\":\"并发\",\"char_count\":13142,\"short_content\":\"\\n\\n\\n\\n### 前言\\n\\n本**系列**文章主要是为Java并发入门做铺垫，集中清点：\\n\\n- **Thread的基本概念**\\n- **生命周期**\\n\",\"abbrlink\":\"bu9klx\"},{\"title\":\"从头到尾读ArrayList\",\"categories\":[\"java\",\"collections-framework\"],\"comments\":true,\"date\":\"2018-06-05T08:31:21.000Z\",\"tags\":[\"arraylist\",\"collections-framework\"],\"series\":\"从头到尾读\",\"char_count\":15573,\"short_content\":\"\\n\\n#### ArrayList类\\n\\n对终于要正式开始读**ArrayList**的源码了，虽然**ArrayList**的源码价值并不是那么地大，但作为集合框架源码阅读的第一站来说，我选择了在这里站稳脚跟\\n\\n这个计划搁置了很久，大概有15天，中间跑去面试了一个星期，面试下来发现自己的基础已经忘的差不多了，决定回来好好沉淀一段时间，暑期实习offer有没有已经不重要了，**剑指秋招！**\\n\\n为什么要读它，因为线性表几乎是数据结构的基础必备，昨晚花了将近1小时手撸了一个ArrayList的自实现，再搭配源码来看**自己在基础方法上有哪些没考虑到的点**，以及**实际投入使用的ArrayList到底优秀在哪里**\\n\\n\",\"abbrlink\":\"rku8jh\"},{\"title\":\"自实现ArrayList\",\"categories\":[\"java\",\"collections-framework\"],\"comments\":true,\"date\":\"2018-06-04T22:47:12.000Z\",\"tags\":[\"arraylist\"],\"char_count\":4849,\"short_content\":\"\\n\\n\\n\\n#### 前言\\n\\n最近在复习**数据结构**和**算法**，这两个玩意也是被称之为**“程序员的基本素养”**，我最近比较想干的一件事就是读集合框架的源码\\n\\n基于这个伟大目标，我开启了源码阅读的**“从头到尾读”**系列，目前只完成了**Collection接口、Iterable接口、Iterator接口**这三个章节，正打算开始读**ArrayList**的源码\\n\\n\",\"abbrlink\":\"1gfw5vx\"},{\"title\":\"Java运算符知多少\",\"categories\":[\"java\",\"grammar\"],\"comments\":true,\"tags\":[\"java\",\"operator\"],\"date\":\"2018-06-03T21:28:00.000Z\",\"char_count\":9591,\"short_content\":\"\\n\\n\\n\\n{% cq %}\\n\\n小心点，一不小心你就栽跟头了 :ghost:\\n\\n{% endcq%}\\n\\n\",\"abbrlink\":\"1e5xy16\"},{\"title\":\"关于JVM的运行时数据区\",\"categories\":[\"java\",\"jvm\",\"memory\"],\"comments\":true,\"date\":\"2018-06-02T22:48:00.000Z\",\"tags\":[\"jvm\",\"运行时数据区\"],\"series\":\"JVM\",\"char_count\":2997,\"short_content\":\"\\n\\n\\n\\n### 前言\\n\\n本书第二版为止，其实还是针对于Java SE 7 Specification（后简称Spec），然而到了Java8，情况又有很大的不同，比如最出名的Permanent Generation，就在8中被HotSpot虚拟机移除掉了，所以这一系列的文章，我后续还需要慢慢地研究和重写\\n\\n然后是一篇关于Java SE 7 Spec的[好文](http://blog.jamesdbloom.com/JVMInternals.html#threads)\\n\\n\",\"abbrlink\":\"rikltc\"},{\"title\":\"排序大礼包\",\"categories\":[\"algorithm\",\"sort\"],\"comments\":true,\"date\":\"2018-06-02T18:50:00.000Z\",\"tags\":[\"algorithm\",\"sort\"],\"char_count\":16074,\"short_content\":\"\\n\\n\\n\\n### 术语\\n\\n**稳定性：**算法排序前后，相同值的元素的相对位置是否不变，变了就不稳定\\n\\n**在位性：**算法排序是否要借助额外的内存空间，需要就不在位\\n\\n\",\"abbrlink\":\"1b0rp9e\"},{\"title\":\"这，就是Lambda！\",\"categories\":[\"java\",\"grammar\"],\"comments\":true,\"date\":\"2018-06-02T10:52:00.000Z\",\"tags\":[\"lambda\",\"java8\"],\"char_count\":8596,\"short_content\":\"\\n\\n### HelloWorld\\n\\n昨天的小米笔试题: **请用Lambda写一个将int数组[1,2,3]转换为String数组[\\\"1\\\",\\\"2\\\",\\\"3\\\"]**\\n\\n当时没写完整，就这个为例作为开始吧, 完整代码如下:\\n\\n``` java\\n  int[] si = {1, 2, 3};\\n```\\n\",\"abbrlink\":\"n0hez3\"},{\"title\":\"从头到尾读Iterable与Iterator\",\"categories\":[\"java\",\"collections-framework\"],\"comments\":true,\"date\":\"2018-05-15T17:22:14.000Z\",\"tags\":[\"iterable\",\"iterator\",\"collections-framework\"],\"series\":\"从头到尾读\",\"char_count\":2385,\"short_content\":\"\\n\\n\\n\\n### Iterable接口\\n\\n含义: 这个接口的含义是, 容器的元素是否支持**迭代器**访问\\n\\n#### 源码\\n\\n\",\"abbrlink\":\"1kakozs\"},{\"title\":\"从头到尾读Collection\",\"categories\":[\"java\",\"collections-framework\"],\"comments\":true,\"date\":\"2018-05-15T17:17:26.000Z\",\"tags\":[\"collection\",\"collections-framework\"],\"series\":\"从头到尾读\",\"char_count\":4653,\"short_content\":\"\\n\\n### Collection接口\\n\\n### 源代码解读\\n\\n#### 头部\\n\\n``` java\\npublic interface Collection<E> extends Iterable<E> {\\n```\\n\",\"abbrlink\":\"faxga5\"},{\"title\":\"初探Java8之方法引用\",\"categories\":[\"java\",\"grammar\"],\"comments\":true,\"date\":\"2018-05-15T10:40:00.000Z\",\"tags\":[\"java8\",\"方法引用\"],\"char_count\":3828,\"short_content\":\"\\n\\n{% cq %}\\n\\n本文从为知笔记迁移过来, 本文的写作时间是 : 2016/10/18 下午1:41:28, 两年前的文章, 言语难免幼稚, 思维难免浅显, 多多包含.\\n\\n{% endcq %}\\n\\n > 在学习这个东西的时候，找了很多资料，网上说的也都很笼统，找不到一个比较容易上手的例子，直到我看到一篇文章，作者在整体讲述Java5-8的新特性，其中讲完Java8的lambda表达式之后，马上就讲方法引用这个特性，我才更加清楚的意识到，方法引用其实是比lambda更加简洁的一个语法糖（不知道我这样理解对不对），但是，常识告诉我们，越简单的技术，限制条件就越多，为什么网上的关于方法引用的讲解都很散，因为方法引用的使用条件有点多。\\n\\n\",\"abbrlink\":\"1bhsyh3\"},{\"title\":\"初探Java8之lambda\",\"categories\":[\"java\",\"grammar\"],\"comments\":true,\"date\":\"2018-05-15T10:05:00.000Z\",\"tags\":[\"java8\",\"lambda\"],\"char_count\":6126,\"short_content\":\"\\n\\n{% cq %}\\n\\n本文从为知笔记迁移过来, 本文的写作时间是 : 2016/10/17 下午12:28:14, 两年前的文章, 言语难免幼稚, 思维难免浅显, 多多包含.\\n\\n{% endcq %}\\n\\n### 引例\\n\\n\",\"abbrlink\":\"nr7s9o\"},{\"title\":\"对持续集成(CI)的一些理解\",\"tags\":[\"CI\"],\"categories\":[\"thinking\"],\"date\":\"2018-05-08T15:53:01.000Z\",\"char_count\":1430,\"short_content\":\"\\n\\n### 什么是CI\\n\\n**持续集成（Continuous integration）** 不是什么新概念\\n\\n> _持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。_\\n\\n以上引自百度百科的定义。\\n\\n\",\"abbrlink\":\"14k0uek\"},{\"title\":\"JettyDocument_ZH_CN_Translation_README\",\"tags\":[\"jetty\",\"document\",\"readme\"],\"categories\":[\"translation\"],\"series\":\"JettyDocument_ZH_CN_Translation\",\"date\":\"2018-05-07T17:30:01.000Z\",\"char_count\":2895,\"short_content\":\"\\n\\n# Jetty : Servlet Engine and HTTP server\\n创立时间：2017年8月25日16:13:49\\n\\n官方文档地址：http://www.eclipse.org/jetty/documentation/9.4.6.v20170531/\\n- - -\\nMaven依赖：\\n```\\n<properties>\\n```\\n\",\"abbrlink\":\"n8gsoq\"},{\"title\":\"JettyDocument_ZH_CN_Translation_Part4-23\",\"tags\":[\"jetty\",\"document\"],\"categories\":[\"translation\"],\"series\":\"JettyDocument_ZH_CN_Translation\",\"date\":\"2018-05-07T17:30:01.000Z\",\"char_count\":16093,\"short_content\":\"\\n\\n<span id=\\\"top\\\"></span>\\n### Ⅳ. Jetty开发指南-23.Jetty和Maven\\n- 23. [Jetty和Maven](#23jetty和maven)\\n  - [使用Maven](#231使用maven)\\n    - [使用Maven做嵌入式Jetty开发](#2311使用maven做嵌入式jetty开发)\\n    - [使用Maven开发标准的WebApp](#2321使用maven开发标准的wabapp)\\n  - [配置Jetty的Maven插件](#232配置jetty的maven插件)\\n    - [快速开始](#2321快速开始)\\n\",\"abbrlink\":\"1cei7aq\"},{\"title\":\"JettyDocument_ZH_CN_Translation_Part4-21\",\"tags\":[\"jetty\",\"document\"],\"categories\":[\"translation\"],\"series\":\"JettyDocument_ZH_CN_Translation\",\"date\":\"2018-05-07T17:30:01.000Z\",\"char_count\":35483,\"short_content\":\"\\n\\n<span id=\\\"top\\\"></span>\\n### Ⅳ. Jetty开发指南-21.嵌入式开发\\n  - 21. [嵌入式开发](#21嵌入式开发)\\n    - [Jetty的嵌入式Hello World](#211jetty的嵌入式hello-world)\\n      - [下载Jar包](#2111下载jar包)\\n      - [Hello World栗子](#2112hello-world栗子)\\n      - [编译Hello World栗子](#2113编译hello-world栗子)\\n      - [运行Handler和Server](#2114运行handler和server)\\n\",\"abbrlink\":\"18rke1\"},{\"title\":\"JettyDocument_ZH_CN_Translation_Part3-13\",\"tags\":[\"jetty\",\"document\"],\"categories\":[\"translation\"],\"series\":\"JettyDocument_ZH_CN_Translation\",\"date\":\"2018-05-07T17:30:01.000Z\",\"char_count\":14125,\"short_content\":\"\\n\\n<span id=\\\"top\\\"></span>\\n### Ⅲ. Jetty管理者指南-13.注释\\n  - 13. [注解](#13注解)\\n    - [快速设置](#131快速设置)\\n      - [关于Jetty发行版](#1311关于jetty发行版)\\n      - [关于Jetty Maven Plugin](#1312关于jetty-maven-plugin)\\n      - [关于嵌入式](#1313关于嵌入式)\\n    - [使用注解](#132使用注解)\\n\",\"abbrlink\":\"cc3kmk\"},{\"title\":\"JettyDocument_ZH_CN_Translation_Part1\",\"tags\":[\"jetty\",\"document\"],\"categories\":[\"translation\"],\"series\":\"JettyDocument_ZH_CN_Translation\",\"date\":\"2018-05-07T17:30:01.000Z\",\"char_count\":24839,\"short_content\":\"\\n\\n### Ⅰ.开始使用Jetty\\n<span id=\\\"top\\\"></span>\\n  - 1. [关于Jetty的介绍](#1关于jetty的介绍)\\n    - [什么是Jetty](#11什么是jetty)\\n    - [我应该使用哪个版本](#12我应该使用哪个版本)\\n    - [Jetty和JavaEE的Web规范](#13jetty和javaee的web规范)\\n    - [在Maven里面找到Jetty](#14在maven里面找到jetty)\\n  - 2. [使用Jetty](#2使用jetty)\\n\",\"abbrlink\":\"17hjlts\"},{\"title\":\"Cron4jDocument_ZH_CN_Translation\",\"categories\":[\"translation\"],\"tags\":[\"cron4j\",\"scheduler\"],\"series\":\"Cron4jDocument_ZH_CN_Translation\",\"date\":\"2018-05-07T17:25:01.000Z\",\"char_count\":19297,\"short_content\":\"\\n\\n# Cron4j\\n \\n一些必要的单词解释：\\n1. schedule 安排、调度（安排在有主语的时候使用 调用在没主语的时候使用）\\n2. scheduler 调度器\\n3. scheduling pattern 调度模式\\n4. reschedule 重新调度、安排\\n5. action/task 动作/任务\\n\",\"abbrlink\":\"1ngl1pm\"},{\"title\":\"Cron4jDocument_ZH_CN_Translation_README\",\"categories\":[\"translation\"],\"tags\":[\"cron4j\",\"scheduler\",\"readme\"],\"series\":\"Cron4jDocument_ZH_CN_Translation\",\"date\":\"2018-05-07T17:12:01.000Z\",\"char_count\":2323,\"short_content\":\"\\n\\n# Cron4j : A pure Java cron-like scheduler\\n创立时间：2017年8月20日13:35:01\\n\\n官方文档地址：http://www.sauronsoftware.it/projects/cron4j/\\n- - -\\nMaven依赖：\\n```\\n<dependency>\\n```\\n\",\"abbrlink\":\"19jo7o1\"},{\"title\":\"Linux安装MySql\",\"categories\":[\"reprinted\"],\"tags\":[\"mysql\",\"linux\"],\"date\":\"2018-05-03T16:05:01.000Z\",\"char_count\":3195,\"short_content\":\"\\n\\n\\n\\n# Linux安装MySql\\n一位哲人说过，只会用 FTP 工具的人都是傻子。\\n## 原料\\n去 [Mysql官网](https://www.mysql.com/downloads/) 下载\\nmysql-5.7.19-linux-glibc2.12x86_64.tar.gz。\\n## 步骤\\n\",\"abbrlink\":\"spovqu\"},{\"title\":\"蓝桥杯Java一夜暴富\",\"categories\":[\"note\"],\"comments\":false,\"tags\":[\"蓝桥杯\"],\"date\":\"2018-03-30T16:59:43.000Z\",\"char_count\":12713,\"short_content\":\"\\n\\n#### 目录\\n- eclipse快捷键\\n- 数组的使用\\n - 初始化\\n - for-each遍历\\n - 使用底层API快速复制\\n - 搭配Arrays类进行二分查找和排序\\n- String类\\n\",\"abbrlink\":\"mtg94p\"},{\"title\":\"CentOS7下安装Pillow并使用osm-bundler生成图点模型\",\"categories\":[\"note\",\"project\"],\"comments\":true,\"tags\":[\"centos7\",\"python\",\"Pillow\",\"osm-bundler\",\"pip\"],\"date\":\"2018-01-21T11:50:30.000Z\",\"char_count\":5474,\"short_content\":\"\\n\\n{% cq %}\\n前言：之前留下的17大创项目总得做点什么，马上就要结题了，我们做的AR留影需要将用户照下来的照片生成点云然后合成模型。由此Escnqh[link:gayhub]找到了使用PIL+osm-bundler的解决方案。\\n{% endcq %}\\n\\n<!-- more -->\\n\\n### Python Photogrammetry ToolKit（PPT）\\n\\n\",\"abbrlink\":\"1ox3j6i\"},{\"title\":\"Log4j2_Lookups\",\"categories\":[\"java\",\"lib\",\"log4j\"],\"comments\":true,\"tags\":[\"log4j2\",\"learning\"],\"date\":\"2017-12-09T15:28:15.000Z\",\"series\":\"Log4j2\",\"char_count\":1520,\"short_content\":\"\\n\\n{% cq %}\\n\\nLookups：让你的配置更灵活\\n\\n{% endcq %}\\n\\n<!-- more -->\\n\\n\",\"abbrlink\":\"3zxt7z\"},{\"title\":\"Log4j2_Filters\",\"categories\":[\"java\",\"lib\",\"log4j\"],\"comments\":true,\"tags\":[\"log4j2\",\"learning\"],\"date\":\"2017-12-09T12:41:20.000Z\",\"series\":\"Log4j2\",\"char_count\":2384,\"short_content\":\"\\n\\n{% cq %}\\n\\nFilters：过滤你的日志信息\\n\\n{% endcq %}\\n\\n<!-- more -->\\n\\n\",\"abbrlink\":\"3fjm8j\"},{\"title\":\"Log4j2_Layouts\",\"categories\":[\"java\",\"lib\",\"log4j\"],\"comments\":true,\"tags\":[\"log4j2\"],\"date\":\"2017-12-08T14:39:16.000Z\",\"series\":\"Log4j2\",\"char_count\":1166,\"short_content\":\"\\n\\n{% cq %}\\n\\nLayout：定制你的输出模式\\n\\n{% endcq %}\\n\\n<!-- more -->\\n\\n\",\"abbrlink\":\"yvgzwi\"},{\"title\":\"我认为的规范的git commit msg\",\"top\":true,\"categories\":[\"thinking\"],\"comments\":true,\"tags\":[\"tips\",\"github\",\"git\"],\"date\":\"2017-11-29T18:30:01.000Z\",\"char_count\":2664,\"short_content\":\"\\n\\n{% cq %}\\n\\n其实必要的时候使用`git commit -m \\\"xxxxx\\\"`也木有关系 但你也别每条都这样写\\n\\n{% endcq %}\\n\\n<!-- more -->\\n\\n\",\"abbrlink\":\"a9wle2\"},{\"title\":\"Electron_打包你的HelloWorld为exe\",\"categories\":[\"front-end\",\"electron\"],\"comments\":true,\"tags\":[\"electron\",\"helloworld\"],\"series\":\"electron\",\"date\":\"2017-11-23T13:02:21.000Z\",\"char_count\":5447,\"short_content\":\"\\n\\n\\n\\n{% cq %}\\n\\nEXE什么的，看着就忍不住要双击它！\\n\\n{% endcq %}\\n\\n\",\"abbrlink\":\"1q1lo3l\"},{\"title\":\"Electron_一个HelloWorld\",\"categories\":[\"front-end\",\"electron\"],\"comments\":true,\"tags\":[\"electron\",\"helloworld\"],\"series\":\"electron\",\"date\":\"2017-11-22T22:05:23.000Z\",\"char_count\":4726,\"short_content\":\"\\n\\n\\n\\n{% cq %}\\n\\n惊！仅用前端技术就可以打造跨平台桌面应用！\\n\\n{% endcq %}\\n\\n\",\"abbrlink\":\"a08lib\"},{\"title\":\"Log4j2_Appenders\",\"comments\":true,\"tags\":[\"log4j\"],\"categories\":[\"java\",\"lib\",\"log4j\"],\"date\":\"2017-11-17T16:37:18.000Z\",\"series\":\"Log4j2\",\"char_count\":6004,\"short_content\":\"\\n\\n{% cq %}\\n\\n上篇介绍了使用Log4j2之前的准备工作和简单介绍了一个HelloWorld\\n\\n现在我们来了解配置中的第一个关键配置：Appenders\\n\\n{% endcq %}\\n\\n\",\"abbrlink\":\"nff3ic\"},{\"title\":\"Log4j2_HelloWorld\",\"tags\":[\"log4j2\"],\"categories\":[\"java\",\"lib\",\"log4j\"],\"comments\":true,\"date\":\"2017-11-17T16:13:21.000Z\",\"series\":\"Log4j2\",\"char_count\":3621,\"short_content\":\"\\n\\n{% cq %}\\n\\nLo4j2是啥就不解释了，之前无论是使用log4j还是log4j2，同样只是简单的各种百度然后复制粘贴没有系统的总结一下，今天把一个小小的Ajax的测试程序放服务器上面都不知道怎么查错，然后想写一下log来看看哪错了吧，发现还是不会独立配置log4j，于是想总结一波。基本的思路是总结官方文档和官方推荐的中文文档，尽量简洁表达出原理以及应用。\\n\\n{% endcq %}\\n\\n<!-- more -->\\n\\n\",\"abbrlink\":\"en4hhw\"},{\"title\":\"RegExp_2_metacharacters\",\"categories\":[\"booknotes\",\"Mastering Regular Expression\"],\"comments\":true,\"tags\":[\"regular-expression\"],\"date\":\"2017-11-17T00:02:06.000Z\",\"series\":\"《Mastering Regular Expression(Third Edition)》\",\"char_count\":2336,\"short_content\":\"\\n\\n{% cq %}\\n\\nMetacharacters：元字符\\n\\n{% endcq %}\\n\\n<!-- more -->\\n\\n\",\"abbrlink\":\"huiysg\"},{\"title\":\"RegExp_1_overview\",\"tags\":[\"regular-expression\"],\"categories\":[\"booknotes\",\"Mastering Regular Expression\"],\"comments\":true,\"date\":\"2017-11-17T00:00:56.000Z\",\"series\":\"《Mastering Regular Expression(Third Edition)》\",\"char_count\":1284,\"short_content\":\"\\n\\n*自接触计算机编程以来，无数次碰到过这个名词“正则表达式”，刚开始肯定是不懂，但是听到“表达式”三个字就发现事情并不简单。*\\n\\n<!-- more -->\\n\\n第一次接触到它还是在我进NTJ2EE的招新机试的时候，机试题有一道题：“有一个字符串，其中包含中文字符、英文字符和数字字符，请统计和打印出各个字符的个数。”，当时只会用取字符对照ascii的方法来做这道题，然后正好学长看了我的做法，他说还有种东西叫做“正则表达式”，然后他给我打开了在线的JDK-1.6的API，找到了里面介绍正则表达式的页，然后还百度了一篇正则表达式的教程给我看（对，就是那个通篇斜杠写反的那盘），然后我就头皮发麻了。\\n\\n在之后无论是正式学习还是运用到实际当中，我的处理都是：百度——ctrl+c——ctrl+v，然后下次碰到另一个字符串处理问题的时候还是这样做，毫无意义，甚至还不能完全匹配我的应用场景。然后这次的工程中心项目，我负责写前端，对输入框需要用到字符串过滤的需求，就这么简单的一个功能我都实现不了，感觉非常丢人，我不想再复制粘贴了，所以开始以blog的形式记录我学习`regular-expression`的过程。\\n\\n\",\"abbrlink\":\"1k4djcz\"},{\"title\":\"5 Useful Tips For A Better Commit Message\",\"categories\":[\"reprinted\"],\"comments\":true,\"tags\":[\"tips\",\"github\",\"git\"],\"date\":\"2017-11-15T16:59:00.000Z\",\"char_count\":3660,\"short_content\":\"\\n\\nYou’re already writing decent commit messages. Let’s see if we can level you up to awesome. Other developers, especially you-in-two-weeks and you-from-next-year, will thank you for your forethought and verbosity when they run git blame to see why that conditional is there.\\n\\n<!-- more -->\\n\\n1. The first line should always be <u>50 characters</u> or less and that it should be followed by a blank line. Vim ships with syntax, indent, and filetype plugins for Git commits which can help here.\\n\\n1. Add this line to your `~/.vimrc` to add spell checking and automatic wrapping at the recommended 72 columns to you commit messages.\\n\\n\",\"abbrlink\":\"1h187i6\"}]");
    sessionStorage.setItem('postOrder', "[\"Connecting ModelSIM with Vscode & XQuartz on Mac<=>xqh6xg\",\"了解前缀树<=>ooqfkn\",\"带状态机的DP<=>f40uwq\",\"再聊InnoDB索引<=>1lvzuh7\",\"MySQL InnoDB锁概述<=>dc5shg\",\"MySQL InnoDB事务概述<=>tx6g0p\",\"MySQL InnoDB索引概述<=>a0p0f4\",\"优先队列&二叉堆（2-heap）<=>2t44ld\",\"MySQL InnoDB引擎概述<=>xfjqry\",\"Python - Threading<=>2acnhf\",\"The Basic Grammar Of Python (EF)<=>1xentt\",\"The Basic Grammar Of Python (CD)<=>1ba9tuk\",\"The Basic Grammar Of Python (AB)<=>t3owl3\",\"Make Your Raspberry Pi Broadcasting TV News Every Morning<=>1xemds8\",\"Interesting Math - Prime Number<=>1jy4sem\",\"微信小程序支付后台接入<=>1csh4qm\",\"一次博客的改版和升级<=>3rmqph\",\"字符编码笔记<=>1w60zyo\",\"Electron_UI<=>kimeni\",\"Electron_配置相关与对象<=>1y7ozg8\",\"Electron_上手铺垫<=>11zuc81\",\"Express Middleware<=>1tzsbbu\",\"Express Routing<=>1n8vn13\",\"Understanding the nodejs' event loop<=>1w97yet\",\"GC Algorithm Implementation<=>1jvfs4t\",\"Leetcode-71~75<=>i9becb\",\"Leetcode-66~70<=>z9pvg9\",\"Leetcode-61~65<=>1cu6q2d\",\"Leetcode-56~60<=>1kv61wq\",\"Leetcode-51~55<=>xmbex2\",\"Leetcode-46~50<=>jywoys\",\"Some Backtracking Problem In Leetcode<=>1x7azit\",\"DP Again<=>1flo1c0\",\"Leetcode-41~45<=>11z93zc\",\"Leetcode-36~40<=>v6ei19\",\"再谈对象分代和GC事件<=>wlvrl9\",\"字节跳动2019-03-16后端笔试<=>djlqql\",\"Leetcode-31~35<=>dbne5d\",\"Leetcode-26~30<=>448jer\",\"Leetcode-21~25<=>1hrw4sv\",\"Leetcode-16~20<=>3yl2hx\",\"Help GC A Favor & JIT Introduction<=>12iaggv\",\"Java's Refernece<=>13tt0au\",\"The Revelation of Java String<=>46bhg0\",\"Leetcode-11~15<=>2gps3g\",\"最近点对及其相关问题<=>1d9upzt\",\"Leetcode-6~10<=>t1f0vq\",\"Hashing<=>1f3qusx\",\"Leetcode-1~5<=>pn2ezr\",\"Tree Binary Tree<=>1aew5v7\",\"Tree Introduction<=>1qvt6fv\",\"Java并发编程第八坎<=>1u7rv30\",\"CLH Lock Queue<=>vywf17\",\"Java并发编程第七坎-2<=>u4sgci\",\"Java并发编程第七坎<=>7kdfk8\",\"Docker Volumes<=>1ae6lng\",\"Docker Persist Data Overview<=>lt42s8\",\"Docker ConceptReview<=>rx7jt4\",\"Docker Stack<=>u7sd0w\",\"Docker Swarm&ClusterSetup<=>1toixsk\",\"Docker Service&Composefile<=>zkr55u\",\"Jenkins Introductions&Setup<=>1arzjog\",\"写在21岁的最后一天<=>1xetsy3\",\"关于JVM的GC行为和内存分配<=>jhpq7e\",\"Docker Containers&Dockerfile<=>uh480l\",\"Tess login on Jenkins<=>1gukab6\",\"Introductions of eBay Tess<=>2032k5\",\"关于JVM的运行时数据区上的GC<=>d5ykz8\",\"关于JVM的对象创建与访问<=>18669ga\",\"Docker Orientation&Setup<=>1ei198o\",\"kafka-topic-storage-detail<=>1ro5m3y\",\"kafka-helloworld-concept<=>u28b7l\",\"微服务架构理论基础-康威定律<=>pjff39\",\"微服务（Microservice）那点事<=>1kb6gry\",\"Graduation Design<=>q0aas8\",\"地痞（DP）成长记<=>188zp6j\",\"AVL树和红黑树<=>wji6g0\",\"查找大礼包<=>bg6w8m\",\"把HashMap安排得明明白白<=>ofa68o\",\"算法回收站<=>8lcrnu\",\"记一次设计模式之旅<=>9h3hmp\",\"Java并发编程第六坎<=>139027a\",\"Java并发编程第五坎<=>1xo3tpx\",\"Java并发编程第四坎<=>db3vx3\",\"Java并发编程第三坎<=>1h1ww1y\",\"Java并发编程第二坎<=>1clnpuk\",\"计算机网络-谢希仁-2<=>1nz333d\",\"计算机网络-谢希仁-1<=>1k7g0p3\",\"Java并发编程第一坎<=>bu9klx\",\"从头到尾读ArrayList<=>rku8jh\",\"自实现ArrayList<=>1gfw5vx\",\"Java运算符知多少<=>1e5xy16\",\"关于JVM的运行时数据区<=>rikltc\",\"排序大礼包<=>1b0rp9e\",\"这，就是Lambda！<=>n0hez3\",\"从头到尾读Iterable与Iterator<=>1kakozs\",\"从头到尾读Collection<=>faxga5\",\"初探Java8之方法引用<=>1bhsyh3\",\"初探Java8之lambda<=>nr7s9o\",\"对持续集成(CI)的一些理解<=>14k0uek\",\"JettyDocument_ZH_CN_Translation_README<=>n8gsoq\",\"JettyDocument_ZH_CN_Translation_Part4-23<=>1cei7aq\",\"JettyDocument_ZH_CN_Translation_Part4-21<=>18rke1\",\"JettyDocument_ZH_CN_Translation_Part3-13<=>cc3kmk\",\"JettyDocument_ZH_CN_Translation_Part1<=>17hjlts\",\"Cron4jDocument_ZH_CN_Translation<=>1ngl1pm\",\"Cron4jDocument_ZH_CN_Translation_README<=>19jo7o1\",\"Linux安装MySql<=>spovqu\",\"蓝桥杯Java一夜暴富<=>mtg94p\",\"CentOS7下安装Pillow并使用osm-bundler生成图点模型<=>1ox3j6i\",\"Log4j2_Lookups<=>3zxt7z\",\"Log4j2_Filters<=>3fjm8j\",\"Log4j2_Layouts<=>yvgzwi\",\"我认为的规范的git commit msg<=>a9wle2\",\"Electron_打包你的HelloWorld为exe<=>1q1lo3l\",\"Electron_一个HelloWorld<=>a08lib\",\"Log4j2_Appenders<=>nff3ic\",\"Log4j2_HelloWorld<=>en4hhw\",\"RegExp_2_metacharacters<=>huiysg\",\"RegExp_1_overview<=>1k4djcz\",\"5 Useful Tips For A Better Commit Message<=>1h187i6\"]");
    sessionStorage.setItem('scriptsMds', "{\"Academic Website\":\"cb48f8a4\",\"CSS\":\"365a1777\",\"Docker\":\"8c6a1638\",\"ECE\":\"f5916bab\",\"Electron\":\"79da6013\",\"English Termiologies\":\"befb463a\",\"FE Engineering Related\":\"fbc08f90\",\"HTML\":\"a4690ebd\",\"JS&Node.js库\":\"9b96de31\",\"JS\":\"a586ccf8\",\"Java\":\"e3e877fe\",\"LaTeX\":\"56fa014a\",\"Linux\":\"26535a\",\"MAC\":\"4669e57a\",\"MySQL\":\"58be3d4b\",\"Open API\":\"76024c57\",\"Python\":\"b3001d81\",\"Software Engineering\":\"b09cec40\",\"Vue\":\"fe80f986\",\"坑\":\"737e95b3\",\"技巧\":\"79453be7\",\"操作系统原理\":\"c72c09e6\",\"概念与思考\":\"edefab81\",\"算法\":\"984d050c\",\"网站&博客\":\"7d0d4b58\",\"网络\":\"8f8dd110\",\"软件\":\"e173fd3a\"}");
