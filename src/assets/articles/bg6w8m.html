
          <h4 id="c2993dc7">小声BB</h4><p>整理一波查找相关的东西</p>
<ul>
<li>几个元素查找算法如：<ul>
<li>顺序查找</li>
<li>二分查找</li>
<li>分块查找</li>
<li>哈希查找</li>
</ul>
</li>
<li>字符串匹配：<ul>
<li>蛮力法</li>
<li>KMP</li>
</ul>
</li>
</ul>
<hr>

          <h4 id="9e3dd7b7">术语</h4>
          <h5 id="9ee9ce16">ASL（Average Search Length）</h5><p>平均查找长度：为确定记录在查找表中的位置，需和给定值进行比较的关键字的个数的期望值；</p>
<p>公式：</p>
<p>$$
ASL = _{i=1}^{n \atop \sum} P_iC_i
$$
其中<em><strong>Pi</strong></em>为查找表中第<em><strong>i</strong></em>个记录的概率；<em><strong>Ci</strong></em>为找到表中关键字和给定值的第<em><strong>i</strong></em>个记录时，和给定值已进行比较的<strong>关键字个数</strong></p>
<p>假设有顺序查找，长度为n，假设每个记录查找的概率相等（无重复），即</p>
<p>$$
P_i = 1 / n
$$
则：</p>
<p>$$
\begin{aligned}ASL &amp;= (1 * 1 / n ) + (2 * 1 / n) + \dots + (n * 1 / n) \\ &amp;= [1 / n * ( n * \dfrac{n + 1}{2})] = \dfrac{n + 1}{2} \end{aligned}
$$
但是以上仅是查找成功的概率，如果查找成功和查找成功则这个概率是</p>
<p>$$
\dfrac{3}{4} (n + 1)
$$</p>
<hr>

          <h4 id="5444c982">元素查找算法</h4>
          <h5 id="ee0d6202">顺序查找（Sequential Search）</h5><pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">orderSearch</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> target)</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)
        <span class="hljs-keyword">if</span> (arr[i] == target)
            <span class="hljs-keyword">return</span> i;
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre>
<p>不解释，时间复杂度：<strong>O(n)，ASL(ss) =（n + 1）/ 2</strong></p>

          <h5 id="df10e587">二分查找/折半查找（Binary Search）</h5><blockquote>
<p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表，且插入删除困难。</p>
<p>因此，折半查找方法适用于不经常变动而查找频繁的有序列表。</p>
<p>两个条件：1）序列有序；2）可以随机访问</p>
</blockquote>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dynamicBinarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> target)</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> start, high = end, mid;
    <span class="hljs-keyword">while</span> (low &lt;= high) {
        mid = (low + high) &gt;&gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (arr[mid] &lt; target) {
            low = mid + <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; target) {
            high = mid - <span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> mid;
        }
    }
    <span class="hljs-keyword">return</span> -low;
}
</code></pre>
<p>以上为动态二分查找，也就是如果找不到结果，就返回元素要插入位置的负数；一般的查找，找不到元素就返回-1；</p>
<p>时间复杂度为<strong>O(logn)</strong></p>

          <h6 id="267d7aea">二分的ASL计算</h6><blockquote>
<p>来源：<a href="https://www.nowcoder.com/profile/1105774/myFollowings/detail/6105243">https://www.nowcoder.com/profile/1105774/myFollowings/detail/6105243</a></p>
</blockquote>
<blockquote>
<p>题目：</p>
<p>具有12个关键字的有序表,折半查找的平均查找长度为（）</p>
<p>A 3.1    B 4        C 2.5    D 5</p>
</blockquote>
<blockquote>
<p>解答：</p>
<p>将12个数画成完全二叉树，第一层有1个、第二次2个、第三层4个，第四层只有5个。</p>
<p>二分查找时：</p>
<p>第一层需要比较1次</p>
<p>第二两个数，每个比较2次</p>
<p>第三层四个数，每个比较3次</p>
<p>第四层五个数，每个比较4次</p>
<p>则平均查找长度即为：（1 + <strong>2 * 2</strong> + <strong>3 * 4</strong> + <strong>4 * 5</strong>）/ 12 = 37/12 = 3.0833 即为 A、3.1</p>
</blockquote>

          <h5 id="27c47f33">分块查找/索引查找（Block Search/Index Search）</h5><blockquote>

          <h4 id="a04ef540">简介</h4><p>分块查找是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是有序的，对块内节点没有排序要求（块内无序，块间有序），因此特别适合于节点<strong>动态变化</strong>的情况。</p>
<p>折半查找虽然具有很好的性能，但其前提条件时线性表顺序存储而且按照关键码排序，这一前提条件在结点树很大且表元素动态变化时是难以满足的。而顺序查找可以解决表元素动态变化的要求，但查找效率很低。如果既要保持对线性表的查找具有较快的速度，又要能够满足表元素动态变化的要求，则可采用分块查找的方法。</p>
<p>当增加或减少节以及节点的关键码改变时，只需将该节点调整到所在的块即可。在空间复杂性上，分块查找的主要代价是增加了一个辅助数组。</p>

          <h4 id="2ec1a283">方法描述</h4><p>分块查找要求把一个大的线性表分解成若干块，每块中的节点可以任意存放，但块与块之间必须排序。假设是按关键码值非递减的，那么这种块与块之间必须满足已排序要求，实际上就是对于任意的i，第i块中的所有节点的关键码值都必须小于第i+1块中的所有节点的关键码值。还要建立一个索引表（索引表中为每一块都设置索引项，每一个索引项都包含两个内容）</p>
<ul>
<li>该块的起始地址</li>
<li>该块中最大的元素</li>
</ul>

          <h4 id="4626bbc2">性能分析</h4><p>这种带索引表的分块有序表查找的时间性能取决于两步查找时间之和：如前面所述，第一步可以采用简单顺序查找和折半查找之一进行。第二步只能采用简单顺序查找，但由于子表的长度较原表的长度小。因此，其时间性能介于顺序查找和折半查找之间。</p>
<p>假设索引表有n个元素，每块含有s个元素，</p>
<ul>
<li><p>平均查找长度为：<strong>ASL=(n/s+s)/2 +1</strong></p>
</li>
<li><p>时间复杂度为：<strong>O(n)~O(log2n)</strong></p>
</li>
</ul>
</blockquote>
<hr>

          <h4 id="618baf9c">字符串匹配</h4><p>问题：给定一个n长度的字符串（text），一个m（m&lt;=n）长度的串（pattern），从text中找匹配pattern的字串</p>

          <h5 id="16544070">蛮力法</h5><blockquote>
<p>实现1，参考于：<em>《算法设计与分析基础》（第三版）P-81</em></p>
</blockquote>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bruteForceStringMatch</span><span class="hljs-params">(String text, String pattern)</span>{
    <span class="hljs-type">char</span>[] t = text.toCharArray();
    <span class="hljs-type">char</span>[] p = pattern.toCharArray();
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> t.length;
    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> p.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n - m; i++){
        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(j &lt; m &amp;&amp; p[j] == t[i + j]){
            j++;
            <span class="hljs-keyword">if</span> (j == m) <span class="hljs-keyword">return</span> i;
        }
    }
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre>
<p>时间复杂度：最坏<strong>O(nm)<strong>，平均</strong>O(n)</strong></p>
<p>上法之所以叫蛮力法，因为它真的是在两串之间逐个字符地去比较，花费了很多不必要的工作，比如：</p>
<p>有text：“abcabe”</p>
<p>有patt：“abe”</p>
<p>当<strong>i = 0，j = 2</strong>的时候，也就是c和e比较的时候就发现不等了，蛮力法的做法是讲<strong>i往后移1位，j置0，从第一个b开始和patt的a开始比较！</strong>但是我们前面已经知道了patt的第一个字符就是<strong>a</strong>，和<strong>text[1]b</strong>比较必然无果</p>
<p>这时候就会做一些徒劳工，<strong>你要把主串中前面比较过的元素再和匹配串从头到尾进行一次比较</strong></p>
<p>因此就需要找到一个方法，记录好每次的已知条件，不再做徒劳的事情，于是就有了KMP算法</p>

          <h5 id="f91b87c4">KMP</h5><p>关于KMP的原理不再多说了，因为时间关系，以后如果有时间，会自己再写清楚的</p>
<blockquote>
<p>原理参考：</p>
<ul>
<li></li>
<li><p><a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/">http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/yjiyjige/p/3263858.html">https://www.cnblogs.com/yjiyjige/p/3263858.html</a></p>
</li>
<li><p><a href="https://subetter.com/algorithm/kmp-algorithm.html">刘毅</a></p>
</li>
</ul>
</blockquote>

          <h6 id="32d32983">next</h6><p>下面主要讨论<em>next函数</em>的代码和手算过程：</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] next(<span class="hljs-type">char</span>[] p) {
    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[p.length];
    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (j &lt; p.length - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (k == -<span class="hljs-number">1</span> || p[j] == p[k]) {
            j++;
            k++;
            next[j] = k;
        } <span class="hljs-keyword">else</span> {
            k = next[k];
        }
    }
    <span class="hljs-keyword">return</span> next;
}
</code></pre>
<p>根据这个，求出next数组，数组中每个值代表<strong>部分匹配</strong>，一下摘自<a href="https://subetter.com/articles/2018/04/how-to-understand-kmp.html">刘毅</a>中的手算过程，稍作修改：</p>
<blockquote>
<p>手算<strong>“ABCDABD”</strong></p>
<ol>
<li>i = 0，对于模式串的首字符，我们统一为<code>next[0] = -1</code>；</li>
<li>i = 1，<code>p[1] = B</code>前面的字符串为<code>A</code>，其最长相同真前后缀长度为 0，即<code>next[1] = 0</code>；</li>
<li>i = 2，<code>p[2] = C</code>前面的字符串为<code>AB</code>，其最长相同真前后缀长度为 0，即<code>next[2] = 0</code>；</li>
<li>i = 3，<code>p[3] = D</code>前面的字符串为<code>ABC</code>，其最长相同真前后缀长度为 0，即<code>next[3] = 0</code>；</li>
<li>i = 4，<code>p[4] = A</code>前面的字符串为<code>ABCD</code>，其最长相同真前后缀长度为 0，即<code>next[4] = 0</code>；</li>
<li>i = 5，<code>p[5] = B</code>前面的字符串为<code>ABCDA</code>，其最长相同真前后缀为<code>A</code>，即<code>next[5] = 1</code>；</li>
<li>i = 6，<code>p[6] = D</code>前面的字符串为<code>ABCDAB</code>，其最长相同真前后缀为<code>AB</code>，即<code>next[6] = 2</code>；</li>
</ol>
</blockquote>

          <h6 id="6de91b02">kmp</h6><p>这是稍微简洁一点的实现</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kmp</span><span class="hljs-params">(<span class="hljs-type">char</span>[] t, <span class="hljs-type">char</span>[] p)</span> {
    <span class="hljs-type">int</span>[] next = next(p);
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (i &lt; t.length &amp;&amp; j &lt; p.length) {
        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || t[i] == p[j]) {
            <span class="hljs-comment">// 有匹配就++</span>
            i++;
            j++;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 否则就按照next去移位j</span>
            j = next[j];
        }
    }
    <span class="hljs-keyword">if</span> (j == p.length) {
        <span class="hljs-keyword">return</span> i - j;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}
</code></pre>
<p>考虑得多一点的话，我们可以少匹配几次，比如我们考虑：</p>
<ul>
<li><p>如果text和pattern长度相等，如果text[0] != pattern[0]，那么就可以直接判断无匹配；</p>
</li>
<li><p>如果text长度小于pattern，直接-1；</p>
</li>
<li><p>在比对过程中，根据next[j]移位之时，如果移位后pattern接着要比对的串长，长过text剩下要比对的串长，直接-1，这是什么意思呢？</p>
<p>比如有text：abcdab<strong>c</strong>da</p>
<p>pattern：abcdab<strong>d</strong></p>
<p>i到c时，j到d时做比对，发现不等，但是主串这时的c前面有两个ab和pattern的前abc是相等的，移位后只需要<strong>j从pattern[3] = d开始比剩余的就好了，但是这时候text剩余要比较的只有da，但是pattern还有dabd要比较，所以这个长度之下就没必要再比较了，针对这个情况做优化</strong></p>
</li>
</ul>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kmp</span><span class="hljs-params">(<span class="hljs-type">char</span>[] t, <span class="hljs-type">char</span>[] p)</span> {
    <span class="hljs-keyword">if</span> (t.length &lt; p.length) {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t.length == p.length &amp;&amp; t[<span class="hljs-number">0</span>] != p[<span class="hljs-number">0</span>]) {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    <span class="hljs-type">int</span>[] next = next(pattern);
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (i &lt; t.length &amp;&amp; j &lt; p.length) {
        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || t[i] == p[j]) {
            i++;
            j++;
        } <span class="hljs-keyword">else</span> {
            j = next[j];
            <span class="hljs-keyword">if</span> (t.length - i &lt;= p.length &amp;&amp; j != -<span class="hljs-number">1</span> &amp;&amp; p.length - next[j] &lt;= t.length - i - <span class="hljs-number">1</span>) {
                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
            }
        }
    }
    <span class="hljs-keyword">if</span> (j == p.length) {
        <span class="hljs-keyword">return</span> i - j;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}
</code></pre>
<p>这里主要是<code>line：18-20</code>：在保证剩余串长还可以有效比对的情况下，还要保证移位后也能在长度内有效比对</p>

          <h6 id="336f875a">nextVal</h6><p>nextVal数组是对next数组的变体，意在快速找到<strong>相同的真前后缀</strong>，便于定位匹配串，</p>
<p>nextVal有两种算法，一种是根据算好的next去算，另一种是直接根据定义去另外算nextVal；</p>
<p>第一种，适合笔试的时候手算，因为笔试的时候观察法手算next贼简单，然后算nextVal也贼简单，第二种就是写代码的时候简单，但是跟着代码去心算不好算</p>
<p>关于next和nextVal的对比，引用自<a href="https://subetter.com/algorithm/kmp-algorithm.html">刘毅</a>：</p>
<blockquote>
<p><strong>KMP 算法（next）：</strong> next 数组表示最长的相同真前后缀的长度，我们不仅可以利用 next 来解决模式串的匹配问题，也可以用来解决类似字符串重复问题等等，这类问题大家可以在各大 OJ 找到，这里不作过多表述。</p>
<p><strong>KMP 算法（nextVal）：</strong> 根据代码很容易知道（名称也改为了 nextval），优化后的 next 仅仅表示相同真前后缀的长度，但<strong>不一定是最长</strong>（称其为 “最优相同真前后缀” 更为恰当）。此时我们利用优化后的 next 可以在模式串匹配问题中以更快的速度得到我们的答案（相较于未优化版），但是上述所说的字符串重复问题，优化版本则束手无策。</p>
<p>所以，该采用哪个版本，取决于你在现实中遇到的实际问题。</p>
</blockquote>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] nextVal(<span class="hljs-type">char</span>[] p) {
    <span class="hljs-type">int</span>[] nextVal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[p.length];
    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
    nextVal[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (j &lt; p.length - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (k == -<span class="hljs-number">1</span> || p[j] == p[k]) {
            j++;
            k++;
            <span class="hljs-keyword">if</span> (p[j] != p[k]) {
                nextVal[j] = k;
            } <span class="hljs-keyword">else</span> {
                nextVal[j] = nextVal[k];
            }
        } <span class="hljs-keyword">else</span> {
            k = nextVal[k];
        }
    }
    <span class="hljs-keyword">return</span> nextVal;
}
</code></pre>
<p>下面展示如何手算，首先有next：</p>
<table>
<thead>
<tr>
<th align="center">Index</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>text[i]</strong></td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center"><strong>next[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>和next一样，nextVal的首位nextVal[0]也是定值-1，然后从<strong>nextVal[1] = b开始描述手算：</strong></p>
<p>当<code>i = 1</code>时，<code>compare = next[i] = 0</code>，<code>text[i] == text[compare] 即 b = a 吗？</code>，结果不等于，则<code>nextVal[i] = next[i] = 0</code>；</p>
<table>
<thead>
<tr>
<th align="center">Index</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>text[i]</strong></td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center"><strong>next[i]</strong></td>
<td align="center">-1</td>
<td align="center">0⭐</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>nextVal[i]</strong></td>
<td align="center">-1</td>
<td align="center">0👈</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>当<code>i = 2</code>时，<code>compare = next[i] = 0</code>，<code>text[i] == text[compare] 即 a = a 吗？</code>，结果等于，则<code>nextVal[i] = nextVal[compare] = -1</code>；</p>
<table>
<thead>
<tr>
<th align="center">Index</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>text[i]</strong></td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center"><strong>next[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>nextVal[i]</strong></td>
<td align="center">-1⭐</td>
<td align="center">0</td>
<td align="center">-1👈</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>当<code>i = 3</code>时，<code>compare = next[i] = 1</code>，<code>text[i] == text[compare] 即 b = b 吗？</code>，结果等于，则<code>nextVal[i] = nextVal[compare] = 0</code>；</p>
<table>
<thead>
<tr>
<th align="center">Index</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>text[i]</strong></td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center"><strong>next[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>nextVal[i]</strong></td>
<td align="center">-1</td>
<td align="center">0⭐</td>
<td align="center">-1</td>
<td align="center">0👈</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>当<code>i = 4</code>时，<code>compare = next[i] = 2</code>，<code>text[i] == text[compare] 即 a = a 吗？</code>，结果等于，则<code>nextVal[i] = nextVal[compare] = -1</code>；</p>
<table>
<thead>
<tr>
<th align="center">Index</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>text[i]</strong></td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center"><strong>next[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>nextVal[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">-1⭐</td>
<td align="center">0</td>
<td align="center">-1👈</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>当<code>i = 5</code>时，<code>compare = next[i] = 3</code>，<code>text[i] == text[compare] 即 a = b 吗？</code>，结果不等于，则<code>nextVal[i] = next[i] = 3</code>；</p>
<table>
<thead>
<tr>
<th align="center">Index</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>text[i]</strong></td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center"><strong>next[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3⭐</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>nextVal[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">3👈</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>当<code>i = 6</code>时，<code>compare = next[i] = 1</code>，<code>text[i] == text[compare] 即 b = b 吗？</code>，结果等于，则<code>nextVal[i] = nextVal[compare] = 0</code>；</p>
<table>
<thead>
<tr>
<th align="center">Index</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>text[i]</strong></td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center"><strong>next[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>nextVal[i]</strong></td>
<td align="center">-1</td>
<td align="center">0⭐</td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">3</td>
<td align="center">0👈</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>当<code>i = 7</code>时，<code>compare = next[i] = 2</code>，<code>text[i] == text[compare] 即 a = a 吗？</code>，结果等于，则<code>nextVal[i] = nextVal[compare] = 0</code>；</p>
<table>
<thead>
<tr>
<th align="center">Index</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>text[i]</strong></td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center"><strong>next[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>naxtVal[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">-1⭐</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">-1👈</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>当<code>i = 8</code>时，<code>compare = next[i] = 3</code>，<code>text[i] == text[compare] 即 b = b 吗？</code>，结果等于，则<code>nextVal[i] = nextVal[compare] = 0</code>；</p>
<table>
<thead>
<tr>
<th align="center">Index</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>text[i]</strong></td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center"><strong>next[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center"><strong>nextVal[i]</strong></td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">0⭐</td>
<td align="center">-1</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">-1</td>
<td align="center">0👈</td>
</tr>
</tbody></table>
<p>下面用通俗一点的语言来解释一下怎么抓：</p>
<p><strong>当前要算的i位置上的next值作为compare下标，如果当前位置的字符和compare位置的字符相等，那么就抓compare位置对应的nextVal作为当前位置的nextVal，否则就拿自己的next作为自己的nextVal</strong></p>
<p>参考：</p>
<blockquote>
<p><a href="http://www.slyar.com/blog/kmp-next-nextval.html">http://www.slyar.com/blog/kmp-next-nextval.html</a></p>
<p><a href="https://www.nowcoder.com/profile/1105774/myFollowings/detail/6106514%EF%BC%88%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%9B%9E%E7%AD%94%EF%BC%89">https://www.nowcoder.com/profile/1105774/myFollowings/detail/6106514（第一条回答）</a></p>
</blockquote>

          <h6 id="32532b0d">表示法注意事项</h6><p>next的位移量多以-1开始表示，但是也有从0开始表示的，这样的情况下其实是一样的，只需要把-1那一组的next全+1就变成0那一组了；相对来说，-1的方法比较容易理解一点；</p>
<p>举例：</p>
<ul>
<li><a href="https://blog.csdn.net/nanami809/article/details/49367159">https://blog.csdn.net/nanami809/article/details/49367159</a></li>
<li><a href="https://blog.csdn.net/zhengjia0826/article/details/39895781">https://blog.csdn.net/zhengjia0826/article/details/39895781</a></li>
</ul>
<hr>

          <h4 id="31c91a7e">引用、参考</h4><p><a href="https://blog.csdn.net/u011489043/article/details/78683856">https://blog.csdn.net/u011489043/article/details/78683856</a></p>
